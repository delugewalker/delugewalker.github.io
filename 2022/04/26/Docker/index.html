

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/deluge.png">
  <link rel="icon" href="/img/deluge.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Deluge Walker">
  <meta name="keywords" content="">
  
    <meta name="description" content="title: Dockerdate: 2022-04-26 10:50:36tags:  Docker教程1 概述Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护，大概在2017年4月份左右Docker项目改名为Moby，可以在Github搜">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="http://example.com/2022/04/26/Docker/index.html">
<meta property="og:site_name" content="DelugeWalker的博客">
<meta property="og:description" content="title: Dockerdate: 2022-04-26 10:50:36tags:  Docker教程1 概述Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护，大概在2017年4月份左右Docker项目改名为Moby，可以在Github搜">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Nvidia-Docker.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-Deployment.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-SFTP-Connection.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-VM-Options.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-SFTP-Connection-ipv6.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-SFTP-Mappings.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-Interpret-Add.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-Interpret-Config.png">
<meta property="og:image" content="http://example.com/2022/04/26/Docker/Pycharm-Deployment-Options.png">
<meta property="article:published_time" content="2022-04-26T07:16:04.000Z">
<meta property="article:modified_time" content="2022-04-26T08:27:04.133Z">
<meta property="article:author" content="Deluge Walker">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/04/26/Docker/Nvidia-Docker.png">
  
  
  <title>Docker - DelugeWalker的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>DelugeWalker的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Docker"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-26 15:16" pubdate>
          April 26, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          190 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Docker</h1>
            
            <div class="markdown-body">
              
              <hr>
<p>title: Docker<br>date: 2022-04-26 10:50:36<br>tags:</p>
<hr>
<h1 id="Docker教程"><a href="#Docker教程" class="headerlink" title="Docker教程"></a>Docker教程</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护，大概在2017年4月份左右Docker项目改名为<a target="_blank" rel="noopener" href="https://github.com/moby/moby">Moby</a>，可以在Github搜索Moby找到这个项目。  </p>
<p>Docker的内核建立在LXC(Linux Container)之上，作为容器的一种，同传统的虚拟机比起来，容器内的应用&#x2F;进程直接运行在宿主机的内核上，容器没有自己的内核，所以容器更加轻量，运行效率也更高。同传统的虚拟机相比：Docker具有以下优点：  </p>
<ul>
<li>更高效的资源利用</li>
<li>快速启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>轻松迁移</li>
<li>轻松维护和扩展</li>
</ul>
<h2 id="2-Docker概念"><a href="#2-Docker概念" class="headerlink" title="2 Docker概念"></a>2 Docker概念</h2><ul>
<li><strong>镜像 Image</strong><br>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li>
<li><strong>容器 Container</strong><br>Docker容器是Docker镜像的实例，镜像启动后可生成一个Docker实例，它可以被开始、停止、删除、每个容器都是互相隔离的，保证安全的平台，可以把容器看做是要给简易版的linux环境(包括root用户权限、镜像空间、用户空间和网络空间等)和运行在其中的应用程序当然也可以将Docker实例保存为一个镜像，供其他用户使用。</li>
<li><strong>仓库 Repository</strong><br>Docker仓库是保存Docker镜像的地方，Docker的默认镜像仓库是在<code>hub.docker.com</code>，但用户只能在官网创建一个<code>private</code>项目，有些组织并不希望自己的镜像成为<code>public</code>项目(比如打包了云源码)，这时用户可以使用<code>registry</code>构建自己的仓库。</li>
</ul>
<h2 id="3-Docker常用命令"><a href="#3-Docker常用命令" class="headerlink" title="3 Docker常用命令"></a>3 Docker常用命令</h2><h3 id="3-1-Docker安装"><a href="#3-1-Docker安装" class="headerlink" title="3.1 Docker安装"></a>3.1 Docker安装</h3><h4 id="3-1-1-Linux安装"><a href="#3-1-1-Linux安装" class="headerlink" title="3.1.1 Linux安装"></a>3.1.1 Linux安装</h4><p>接下来将基于<code>Ubuntu20.04</code>操作系统讲解Docker命令。</p>
<h5 id="3-1-1-1-Docker安装"><a href="#3-1-1-1-Docker安装" class="headerlink" title="3.1.1.1 Docker安装"></a>3.1.1.1 Docker安装</h5><p><strong>第一种 安装<code>docker</code></strong></p>
<ul>
<li><p>安装docker</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install docker<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装nvidia-docker<br>  nvidia-docker是一个可以使用GPU的docker，它在docker上做了一层封装，通过nvidia-docker-plugin，然后调用到docker上，其最终实现的还是在docker的启动命令上携带一些必要的参数。因此在安装nvidia-docker之前，还是需要安装docker的。</p>
  <center>
  <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Nvidia-Docker.png" srcset="/img/loading.gif" lazyload alt="Nvidia Docker结构" width="60%">
  </center>

<p>  docker一般都是使用基于CPU的应用，而如果是GPU的话，就需要安装特有的硬件环境，比如需要安装nvidia driver，所以docker容器并不直接支持Nvidia GPU。为了使docker image能很便利的使用Nvidia GPU，从而产生了nvidia-docker，由它来制作nvidia driver的image，这就要求在目标机器上启动container时，确保字符设备以及驱动文件已经被挂载。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install -y nvidia-docker2<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>第二种 安装<code>docker.io</code>(推荐)</strong></p>
<p>Docker19版本更新了GPU驱动使用参数，下面介绍具体的安装方法。</p>
<ul>
<li><p><code>docker-ce</code>与<code>docker-io</code>的区别<br>  <code>docker-ce</code>是由docker团队认证并维护的一个社区版发行包，<code>docker.io</code>是ubuntu团队维护的一个包。由于之前ubuntu团队有很长一段时间没有维护docker的版本，导致有一段时间docker.io的版本还停留在远古版本。后来ubuntu版本重新开始维护，版本继续送代，截止2021-05-14日，版本已经更新到<code>Docker version 20.10.2</code>。两者使用相同的包管理，<code>docker-ce</code>是所有依赖包由docker团队管理，可以保证docker运行的稳定，适合作为纯docker管理的生产环境，即整个系统只有一个docker在跑，剩下所有应用都通过发布docker的容器来部署。<code>docker-io</code>的依赖包则是由ubuntu统一管理，更符合包管理的理念，也更规范，可以尽可能的保证系统和多个软件的运行稳定，适合作为多软件协同运行的服务器和个人桌面使用。Docker目前是一个被广泛使用的工具，ubuntu再次停止维护的概率不大。所以除了纯docker环境，个人建议直接用<code>docker.io</code>。</p>
</li>
<li><p>安装<code>docker.io</code></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Install Docker</span><br>sudo apt install docker.io<br></code></pre></td></tr></table></figure>
</li>
<li><p>在线安装nvidia-container-toolkit</p>
<ul>
<li><p>首先配置package repositories</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Get system version</span><br>distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)<br><span class="hljs-comment"># add public key</span><br>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -<br><span class="hljs-comment"># add source</span><br>curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list<br>sudo apt-get update<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装nvidia-container-toolkit</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bsah">sudo apt-get install -y nvidia-container-toolkit<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>离线安装nvidia-container-toolkit</p>
<ul>
<li><p>在有网络连接的设备上配置package repositories</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Get system version</span><br>distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)<br><span class="hljs-comment"># add public key</span><br>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -<br><span class="hljs-comment"># add source</span><br>curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list<br>sudo apt-get update<br></code></pre></td></tr></table></figure>
</li>
<li><p>下载nvidia-container-toolkit套件</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bsah">apt download libnvidia-container1<br>apt download libnvidia-container-tools<br>apt download nvidia-container-toolkit<br>apt download nvidia-container-runtime<br>apt download nvidia-docker2<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装nvidia-container-toolkit套件(以下顺序不能改变)</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bsah">dpkg -i libnvidia-container1_***.deb<br>dpkg -i libnvidia-container-tools_***.deb<br>dpkg -i nvidia-container-toolkit_***.deb<br>dpkg -i nvidia-container-runtime_***.deb<br>dpkg -i nvidia-docker2_***.deb<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>安装完成后重启Docker</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart docker<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用该版本Docker创建容器时使用<code>--gpus</code>参数指定使用的GPU编号：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -it --gpus all imagename<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-1-1-2-加入Docker用户组"><a href="#3-1-1-2-加入Docker用户组" class="headerlink" title="3.1.1.2 加入Docker用户组"></a>3.1.1.2 加入Docker用户组</h5><ul>
<li><p>创建docker用户组</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></figure>
</li>
<li><p>将用户加入docker用户组</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$&#123;USER&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>重启docker服务</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart docker<br></code></pre></td></tr></table></figure>
</li>
<li><p>切换或者退出当前账户，再重新登入</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su root<br>su <span class="hljs-variable">$&#123;USER&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>添加访问和执行权限(普通用户可不加<code>sudo</code>使用docker)</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> a+rw /var/run/docker.sock<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-1-1-3-查看Docker安装信息"><a href="#3-1-1-3-查看Docker安装信息" class="headerlink" title="3.1.1.3 查看Docker安装信息"></a>3.1.1.3 查看Docker安装信息</h5><p>使用<code>docker info</code>查看 Docker 系统信息，包括镜像和容器数。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker info <br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>查看Docker版本信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker info<br></code></pre></td></tr></table></figure>


<h5 id="3-1-1-4-查看Docker版本"><a href="#3-1-1-4-查看Docker版本" class="headerlink" title="3.1.1.4 查看Docker版本"></a>3.1.1.4 查看Docker版本</h5><p>使用<code>docker version</code>查看Docker的版本信息。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version [Options]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-f：指定返回值的模板文件</li>
</ul>
<p><strong>示例：</strong><br>查看Docker版本信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure>

<h5 id="3-1-1-5-卸载Docker"><a href="#3-1-1-5-卸载Docker" class="headerlink" title="3.1.1.5 卸载Docker"></a>3.1.1.5 卸载Docker</h5><ul>
<li>确定您拥有什么已安装的软件包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -l | grep -i docker<br></code></pre></td></tr></table></figure>

<ul>
<li>删除软件包服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get purge -y docker.io docker-engine docker<br>sudo apt-get autoremove -y --purge docker.io docker-engine docker<br></code></pre></td></tr></table></figure>

<ul>
<li>删除主机上的映像，容器，卷或用户创建的配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> -rf /var/lib/docker /etc/docker<br>sudo <span class="hljs-built_in">rm</span> /etc/apparmor.d/docker<br>sudo groupdel docker<br>sudo <span class="hljs-built_in">rm</span> -rf /var/run/docker.sock<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-1-2-Windows安装"><a href="#3-1-2-Windows安装" class="headerlink" title="3.1.2 Windows安装"></a>3.1.2 Windows安装</h4><h5 id="3-1-2-1-启动依赖环境"><a href="#3-1-2-1-启动依赖环境" class="headerlink" title="3.1.2.1 启动依赖环境"></a>3.1.2.1 启动依赖环境</h5><ul>
<li><p><strong>Hyper-V</strong></p>
<ul>
<li><p>以管理员身份运行Powershell：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All<br></code></pre></td></tr></table></figure>
</li>
<li><p>在BIOS中开启Virtualization<br>  不同的主板设置不同，基本位于Advanced-&gt;CPU设置中。</p>
</li>
</ul>
</li>
<li><p><strong>WSL2</strong></p>
<ul>
<li>必须运行Windows10版本2004及更高版本(内部版本19041及更高版本)或Windows 11。</li>
<li>Windows11中默认安装了WSL内核，如果没有可手动安装。</li>
<li>以管理员身份运行Powershell：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --install<br></code></pre></td></tr></table></figure>
  此命令将启用所需的可选组件，下载最新的Linux内核，将WSL2设置为默认值，并安装 Linux发行版(默认安装Ubuntu)。</li>
</ul>
</li>
</ul>
<h5 id="3-1-2-2-安装Docker-Desktop-for-Windows"><a href="#3-1-2-2-安装Docker-Desktop-for-Windows" class="headerlink" title="3.1.2.2 安装Docker Desktop for Windows"></a>3.1.2.2 安装Docker Desktop for Windows</h5><ul>
<li><p>下载安装包<br>  进入<a target="_blank" rel="noopener" href="https://hub.docker.com/?overlay=onboarding">Dokcer官网下载地址</a>，并下载Windows的版本Docker，如果你还没有登录，会要求注册登录。</p>
</li>
<li><p>安装<br>  双击安装文件并根据指引完成安装。</p>
</li>
</ul>
<h5 id="3-1-2-3-下载Linux内核更新包"><a href="#3-1-2-3-下载Linux内核更新包" class="headerlink" title="3.1.2.3 下载Linux内核更新包"></a>3.1.2.3 下载Linux内核更新包</h5><p>启动Docker Desktop时可能会要求更新WSL内核版本，在<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">WSL文档中</a>获取<a target="_blank" rel="noopener" href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于x64计算机的WSL2 Linux内核更新包</a>。完成安装后重启Docker即可。</p>
<h5 id="3-1-2-4-注意事项"><a href="#3-1-2-4-注意事项" class="headerlink" title="3.1.2.4 注意事项"></a>3.1.2.4 注意事项</h5><ul>
<li>docker运行出现错误<code>error during connect: This error may indicate that the docker daemon is not running.:</code><ul>
<li>powershell进入目录”C:\Program Files\Docker\Docker”  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Docker\Docker&quot;</span><br></code></pre></td></tr></table></figure></li>
<li>执行以下命令  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./DockerCli.exe -SwitchDaemon<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h3><h4 id="3-2-1-登入-x2F-登出-login-x2F-logout"><a href="#3-2-1-登入-x2F-登出-login-x2F-logout" class="headerlink" title="3.2.1 登入&#x2F;登出(login&#x2F;logout)"></a>3.2.1 登入&#x2F;登出(login&#x2F;logout)</h4><p>使用<code>docker login</code>登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub；<br>使用<code>docker logout</code>登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub。<br><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker login [Options] [Server]<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">logout</span> [Options] [Server]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-u：登陆的用户名</li>
<li>-p：登陆的密码</li>
</ul>
<p><strong>示例：</strong><br>登陆到Docker Hub。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker login -u username -p password<br></code></pre></td></tr></table></figure>
<p>登出Docker Hub。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">logout</span><br></code></pre></td></tr></table></figure>


<h4 id="3-2-2-查找镜像-search"><a href="#3-2-2-查找镜像-search" class="headerlink" title="3.2.2 查找镜像(search)"></a>3.2.2 查找镜像(search)</h4><p>使用<code>docker search</code>从Docker Hub查找镜像。<br><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search [Options] TERM<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>–automated：只列出 automated build类型的镜像</li>
<li>–no-trunc：显示完整的镜像描述</li>
<li>-s：列出收藏数不小于指定值的镜像</li>
</ul>
<p><strong>查找到的镜像列表包含：</strong></p>
<ul>
<li><strong>NAME</strong> 镜像名称</li>
<li><strong>DESCRIPTION</strong> 镜像描述</li>
<li><strong>STARS</strong> 星标数量</li>
<li><strong>OFFICIAL</strong> 是否为官方镜像</li>
<li><strong>AUTOMATED</strong> 是否是自动构建的镜像</li>
</ul>
<p><strong>示例：</strong><br>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search -s 10 java<br></code></pre></td></tr></table></figure>


<h4 id="3-2-3-拉取镜像-pull"><a href="#3-2-3-拉取镜像-pull" class="headerlink" title="3.2.3 拉取镜像(pull)"></a>3.2.3 拉取镜像(pull)</h4><p>使用<code>docker pull</code>从镜像仓库中拉取或者更新指定镜像。<br><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull [Options] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-a：拉取所有tagged镜像</li>
<li>–disable-content-trust：忽略镜像的校验，默认开启</li>
</ul>
<p><strong>示例：</strong><br>从Docker Hub下载<code>java</code>最新版镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull java<br></code></pre></td></tr></table></figure>

<p>从Docker Hub下载<code>Repository</code>为<code>java</code>的所有镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull -a java<br></code></pre></td></tr></table></figure>


<h4 id="3-2-4-上传镜像-push"><a href="#3-2-4-上传镜像-push" class="headerlink" title="3.2.4 上传镜像(push)"></a>3.2.4 上传镜像(push)</h4><p>使用<code>docker push</code>将本地的镜像上传到镜像仓库，要先登陆到镜像仓库<br><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push [Options] NAME[:TAG]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>–disable-content-trust：忽略镜像的校验，默认开启</li>
</ul>
<p><strong>示例：</strong><br>上传本地镜像<code>myapache:v1</code>到镜像仓库中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push myapache:v1<br></code></pre></td></tr></table></figure>

<h4 id="3-2-5-查看镜像-images"><a href="#3-2-5-查看镜像-images" class="headerlink" title="3.2.5 查看镜像(images)"></a>3.2.5 查看镜像(images)</h4><p>使用<code>docker images</code>查看本地存在的镜像。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images [Options] [Repository[:Tag]]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-a：列出本地所有的镜像(含中间映像层，默认情况下，过滤掉中间映像层)</li>
<li>–digests：显示镜像的摘要信息</li>
<li>-f：显示满足条件的镜像</li>
<li>–format：指定返回值的模板文件</li>
<li>–no-trunc：显示完整的镜像信息</li>
<li>-q：只显示镜像ID</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure>

<p>列出的镜像列表包含以下信息：</p>
<ul>
<li><strong>REPOSITORY</strong> 镜像来自于哪个仓库，比如ubuntu</li>
<li>**TAG ** 镜像的标记，比如 14.04</li>
<li><strong>IMAGE ID</strong> 镜像的ID号(唯一)</li>
<li><strong>CREATED</strong> 镜像创建时间</li>
<li><strong>VIRTUAL SIZE</strong> 镜像大小</li>
</ul>
<h4 id="3-2-6-载入镜像-load"><a href="#3-2-6-载入镜像-load" class="headerlink" title="3.2.6 载入镜像(load)"></a>3.2.6 载入镜像(load)</h4><p>使用 <code>docker load</code>对于本地其他方式获得的镜像进行导入。</p>
<p><strong>语法：</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">docker</span> <span class="hljs-variable">load</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Options</span><span class="hljs-punctuation">]</span> <span class="hljs-built_in">Image</span><br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>–input ， -i：指定导入的文件，代替 STDIN。</li>
<li>–quiet ， -q：精简输出信息。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker load --input fedora.tar<br></code></pre></td></tr></table></figure>

<h4 id="3-2-7-存出镜像-save"><a href="#3-2-7-存出镜像-save" class="headerlink" title="3.2.7 存出镜像(save)"></a>3.2.7 存出镜像(save)</h4><p>可以使用<code>docker save</code>将指定镜像保存成tar归档文件。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker save [Options] Image<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-o：输出到的文件。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker save -o ubuntu_16.04.tar ubuntu:16.04<br></code></pre></td></tr></table></figure>

<h4 id="3-2-8-删除镜像-rmi"><a href="#3-2-8-删除镜像-rmi" class="headerlink" title="3.2.8 删除镜像(rmi)"></a>3.2.8 删除镜像(rmi)</h4><p>使用<code>docker rmi</code>删除镜像。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi [Options] Image<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-f：强制删除</li>
<li>–no-prune：不移除该镜像的过程镜像，默认移除</li>
</ul>
<p><strong>示例：</strong><br>强制删除本地镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f ubuntu_16.04.tar<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><code>docker rm</code>命令是删除容器，而<code>docker rmi</code>命令是删除镜像(remove <strong>i</strong>mage)。</li>
<li>当出现同一个Image ID对应多个Repository:Tag时，使用<code>docker rmi Repository:Tag</code>可以删除对应的镜像，此时会显示<code>Untagged: Repository:Tag</code>；而加上参数<code>-f</code>，使用<code>docker rmi -f ImageID</code>会删除对应Image ID的所有镜像。</li>
</ul>
</blockquote>
<h4 id="3-2-9-创建Dockerfile"><a href="#3-2-9-创建Dockerfile" class="headerlink" title="3.2.9 创建Dockerfile"></a>3.2.9 创建Dockerfile</h4><p>我们可以使用<code>docker build</code>来创建一个新的镜像。首先需要创建一个Dockerfile，包含一些如何创建镜像的指令。</p>
<p>新建一个目录和一个Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> Dockerfile<br></code></pre></td></tr></table></figure>

<p>在Dockerfile中写入创建信息，Dockerfile 中每一条指令都创建镜像的一层，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># This is a comment</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">14.04</span><br><span class="hljs-keyword">MAINTAINER</span> Docker Newbee &lt;newbee@docker.com&gt;<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -qq update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -qqy install ruby ruby-dev</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> gem install sinatra</span><br></code></pre></td></tr></table></figure>
<p><strong>Dockerfile 基本的语法是：</strong></p>
<ul>
<li><code>#</code> 注释</li>
<li><code>FROM</code> 告诉Docker使用哪个镜像作为基础</li>
<li><code>MAINTAINER</code> 维护者信息</li>
<li><code>RUN</code> 该指令会在创建中运行，比如安装一个软件包，在这里使用<code>apt-get</code>来安装了一些软件</li>
</ul>
<h4 id="3-2-10-从Dockerfile创建镜像-build"><a href="#3-2-10-从Dockerfile创建镜像-build" class="headerlink" title="3.2.10 从Dockerfile创建镜像(build)"></a>3.2.10 从Dockerfile创建镜像(build)</h4><p>对于已有的Dockerfile，可以使用<code>docker build</code>来生成镜像。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build [Options] Path | Url | -<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-f：指定要使用的Dockerfile路径</li>
<li>-t &#x2F; -tag：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签</li>
<li>–build-arg&#x3D;[]：设置镜像创建时的变量</li>
<li>–cpu-shares：设置 cpu 使用权重</li>
<li>–cpu-period：限制 CPU CFS周期</li>
<li>–cpu-quota：限制 CPU CFS配额</li>
<li>–cpuset-cpus：指定使用的CPU id</li>
<li>–cpuset-mems：指定使用的内存 id</li>
<li>–disable-content-trust：忽略校验，默认开启</li>
<li>–force-rm：设置镜像过程中删除中间容器</li>
<li>–isolation：使用容器隔离技术</li>
<li>–label&#x3D;[]：设置镜像使用的元数据</li>
<li>-m：设置内存最大值</li>
<li>–memory-swap：设置Swap的最大值为内存+swap，”-1”表示不限swap</li>
<li>–no-cache：创建镜像的过程不使用缓存</li>
<li>–pull：尝试去更新镜像的新版本</li>
<li>–quiet， -q：安静模式，成功后只输出镜像ID</li>
<li>–rm：设置镜像成功后删除中间容器</li>
<li>–shm-size：设置&#x2F;dev&#x2F;shm的大小，默认值是64M</li>
<li>–ulimit：Ulimit配置</li>
<li>–squash：将 Dockerfile 中所有的操作压缩为一层</li>
<li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li>
</ul>
<p><strong>示例：</strong><br>使用当前目录(用<code>.</code>表示)的 Dockerfile 创建镜像，标签为 walker&#x2F;ubuntu:v1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t walker/ubuntu:v1 . <br></code></pre></td></tr></table></figure>
<p>使用URL github.com&#x2F;creack&#x2F;docker-firefox 的 Dockerfile 创建镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build github.com/creack/docker-firefox<br></code></pre></td></tr></table></figure>
<p>也可以通过<code>-f</code>指定Dockerfile文件的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -f /path/to/a/Dockerfile .<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong>  </p>
<blockquote>
<p>在使用<code>docker build</code>命令时，<code>Docker client</code>会发送执行命令时同级目录下的所有文件到<code>Docker daemon</code>，因此建议<code>cd</code>到Dockerfile所在路径，并保证该路径下无其他大文件。</p>
</blockquote>
<h4 id="3-2-11-标记镜像-tag"><a href="#3-2-11-标记镜像-tag" class="headerlink" title="3.2.11 标记镜像(tag)"></a>3.2.11 标记镜像(tag)</h4><p>使用<code>docker tag</code>标记本地镜像，将其归入某一仓库。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag [Options] Image[:Tag] [RegistryHost/][Username/]Name[:Tag]<br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>将镜像ubuntu:15.10标记为 walker&#x2F;ubuntu:v3 镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag ubuntu:15.10 walker/ubuntu:v3<br></code></pre></td></tr></table></figure>


<h4 id="3-2-12-镜像历史-history"><a href="#3-2-12-镜像历史-history" class="headerlink" title="3.2.12 镜像历史(history)"></a>3.2.12 镜像历史(history)</h4><p>使用<code>docker history</code>查看指定镜像的创建历史。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> [Options] Image<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-H：以可读的格式打印镜像大小和日期，默认为true</li>
<li>–no-trunc：显示完整的提交记录</li>
<li>-q：仅列出提交记录ID</li>
</ul>
<p><strong>示例：</strong><br>查看本地镜像walker&#x2F;ubuntu:v3的创建历史。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> walker/ubuntu:v3<br></code></pre></td></tr></table></figure>

<h4 id="3-2-13-导入镜像-import"><a href="#3-2-13-导入镜像-import" class="headerlink" title="3.2.13 导入镜像(import)"></a>3.2.13 导入镜像(import)</h4><p>使用<code>docker import</code>从归档文件中创建镜像。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker import [Options] file|URL|- [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-c：应用docker 指令创建镜像</li>
<li>-m：提交时的说明文字</li>
</ul>
<p><strong>示例：</strong><br>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为walker&#x2F;ubuntu:v4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker import my_ubuntu_v3.tar walker/ubuntu:v4<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> </p>
<blockquote>
<ul>
<li><code>import</code>与[<code>export</code>](# 3.3.3 导出容器(export))是一对命令，<code>export</code>用于从<strong>容器</strong>导出得到归档文件；而<code>import</code>用于导入归档文件获得镜像 。</li>
<li><code>save</code>与<code>load</code>是一对命令，<code>save</code>用于将镜像到处得到归档文件；而load用于导入归档文件获得镜像。</li>
<li>这四个命令中只有<code>export</code>的操作对象是容器。</li>
</ul>
</blockquote>
<h3 id="3-3-容器操作"><a href="#3-3-容器操作" class="headerlink" title="3.3 容器操作"></a>3.3 容器操作</h3><h4 id="3-3-1-列出容器-ps"><a href="#3-3-1-列出容器-ps" class="headerlink" title="3.3.1 列出容器(ps)"></a>3.3.1 列出容器(ps)</h4><p>使用<code>docker ps</code>列出容器。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps [Options]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-a：显示所有的容器，包括未运行的</li>
<li>-f：根据条件过滤显示的内容</li>
<li>–format：指定返回值的模板文件</li>
<li>-l：显示最近创建的容器</li>
<li>-n：列出最近创建的n个容器</li>
<li>–no-trunc：不截断输出</li>
<li>-q：静默模式，只显示容器编号</li>
<li>-s：显示总的文件大小</li>
</ul>
<p><strong>示例：</strong><br>列出所有在运行的容器信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure>


<h4 id="3-3-2-连接进入容器-attach"><a href="#3-3-2-连接进入容器-attach" class="headerlink" title="3.3.2 连接进入容器(attach)"></a>3.3.2 连接进入容器(attach)</h4><p>使用<code>docker attach</code>连接到正在运行中的容器。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker attach [Options] CONTAINER<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> </p>
<blockquote>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕(与screen命令的attach类似)。官方文档中说attach后可以通过Ctrl+C来detach，但实际上经过我的测试，如果container当前在运行bash，Ctrl+C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，Ctrl+C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy&#x3D;false来确保Ctrl+D或Ctrl+C不会关闭容器。</p>
</blockquote>
<p><strong>示例：</strong><br>容器<code>mynginx</code>将访问日志指到标准输出，连接到容器查看访问信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker attach --sig-proxy=<span class="hljs-literal">false</span> mynginx<br></code></pre></td></tr></table></figure>


<h4 id="3-3-3-导出容器-export"><a href="#3-3-3-导出容器-export" class="headerlink" title="3.3.3 导出容器(export)"></a>3.3.3 导出容器(export)</h4><p>使用<code>docker export</code>将文件系统作为一个tar归档文件导出。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> [Options] CONTAINER<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-o：将输入内容写到文件。</li>
</ul>
<p><strong>示例：</strong><br>将<code>id</code>为<code>a404c6c174a2</code>的容器按日期保存为tar文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> -o mysql-`<span class="hljs-built_in">date</span> +%Y%m%d`.tar a404c6c174a2<br></code></pre></td></tr></table></figure>


<h4 id="3-3-4-获取元数据-inspect"><a href="#3-3-4-获取元数据-inspect" class="headerlink" title="3.3.4 获取元数据(inspect)"></a>3.3.4 获取元数据(inspect)</h4><p>使用<code>docker inspect</code>获取容器&#x2F;镜像的元数据。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect [Options] NAME|ID [NAME|ID...]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-f：指定返回值的模板文件</li>
<li>-s：显示总的文件大小</li>
<li>–type：为指定类型返回JSON</li>
</ul>
<p><strong>示例：</strong><br>获取镜像mysql:5.6的元信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect mysql:5.6<br></code></pre></td></tr></table></figure>


<h4 id="3-3-5-容器进程-top"><a href="#3-3-5-容器进程-top" class="headerlink" title="3.3.5 容器进程(top)"></a>3.3.5 容器进程(top)</h4><p>使用<code>docker top</code>查看容器中运行的进程信息，支持<code>ps</code>命令参数。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker top [Options] Container [ps Options]<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p>容器运行时不一定有<code>/bin/bash</code>终端来交互执行<code>top</code>命令，而且容器还不一定有<code>top</code>命令，可以使用<code>docker top</code>来实现查看container中正在运行的进程。</p>
</blockquote>
<p><strong>示例：</strong><br>查看容器<code>mymysql</code>的进程信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker top mymysql<br></code></pre></td></tr></table></figure>


<h4 id="3-3-6-容器事件-events"><a href="#3-3-6-容器事件-events" class="headerlink" title="3.3.6 容器事件(events)"></a>3.3.6 容器事件(events)</h4><p>使用<code>docker events</code>从服务器获取实时事件。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker events [Options]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-f ：根据条件过滤事件；</li>
<li>–since ：从指定的时间戳后显示所有事件;</li>
<li>–until ：流水时间显示到指定的时间为止；</li>
</ul>
<p><strong>示例：</strong><br>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker events -f <span class="hljs-string">&quot;image&quot;</span>=<span class="hljs-string">&quot;mysql:5.6&quot;</span> --since=<span class="hljs-string">&quot;1467302400&quot;</span> <br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如<code>--since=&quot;2016-07-01</code>。</p>
</blockquote>
<h4 id="3-3-7-容器日志-logs"><a href="#3-3-7-容器日志-logs" class="headerlink" title="3.3.7 容器日志(logs)"></a>3.3.7 容器日志(logs)</h4><p>使用<code>docker logs</code>获取容器的日志。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs [Options] Container<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-f： 跟踪日志输出</li>
<li>–since：显示某个开始时间的所有日志</li>
<li>-t： 显示时间戳</li>
<li>–tail：仅列出最新N条容器日志</li>
</ul>
<p><strong>示例：</strong><br>跟踪查看容器mynginx的日志输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f mynginx<br></code></pre></td></tr></table></figure>

<p>查看容器mynginx从2016年7月1日后的最新10条日志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs --since=<span class="hljs-string">&quot;2016-07-01&quot;</span> --<span class="hljs-built_in">tail</span>=10 mynginx<br></code></pre></td></tr></table></figure>


<h4 id="3-3-8-阻塞容器-wait"><a href="#3-3-8-阻塞容器-wait" class="headerlink" title="3.3.8 阻塞容器(wait)"></a>3.3.8 阻塞容器(wait)</h4><p>使用<code>docker wait</code>阻塞运行直到容器停止，然后打印出它的退出代码。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">wait</span> [Options] Container [Container...]<br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>跟踪查看容器mynginx的日志输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">wait</span> mynginx<br></code></pre></td></tr></table></figure>



<h4 id="3-3-9-容器端口-port"><a href="#3-3-9-容器端口-port" class="headerlink" title="3.3.9 容器端口(port)"></a>3.3.9 容器端口(port)</h4><p>使用<code>docker port</code>列出指定的容器的端口映射，或者查找将<code>PRIVATE_PORT NAT</code>到面向公众的端口。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker port [Options] Container [Private_Port[/Proto]]<br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>查看容器mynginx的端口映射情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker port mymysql<br></code></pre></td></tr></table></figure>


<h4 id="3-3-10-容器提交-commit"><a href="#3-3-10-容器提交-commit" class="headerlink" title="3.3.10 容器提交(commit)"></a>3.3.10 容器提交(commit)</h4><p>使用<code>docker commit</code>从容器创建一个新的镜像。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit [Options] Container [Repository[:Tag]]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-a：提交的镜像作者；</li>
<li>-c：使用Dockerfile指令来创建镜像；</li>
<li>-m：提交时的说明文字；</li>
<li>-p：在commit时，将容器暂停。</li>
</ul>
<p><strong>yuhong示例：</strong><br>将容器<code>a404c6c174a2</code>保存为新的镜像，并添加提交人信息和说明信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit -a <span class="hljs-string">&quot;walker.com&quot;</span> -m <span class="hljs-string">&quot;my apache&quot;</span> a404c6c174a2  mymysql:v1 <br></code></pre></td></tr></table></figure>


<h4 id="3-3-11-容器数据拷贝-cp"><a href="#3-3-11-容器数据拷贝-cp" class="headerlink" title="3.3.11 容器数据拷贝(cp)"></a>3.3.11 容器数据拷贝(cp)</h4><p>使用<code>docker cp</code>进行容器与主机之间的数据拷贝。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> [Options] Container:Src_Path Dest_Path|-<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> [Options] Src_Path|- Container:Dedt_Path<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-L：保持源目标中的链接</li>
</ul>
<p><strong>示例：</strong><br>将主机<code>/www/walker</code>目录拷贝到容器<code>96f7f14e99ab</code>的<code>/www</code>目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /www/walker 96f7f14e99ab:/www/<br></code></pre></td></tr></table></figure>

<p>将主机<code>/www/walker</code>目录拷贝到容器<code>96f7f14e99ab</code>中，目录重命名为<code>www</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /www/walker 96f7f14e99ab:/www<br></code></pre></td></tr></table></figure>

<p>将容器<code>96f7f14e99ab</code>的<code>/www</code>目录拷贝到主机的<code>/tmp</code>目录中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span>  96f7f14e99ab:/www /tmp/<br></code></pre></td></tr></table></figure>



<h4 id="3-3-12-容器文件结构-diff"><a href="#3-3-12-容器文件结构-diff" class="headerlink" title="3.3.12 容器文件结构(diff)"></a>3.3.12 容器文件结构(diff)</h4><p>使用<code>docker diff</code>检查容器里文件结构的更改。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker diff [Options] Container<br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>查看容器mymysql的文件结构更改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker diff mymysql<br></code></pre></td></tr></table></figure>



<h3 id="3-4-容器生命周期管理"><a href="#3-4-容器生命周期管理" class="headerlink" title="3.4 容器生命周期管理"></a>3.4 容器生命周期管理</h3><h4 id="3-4-1-创建容器-create"><a href="#3-4-1-创建容器-create" class="headerlink" title="3.4.1 创建容器(create)"></a>3.4.1 创建容器(create)</h4><p>使用<code>docker create</code>创建一个新的容器但不启动它。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create [Options] Inage [Command] [Arg...]<br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>使用docker镜像nginx:latest创建一个容器，并将容器命名为mywalker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker create --name mywalker nginx:latest<br></code></pre></td></tr></table></figure>

<h4 id="3-4-2-运行容器-run"><a href="#3-4-2-运行容器-run" class="headerlink" title="3.4.2 运行容器(run)"></a>3.4.2 运行容器(run)</h4><p>使用<code>docker run</code>创建一个新的容器并运行一个命令。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run [Options] Image [Command] [Arg...]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<table>
<thead>
<tr>
<th align="left">option</th>
<th align="left">descriptipon</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-a， –attach&#x3D;[]</td>
<td align="left">指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项</td>
</tr>
<tr>
<td align="left">–add-host&#x3D;[]</td>
<td align="left">Add a custom host-to-IP mapping (host:ip)</td>
</tr>
<tr>
<td align="left">–blkio-weight&#x3D;0</td>
<td align="left">Block IO (relative weight)， between 10 and 1000</td>
</tr>
<tr>
<td align="left">–cpu-shares&#x3D;0</td>
<td align="left">CPU shares (relative weight)</td>
</tr>
<tr>
<td align="left">–cap-add&#x3D;[]</td>
<td align="left">Add Linux capabilities</td>
</tr>
<tr>
<td align="left">–cap-drop&#x3D;[]</td>
<td align="left">Drop Linux capabilities</td>
</tr>
<tr>
<td align="left">–cgroup-parent&#x3D;</td>
<td align="left">Optional parent cgroup for the container</td>
</tr>
<tr>
<td align="left">–cidfile&#x3D;</td>
<td align="left">Write the container ID to the file</td>
</tr>
<tr>
<td align="left">–cpu-period&#x3D;0</td>
<td align="left">Limit CPU CFS (Completely Fair Scheduler) period</td>
</tr>
<tr>
<td align="left">–cpu-quota&#x3D;0</td>
<td align="left">Limit CPU CFS (Completely Fair Scheduler) quota</td>
</tr>
<tr>
<td align="left">–cpuset-cpus&#x3D;</td>
<td align="left">CPUs in which to allow execution (0-3， 0，1)</td>
</tr>
<tr>
<td align="left">–cpuset-mems&#x3D;</td>
<td align="left">MEMs in which to allow execution (0-3， 0，1)</td>
</tr>
<tr>
<td align="left">-d， –detach&#x3D;false</td>
<td align="left">后台运行容器，并返回容器ID</td>
</tr>
<tr>
<td align="left">–device&#x3D;[]</td>
<td align="left">Add a host device to the container</td>
</tr>
<tr>
<td align="left">–disable-content-trust&#x3D;true</td>
<td align="left">Skip image verification</td>
</tr>
<tr>
<td align="left">–dns&#x3D;[]</td>
<td align="left">指定容器使用的DNS服务器，默认和宿主一致</td>
</tr>
<tr>
<td align="left">–dns-opt&#x3D;[]</td>
<td align="left">Set DNS options</td>
</tr>
<tr>
<td align="left">–dns-search&#x3D;[]</td>
<td align="left">指定容器DNS搜索域名，默认和宿主一致</td>
</tr>
<tr>
<td align="left">-e， –env&#x3D;[]</td>
<td align="left">设置环境变量</td>
</tr>
<tr>
<td align="left">–entrypoint&#x3D;</td>
<td align="left">Overwrite the default ENTRYPOINT of the image</td>
</tr>
<tr>
<td align="left">–env-file&#x3D;[]</td>
<td align="left">从指定文件读入环境变量</td>
</tr>
<tr>
<td align="left">–expose&#x3D;[]</td>
<td align="left">开放一个端口或一组端口</td>
</tr>
<tr>
<td align="left">–gpu</td>
<td align="left">使用GPU启动</td>
</tr>
<tr>
<td align="left">–group-add&#x3D;[]</td>
<td align="left">Add additional groups to join</td>
</tr>
<tr>
<td align="left">-h， –hostname&#x3D;</td>
<td align="left">指定容器的hostname</td>
</tr>
<tr>
<td align="left">–help&#x3D;false</td>
<td align="left">Print usage</td>
</tr>
<tr>
<td align="left">-i， –interactive&#x3D;false</td>
<td align="left">以交互模式运行容器，通常与<code>-t</code>一起同时使用</td>
</tr>
<tr>
<td align="left">–ipc&#x3D;</td>
<td align="left">IPC namespace to use</td>
</tr>
<tr>
<td align="left">–kernel-memory&#x3D;</td>
<td align="left">Kernel memory limit</td>
</tr>
<tr>
<td align="left">-l， –label&#x3D;[]</td>
<td align="left">Set meta data on a container</td>
</tr>
<tr>
<td align="left">–label-file&#x3D;[]</td>
<td align="left">Read in a line delimited file of labels</td>
</tr>
<tr>
<td align="left">–link&#x3D;[]</td>
<td align="left">添加链接到另一个容器</td>
</tr>
<tr>
<td align="left">–log-driver&#x3D;</td>
<td align="left">Logging driver for container</td>
</tr>
<tr>
<td align="left">–log-opt&#x3D;[]</td>
<td align="left">Log driver options</td>
</tr>
<tr>
<td align="left">–lxc-conf&#x3D;[]</td>
<td align="left">Add custom lxc options</td>
</tr>
<tr>
<td align="left">-m， –memory&#x3D;</td>
<td align="left">Memory limit</td>
</tr>
<tr>
<td align="left">–mac-address&#x3D;</td>
<td align="left">Container MAC address (e.g. 92:d0:c6:0a:29:33)</td>
</tr>
<tr>
<td align="left">–memory-reservation&#x3D;</td>
<td align="left">Memory soft limit</td>
</tr>
<tr>
<td align="left">–memory-swap&#x3D;</td>
<td align="left">Total memory (memory + swap)， ‘-1’ to disable swap</td>
</tr>
<tr>
<td align="left">–memory-swappiness&#x3D;-1</td>
<td align="left">Tuning container memory swappiness (0 to 100)</td>
</tr>
<tr>
<td align="left">–name&#x3D;</td>
<td align="left">为容器指定一个名称</td>
</tr>
<tr>
<td align="left">–net&#x3D;default</td>
<td align="left">指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型</td>
</tr>
<tr>
<td align="left">–oom-kill-disable&#x3D;false</td>
<td align="left">Disable OOM Killer</td>
</tr>
<tr>
<td align="left">-P， –publish-all&#x3D;false</td>
<td align="left">Publish all exposed ports to random ports</td>
</tr>
<tr>
<td align="left">-p， –publish&#x3D;[]</td>
<td align="left">指定端口映射，格式为：主机(宿主)端口:容器端口</td>
</tr>
<tr>
<td align="left">–pid&#x3D;</td>
<td align="left">PID namespace to use</td>
</tr>
<tr>
<td align="left">–privileged&#x3D;false</td>
<td align="left">Give extended privileges to this container</td>
</tr>
<tr>
<td align="left">–read-only&#x3D;false</td>
<td align="left">Mount the container’s root filesystem as read only</td>
</tr>
<tr>
<td align="left">–restart&#x3D;no</td>
<td align="left">Restart policy to apply when a container exits</td>
</tr>
<tr>
<td align="left">–rm&#x3D;false</td>
<td align="left">Automatically remove the container when it exits</td>
</tr>
<tr>
<td align="left">–runtime&#x3D;nvidia</td>
<td align="left">在安装nvidia-docker的情况下，使用该参数可以在docker中使用GPU及Nvidia驱动</td>
</tr>
<tr>
<td align="left">–security-opt&#x3D;[]</td>
<td align="left">Security Options</td>
</tr>
<tr>
<td align="left">–shm-size&#x3D;</td>
<td align="left">指定容器的shared memory</td>
</tr>
<tr>
<td align="left">–sig-proxy&#x3D;true</td>
<td align="left">Proxy received signals to the process</td>
</tr>
<tr>
<td align="left">–stop-signal&#x3D;SIGTERM</td>
<td align="left">Signal to stop a container， SIGTERM by default</td>
</tr>
<tr>
<td align="left"><strong>-t， –tty&#x3D;false</strong></td>
<td align="left">为容器重新分配一个伪输入终端</td>
</tr>
<tr>
<td align="left">-u， –user&#x3D;</td>
<td align="left">Username or UID (format: &lt;name</td>
</tr>
<tr>
<td align="left">–ulimit&#x3D;[]</td>
<td align="left">Ulimit options</td>
</tr>
<tr>
<td align="left">–uts&#x3D;</td>
<td align="left">UTS namespace to use</td>
</tr>
<tr>
<td align="left">-v， –volume&#x3D;[]</td>
<td align="left">挂载目录</td>
</tr>
<tr>
<td align="left">–volume-driver&#x3D;</td>
<td align="left">Optional volume driver for the container</td>
</tr>
<tr>
<td align="left">–volumes-from&#x3D;[]</td>
<td align="left">Mount volumes from the specified container(s)</td>
</tr>
<tr>
<td align="left">-w， –workdir&#x3D;</td>
<td align="left">Working directory inside the container</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<p><strong>使用镜像nginx:latest以交互模式启动一个容器，命名为mynginx，使用GPU启动，同时将宿主机<code>/data1/walker</code>挂载到docker的<code>/share</code>文件夹下，将宿主机2333端口映射到容器的22端口，为容器分配2G共享内存(Shared Memory)</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --runtime=nvidia --name=mynginx -v /data1/walker:/share -p 2323:22 --shm-size=<span class="hljs-string">&quot;2g&quot;</span> nginx:latest<br></code></pre></td></tr></table></figure>

<p>使用docker镜像nginx:latest以后台模式启动一个容器，并将容器命名为mynginx。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name mynginx -d nginx:latest<br></code></pre></td></tr></table></figure>

<p>使用镜像nginx:latest以后台模式启动一个容器，并将容器的80端口映射到主机随机端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -P -d nginx:latest<br></code></pre></td></tr></table></figure>

<p>使用镜像 nginx:latest，以后台模式启动一个容器，将容器的 80 端口映射到主机的 80 端口，主机的目录 &#x2F;data 映射到容器的 &#x2F;data。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 80:80 -v /data:/data -d nginx:latest<br></code></pre></td></tr></table></figure>

<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash<br></code></pre></td></tr></table></figure>


<h4 id="3-4-3-容器启动-x2F-停止-x2F-重启-start-x2F-stop-x2F-restart"><a href="#3-4-3-容器启动-x2F-停止-x2F-重启-start-x2F-stop-x2F-restart" class="headerlink" title="3.4.3 容器启动&#x2F;停止&#x2F;重启(start&#x2F;stop&#x2F;restart)"></a>3.4.3 容器启动&#x2F;停止&#x2F;重启(start&#x2F;stop&#x2F;restart)</h4><p>使用<code>docker start</code>启动一个或多个已经被停止的容器；<br>使用<code>docker stop</code>停止一个运行中的容器；<br>使用<code>docker restart</code>重启容器。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start [Options] Container [Container...]<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop [Options] Container [Container...]<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart [Options] Container [Container...]<br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>启动已被停止的容器<code>mywalker</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start mywalker<br></code></pre></td></tr></table></figure>

<p>停止运行中的容器<code>mywalker</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop mywalker<br></code></pre></td></tr></table></figure>

<p>重启容器<code>mywalker</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart mywalker<br></code></pre></td></tr></table></figure>


<h4 id="3-4-4-容器强制停止-kill"><a href="#3-4-4-容器强制停止-kill" class="headerlink" title="3.4.4 容器强制停止(kill)"></a>3.4.4 容器强制停止(kill)</h4><p>使用<code>docker kill</code>杀掉一个运行中的容器。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> [Options] Container [Container...]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-s：向容器发送一个信号</li>
</ul>
<p><strong>示例：</strong><br>杀掉运行中的容器mynginx。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> -s KILL myngin<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> </p>
<blockquote>
<p><code>docker kill</code>命令不管容器同不同意，执行强行终止；<code>docker stop</code>命令首先给容器发送一个SIGTERM信号，让容器做一些退出前必须的保护性、安全性操作，然后让容器自动停止运行，这是一种更为优雅的退出方式；如果在一段时间内，容器还是没有停止，再考虑使用<code>docker kill</code>命令强行终止。</p>
</blockquote>
<h4 id="3-4-5-删除容器-rm"><a href="#3-4-5-删除容器-rm" class="headerlink" title="3.4.5 删除容器(rm)"></a>3.4.5 删除容器(rm)</h4><p>使用<code>docker rm</code>删除一个或多个容器。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> [Options] Container [Container...]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-f：通过 SIGKILL 信号强制删除一个运行中的容器</li>
<li>-l：移除容器间的网络连接，而非容器本身</li>
<li>-v：删除与容器关联的卷</li>
</ul>
<p><strong>示例：</strong><br>强制删除容器 db01、db02。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f db01 db02<br></code></pre></td></tr></table></figure>

<p>移除容器 nginx01 对容器 db01 的连接，连接名 db。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f db01 db02<br></code></pre></td></tr></table></figure>

<p>删除容器 nginx01， 并删除容器挂载的数据卷。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -v nginx01<br></code></pre></td></tr></table></figure>

<p>删除所有已经停止的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p><code>docker rm</code>命令是删除容器，而<code>docker rmi</code>命令是删除镜像(remove <strong>i</strong>mage)。</p>
</blockquote>
<h4 id="3-4-6-容器暂停与恢复-pause-x2F-unpause"><a href="#3-4-6-容器暂停与恢复-pause-x2F-unpause" class="headerlink" title="3.4.6 容器暂停与恢复(pause&#x2F;unpause)"></a>3.4.6 容器暂停与恢复(pause&#x2F;unpause)</h4><p>使用<code>docker pause</code>暂停容器中所有的进程；<br>使用<code>docker unpause</code>恢复容器中所有的进程。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pause [Options] Container [Container...]<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker unpause [Options] Container [Container...]<br></code></pre></td></tr></table></figure>

<p><strong>示例：</strong><br>暂停数据库容器db01提供服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pause db01<br></code></pre></td></tr></table></figure>

<p>恢复数据库容器db01提供服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker unpause db01<br></code></pre></td></tr></table></figure>




<h4 id="3-4-7-容器执行命令-exec"><a href="#3-4-7-容器执行命令-exec" class="headerlink" title="3.4.7 容器执行命令(exec)"></a>3.4.7 容器执行命令(exec)</h4><p>使用<code>docker exec</code>在运行的容器中执行命令。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> [Options] Container Command [Arg...]<br></code></pre></td></tr></table></figure>

<p><strong>常用Options：</strong></p>
<ul>
<li>-d：分离模式: 在后台运行</li>
<li>-i：即使没有附加也保持STDIN 打开</li>
<li>-t：分配一个伪终端</li>
</ul>
<p><strong>示例：</strong><br>在容器<code>mynginx</code>中以交互模式执行容器内<code>/root/runoob.sh</code>脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mynginx /bin/sh /root/runoob.sh<br></code></pre></td></tr></table></figure>

<p>在容器 mynginx 中开启一个交互模式的终端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  mynginx /bin/bash<br></code></pre></td></tr></table></figure>
<p>也可以通过<code>docker ps</code>命令查看已经在运行的容器，然后使用容器ID进入容器，再通过<code>docker exec</code>命令对指定的容器执行bash。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br>docker <span class="hljs-built_in">exec</span> -it 9df70f9a0714 /bin/bash<br></code></pre></td></tr></table></figure>



<h3 id="3-5-Docker清理命令汇总"><a href="#3-5-Docker清理命令汇总" class="headerlink" title="3.5 Docker清理命令汇总"></a>3.5 Docker清理命令汇总</h3><p><strong>杀死所有正在运行的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> $(docker ps -a -q)<br></code></pre></td></tr></table></figure>

<p><strong>删除所有已经停止的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)<br></code></pre></td></tr></table></figure>

<p><strong>删除所有未打<code>dangling</code>标签的镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi $(docker images -q -f dangling=<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>

<p><strong>通过镜像的<code>id</code>来删除指定镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi $(docker images -q)<br></code></pre></td></tr></table></figure>

<p><strong>删除所有镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi &lt;image <span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure>



<h2 id="4-Docker仓库管理"><a href="#4-Docker仓库管理" class="headerlink" title="4 Docker仓库管理"></a>4 Docker仓库管理</h2><p>仓库<code>Repository</code>是集中存放镜像的地方。以下介绍一下 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。当然不止DockerHub，只是远程的服务商不一样，操作都是一样的。</p>
<h3 id="4-1-Docker-Hub"><a href="#4-1-Docker-Hub" class="headerlink" title="4.1 Docker Hub"></a>4.1 Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<ul>
<li><p><strong>注册</strong><br>在<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>免费注册一个 Docker 账号。</p>
</li>
<li><p><strong>登录和退出</strong><br>登录需要输入用户名和密码，使用[<code>docker login(点击查看)</code>](#3.2.1 登入&#x2F;登出(login&#x2F;logout))命令登录成功后，我们就可以从Docker Hub上拉取自己账号下的全部镜像。使用[<code>docker logout(点击查看)</code>](#3.2.1 登入&#x2F;登出(login&#x2F;logout))命令即可退出登录。</p>
</li>
<li><p><strong>拉取镜像</strong><br>你可以通过[<code>docker search</code>](#3.2.2 查找镜像(search))命令来查找官方仓库中的镜像，并利用[<code>docker pull</code>](#3.2.3 拉取镜像(pull))命令来将它下载到本地。以 ubuntu 为关键词进行搜索：</p>
</li>
<li><p><strong>推送镜像</strong><br>用户登录后，可以通过[<code>docker push</code>](#3.2.4 上传镜像(push))命令将自己的镜像推送到Docker Hub。</p>
</li>
</ul>
<h3 id="4-2-阿里云容器Hub"><a href="#4-2-阿里云容器Hub" class="headerlink" title="4.2 阿里云容器Hub"></a>4.2 阿里云容器Hub</h3><p>我们使用Docker的第一步，应该是获取一个官方的镜像，例如mysql、wordpress，基于这些基础镜像我们可以开发自己个性化的应用。我们可以使用Docker命令行工具来下载官方镜像。但是因为网络原因，我们下载一个300M的镜像需要很长的时间，甚至下载失败。可以通过设置镜像代理站点&#x2F;加速器的方式来对下载加速。<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云容器Hub</a>服务提供了官方的镜像站点加速官方镜像的下载速度。在该网站登录可以获得加速器地址，格式为<code>https://*****.mirror.aliyuncs.com</code>。  </p>
<p>当你下载安装的Docker Version不低于1.10时，建议直接通过<code>daemon config</code>进行配置。  </p>
<p>使用配置文件 &#x2F;etc&#x2F;docker&#x2F;daemon.json(没有时新建该文件)。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&lt;your accelerate address&gt;&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>然后重启Docker Daemon就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure>



<h2 id="5-docker网络模式"><a href="#5-docker网络模式" class="headerlink" title="5 docker网络模式"></a>5 docker网络模式</h2><p>docker共有4种网络模式，其中自带3种网络模式：分别是<code>bridge</code>网络，<code>host</code>网络，<code>none</code>网络，可以使用以下命令查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network <span class="hljs-built_in">ls</span><br>NETWORK ID     NAME      DRIVER    SCOPE<br>40bf4cb78250   bridge    bridge    <span class="hljs-built_in">local</span><br>59609bcae8c7   host      host      <span class="hljs-built_in">local</span><br>4ba3f22b12f7   none      null      <span class="hljs-built_in">local</span><br></code></pre></td></tr></table></figure>

<h3 id="5-1-host网络"><a href="#5-1-host网络" class="headerlink" title="5.1 host网络"></a>5.1 host网络</h3><p>创建容器时，可以使用<code>-net=host</code>指定。</p>
<p>启动的容器如果指定了网络类型为<code>host</code>模式，那么新创建的容器不会创建自己的虚拟网卡，而是直接使用宿主机的网卡和IP地址，因此容器里面查看到的IP信息就是宿主机的信息，访问容器的时候直接使用<code>宿主机IP:容器端口</code>即可，不过容器的其它资源们比如文件系统，系统进程等还是和宿主机保持隔离。</p>
<p>此模式的网络性能最高，但是各容器之间端口不能相同(因为该模式直接使用的是宿主机的网络)，适用于运行容器端口比较固定的业务，比如Mysql，Redis等。</p>
<p>该模式也有一个缺点，容器内已经使用的端口就不能再用了，并且网络的隔离性不好。例如，当通过ssh的方式直接远程登陆至该容器内部时，端口号<code>22</code>已经被宿主机占用，此时需要修改容器内部ssh端口号，并通过<code>宿主机IP:修改后的端口</code>登录。</p>
<h3 id="5-2-none模式"><a href="#5-2-none模式" class="headerlink" title="5.2 none模式"></a>5.2 none模式</h3><p>创建容器时，可以使用<code>-net=none</code>指定。</p>
<p>在使用<code>none</code>模式后，docker容器不会进行任何网络配置，其没有网卡，没有IP也没有路由，因此默认无法与外界通信，需要手动添加配置IP等，所以极少使用。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p>
<h3 id="5-3-bridge模式"><a href="#5-3-bridge模式" class="headerlink" title="5.3 bridge模式"></a>5.3 bridge模式</h3><p>docker的默认模式就是<code>bridge</code>模式，也是使用比较多的模式，此模式创建的容器会为每一个容器分配自己的网络IP等信息，并将容器连接到一个虚拟网桥与外界通信。</p>
<h3 id="5-4-container模式"><a href="#5-4-container模式" class="headerlink" title="5.4 container模式"></a>5.4 container模式</h3><p>创建容器时，可以使用”-net&#x3D;container:容器名称或容器ID”指定。</p>
<p>使用此模式创建的容器需指定和一个已经存在的容器共享一个网络，而不是和宿主机共享网络，换句话说，就是两个容器公用同一个IP地址。</p>
<p>新创建的容器不会创建自己的网卡也不会配置自己的IP，而是和一个已经存在的被指定的容器IP和端口范围，因此这个容器的端口不能和被指定的端口冲突，除了网络之外的文件系统，进程信息等仍然保持相互隔离，两个容器的进程可以通过lo网卡设备通信。</p>
<h2 id="6-Docker-SSH远程调试"><a href="#6-Docker-SSH远程调试" class="headerlink" title="6 Docker-SSH远程调试"></a>6 Docker-SSH远程调试</h2><p>本章详细讲述使用Pycharm进行远程调试的方法。</p>
<h3 id="6-1-远程服务器-Docker宿主机-SSH配置"><a href="#6-1-远程服务器-Docker宿主机-SSH配置" class="headerlink" title="6.1 远程服务器(Docker宿主机)SSH配置"></a>6.1 远程服务器(Docker宿主机)SSH配置</h3><p>确保宿主机正确安装openssh-server服务，默认端口22，可以自行修改。</p>
<h3 id="6-2-Docker-Container-SSH配置"><a href="#6-2-Docker-Container-SSH配置" class="headerlink" title="6.2 Docker Container SSH配置"></a>6.2 Docker Container SSH配置</h3><p>要想通过本地Pycharm调试服务器中的Docker容器中的代码，需要进行端口映射操作；即我们通过端口映射将容器内部向宿主机的一个端口转发出来，然后通过本地Pycharm连接该转发出来的端口，即可对容器内部代码进行调试。</p>
<ul>
<li><p>启动Dockers容器时指定参数<code>p</code>，将Dockers容器内部端口映射到宿主机端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 2021:22 55914e782b13<br></code></pre></td></tr></table></figure>
<p>启动参数<code>-p 2021:22</code>表示端口映射，将容器内部的<code>22</code>端口映射到宿主机的<code>2021</code>端口。</p>
</li>
<li><p>Docker容器内安装openssh-server服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update &amp;&amp; apt install openssh-server<br></code></pre></td></tr></table></figure>
</li>
<li><p>Docker容器内配置openssh-server服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将root的密码修改为test</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:12345&#x27;</span> | chpasswd<br><br><span class="hljs-comment"># 允许使用root身份登录</span><br>$ sed -i <span class="hljs-string">&#x27;s/PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config<br><br><span class="hljs-comment"># 限制 PAM方式登录</span><br>$ sed <span class="hljs-string">&#x27;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#x27;</span> -i /etc/pam.d/sshd<br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export VISIBLE=now&quot;</span> &gt;&gt; /etc/profile<br></code></pre></td></tr></table></figure>
<p>可将以上代码写成<code>docker_config.sh</code>文件，在Docker容器内运行</p>
</li>
<li><p>Docker容器内重启openssh-server服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service ssh restart<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-测试SSH端口映射配置"><a href="#6-3-测试SSH端口映射配置" class="headerlink" title="6.3 测试SSH端口映射配置"></a>6.3 测试SSH端口映射配置</h3><ul>
<li>Docker容器中ssh服务端口在远程服务器上的映射<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker port &lt;your container name&gt; 22<br><br><span class="hljs-comment"># 输出结果如下所示</span><br>0.0.0.0:2021<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-4-本地设备-Windows-x2F-Linux-的Pycharm配置"><a href="#6-4-本地设备-Windows-x2F-Linux-的Pycharm配置" class="headerlink" title="6.4 本地设备(Windows&#x2F;Linux)的Pycharm配置"></a>6.4 本地设备(Windows&#x2F;Linux)的Pycharm配置</h3><ul>
<li><p>在Pycharm中配置Deployment</p>
  <center>
  <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Deployment.png" srcset="/img/loading.gif" lazyload alt="Pycharm Deployment" width="40%">
  </center>
</li>
<li><p>新建SFTP连接</p>
  <center>
  <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Connection.png" srcset="/img/loading.gif" lazyload alt="Pycharm SFTP Connection" width="60%">
  </center>

<p>  其中Host填写宿主机IP地址，Port填写Docker容器转发到宿主机的端口(即刚才的<code>2021</code>)，Usernam填写<code>root</code>，passward即为先前在容器内部设置的<code>12345</code>，选择好Root Path后选择Mappings。</p>
</li>
<li><p><strong>新建SFTP连接(ipv6)</strong><br>  如果你的宿主机IP地址是ipv6的，那么需要配置Pycharm的ipv6支持：</p>
<ul>
<li>在pycharm中打开<code>Help</code> -&gt; <code>Edit Custom VM Options</code></li>
<li>在该文件中添加一行<code>-Djava.net.preferIPv6Addresses=true</code></li>
<li>将<code>-Djava.net.preferIPv4Stack=false</code>由<code>true</code>改为<code>false</code>(备选)  <center>
  <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-VM-Options.png" srcset="/img/loading.gif" lazyload alt="Pycharm VM Options" width="60%">
  </center></li>
<li>重启Pycharm</li>
<li>按照ipv4的方式新建SFTP连接，Host处填写ipv6地址，不过要使用英文中括号<code>[]</code>包裹  <center>
  <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Connection-ipv6.png" srcset="/img/loading.gif" lazyload alt="Pycharm SFTP Connection ipv6" width="60%">
  </center></li>
</ul>
</li>
<li><p>映射本地项目至远程服务器</p>
  <center>
  <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Mappings.png" srcset="/img/loading.gif" lazyload alt="Pycharm SFTP Mappings" width="50%">
  </center>

<p>  Local path是当前项目路径，Deployment path是远程服务器同步的项目路径。选择完毕后确定。Tools -&gt; Deployment -&gt; Browse Remote Host可以查看远程项目文件。</p>
</li>
<li><p>配置Python远程解释器</p>
<ul>
<li><p>查看远程Python解释器位置(进入Docker容器内部)</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> python<br><span class="hljs-comment"># 输出如下</span><br>/opt/conda/bin/python<br></code></pre></td></tr></table></figure>
</li>
<li><p>添加远程Python解释器<br>   在Pycharm中Add Python Interpret，选择SSH Interpret -&gt; Existing server configuration，选择我们刚才配置的SFTP Deployment，若无法下一步，点击<code>move</code>。接着Interpret路径选择刚才找到的Python解释器位置，同步文件夹(Sync folders)修改为远程项目地址，去掉勾选自动上传。</p>
   <center>
   <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Interpret-Add.png" srcset="/img/loading.gif" lazyload alt="Pycharm Interpret Add" width="50%">
   </center>

   <center>
   <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Interpret-Config.png" srcset="/img/loading.gif" lazyload alt="Pycharm Interpret Config" width="50%">
   </center></li>
</ul>
</li>
<li><p>配置上传方式Tools -&gt; Deployment -&gt; Options，将自动上传改为<code>Ctrl+S</code>。</p>
  <center>
  <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Deployment-Options.png" srcset="/img/loading.gif" lazyload alt="Pycharm Deployment Options" width="50%">
  </center></li>
</ul>
<h2 id="7-Docker使用常见问题"><a href="#7-Docker使用常见问题" class="headerlink" title="7. Docker使用常见问题"></a>7. Docker使用常见问题</h2><h3 id="7-1-Docker容器内用户选择"><a href="#7-1-Docker容器内用户选择" class="headerlink" title="7.1 Docker容器内用户选择"></a>7.1 Docker容器内用户选择</h3><p>Docker在启动时，默认使用的时宿主机的root用户的uid，这就导致两个问题：一时Docker具有宿主机的root权限，安全性很低；二是这样启动的容器如果挂载了宿主机文件，那么在运行时容器所生成的文件在宿主机看来具有root权限，owner是root，这样可能会存在权限上的一些问题。相应的解决方法有两个：</p>
<ul>
<li><p>启动容器时指定uid与gid<br>  如果我们想以宿主机的某个用户启动docker，那么在启动时指定参数<code>-u</code>，获取宿主机用户uid和gid的方法如下：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> &lt;username&gt;<br></code></pre></td></tr></table></figure>
<p>  然后根据获得的id指定启动参数</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --gpus all --name=yuhong -u 1001:1001  55914e782b13<br></code></pre></td></tr></table></figure>
<p>  但是这种方法要求docker容器内已经有对应id的用户组及用户，因此不方便使用。</p>
</li>
<li><p>启动容器后在内部建立用户<br>  同样的，我们先在获取宿主机用户uid和gid：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> &lt;username&gt;<br></code></pre></td></tr></table></figure>
<p>  接着在容器内部建立对应id的用户，例如：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先设定root密码，防止无法切回账号</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:12345&#x27;</span> | chpasswd<br>groupadd -g 1001 student<br><span class="hljs-comment"># 指定命令行为bash</span><br>useradd -u 1001 -g student -s /bin/bash yuhong <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;yuhong:12345&#x27;</span> | chpasswd<br></code></pre></td></tr></table></figure>
<p>  切换至新建的用户</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su yuhong<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果容器内部所使用的Python环境并非对所有用户有效(例如Conda环境)，可以先查找环境位置，切换用户再激活环境。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">su root<br><span class="hljs-built_in">which</span> python<br>su yuhong<br><span class="hljs-built_in">cd</span> &lt;python path&gt;<br><span class="hljs-built_in">source</span> activate<br></code></pre></td></tr></table></figure>
</li>
<li><p>当在Pycharm中使用非root用户的Deployment时，此用户连接ssh远程解释器可能出现permission denied的情况，此时可以考虑在Docker容器内部建立该用户的home文件夹，并将文件夹权限修改为该用户可用(xrw)，由于此时该用户uid和gid都与root不同，因此需要给<code>777</code>权限。</p>
</li>
</ul>
<h3 id="7-2-Docker容器内部无法联网"><a href="#7-2-Docker容器内部无法联网" class="headerlink" title="7.2 Docker容器内部无法联网"></a>7.2 Docker容器内部无法联网</h3><p>解决方法：在启动时增加参数<code>--net host</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --gpus all --name=yuhong --net host  55914e782b13<br></code></pre></td></tr></table></figure>


<h3 id="7-3-ImportError"><a href="#7-3-ImportError" class="headerlink" title="7.3 ImportError"></a>7.3 ImportError</h3><p>在容器内部使用python，导入模块时报错”ImportError: libGL.so.1: cannot open shared object file: No such file or directory”。</p>
<p>解决方法：容器内安装libgl1-mesa-glx</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install libgl1-mesa-glx<br></code></pre></td></tr></table></figure>

<h3 id="7-4-No-command-specified"><a href="#7-4-No-command-specified" class="headerlink" title="7.4 No command specified"></a>7.4 No command specified</h3><p>从容器启动Docker的时候报错”Error response from daemon: No command specified”。</p>
<p>解决方法：指定命令行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -t -i 87e5b6b3ccc1 /bin/bash<br></code></pre></td></tr></table></figure>



              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Docker</div>
      <div>http://example.com/2022/04/26/Docker/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Deluge Walker</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 26, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
