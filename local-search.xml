<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2021/12/21/Docker/"/>
    <url>/2021/12/21/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker教程"><a href="#Docker教程" class="headerlink" title="Docker教程"></a>Docker教程</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护，大概在2017年4月份左右Docker项目改名为<a href="https://github.com/moby/moby">Moby</a>，可以在Github搜索Moby找到这个项目。  </p><p>Docker的内核建立在LXC(Linux Container)之上，作为容器的一种，同传统的虚拟机比起来，容器内的应用&#x2F;进程直接运行在宿主机的内核上，容器没有自己的内核，所以容器更加轻量，运行效率也更高。同传统的虚拟机相比：Docker具有以下优点：  </p><ul><li>更高效的资源利用</li><li>快速启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>轻松迁移</li><li>轻松维护和扩展</li></ul><h2 id="2-Docker概念"><a href="#2-Docker概念" class="headerlink" title="2 Docker概念"></a>2 Docker概念</h2><ul><li><strong>镜像 Image</strong><br>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li><li><strong>容器 Container</strong><br>Docker容器是Docker镜像的实例，镜像启动后可生成一个Docker实例，它可以被开始、停止、删除、每个容器都是互相隔离的，保证安全的平台，可以把容器看做是要给简易版的linux环境(包括root用户权限、镜像空间、用户空间和网络空间等)和运行在其中的应用程序当然也可以将Docker实例保存为一个镜像，供其他用户使用。</li><li><strong>仓库 Repository</strong><br>Docker仓库是保存Docker镜像的地方，Docker的默认镜像仓库是在<code>hub.docker.com</code>，但用户只能在官网创建一个<code>private</code>项目，有些组织并不希望自己的镜像成为<code>public</code>项目(比如打包了云源码)，这时用户可以使用<code>registry</code>构建自己的仓库。</li></ul><h2 id="3-Docker常用命令"><a href="#3-Docker常用命令" class="headerlink" title="3 Docker常用命令"></a>3 Docker常用命令</h2><h3 id="3-1-Docker安装"><a href="#3-1-Docker安装" class="headerlink" title="3.1 Docker安装"></a>3.1 Docker安装</h3><h4 id="3-1-1-Linux安装"><a href="#3-1-1-Linux安装" class="headerlink" title="3.1.1 Linux安装"></a>3.1.1 Linux安装</h4><p>接下来将基于<code>Ubuntu20.04</code>操作系统讲解Docker命令。</p><h5 id="3-1-1-1-Docker安装"><a href="#3-1-1-1-Docker安装" class="headerlink" title="3.1.1.1 Docker安装"></a>3.1.1.1 Docker安装</h5><p><strong>第一种 安装<code>docker</code></strong></p><ul><li><p>安装docker</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo apt install docker</code></pre></div></li><li><p>安装nvidia-docker<br>  nvidia-docker是一个可以使用GPU的docker，它在docker上做了一层封装，通过nvidia-docker-plugin，然后调用到docker上，其最终实现的还是在docker的启动命令上携带一些必要的参数。因此在安装nvidia-docker之前，还是需要安装docker的。</p>  <div style="text-align: center">  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Nvidia-Docker.png" alt="Nvidia Docker结构" width="60%">  </div><p>  docker一般都是使用基于CPU的应用，而如果是GPU的话，就需要安装特有的硬件环境，比如需要安装nvidia driver，所以docker容器并不直接支持Nvidia GPU。为了使docker image能很便利的使用Nvidia GPU，从而产生了nvidia-docker，由它来制作nvidia driver的image，这就要求在目标机器上启动container时，确保字符设备以及驱动文件已经被挂载。</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo apt install -y nvidia-docker2</code></pre></div></li></ul><p><strong>第二种 安装<code>docker.io</code>(推荐)</strong></p><p>Docker19版本更新了GPU驱动使用参数，下面介绍具体的安装方法。</p><ul><li><p><code>docker-ce</code>与<code>docker-io</code>的区别<br>  <code>docker-ce</code>是由docker团队认证并维护的一个社区版发行包，<code>docker.io</code>是ubuntu团队维护的一个包。由于之前ubuntu团队有很长一段时间没有维护docker的版本，导致有一段时间docker.io的版本还停留在远古版本。后来ubuntu版本重新开始维护，版本继续送代，截止2021-05-14日，版本已经更新到<code>Docker version 20.10.2</code>。两者使用相同的包管理，<code>docker-ce</code>是所有依赖包由docker团队管理，可以保证docker运行的稳定，适合作为纯docker管理的生产环境，即整个系统只有一个docker在跑，剩下所有应用都通过发布docker的容器来部署。<code>docker-io</code>的依赖包则是由ubuntu统一管理，更符合包管理的理念，也更规范，可以尽可能的保证系统和多个软件的运行稳定，适合作为多软件协同运行的服务器和个人桌面使用。Docker目前是一个被广泛使用的工具，ubuntu再次停止维护的概率不大。所以除了纯docker环境，个人建议直接用<code>docker.io</code>。</p></li><li><p>安装<code>docker.io</code></p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Install Docker</span>sudo apt install docker.io</code></pre></div></li><li><p>在线安装nvidia-container-toolkit</p><ul><li><p>首先配置package repositories</p>   <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Get system version</span>distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)<span class="hljs-comment"># add public key</span>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -<span class="hljs-comment"># add source</span>curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get update</code></pre></div></li><li><p>安装nvidia-container-toolkit</p>   <div class="code-wrapper"><pre><code class="hljs bsah">sudo apt-get install -y nvidia-container-toolkit</code></pre></div></li></ul></li><li><p>离线安装nvidia-container-toolkit</p><ul><li><p>在有网络连接的设备上配置package repositories</p>   <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Get system version</span>distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)<span class="hljs-comment"># add public key</span>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -<span class="hljs-comment"># add source</span>curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get update</code></pre></div></li><li><p>下载nvidia-container-toolkit套件</p>   <div class="code-wrapper"><pre><code class="hljs bsah">apt download libnvidia-container1apt download libnvidia-container-toolsapt download nvidia-container-toolkitapt download nvidia-container-runtimeapt download nvidia-docker2</code></pre></div></li><li><p>安装nvidia-container-toolkit套件(以下顺序不能改变)</p>   <div class="code-wrapper"><pre><code class="hljs bsah">dpkg -i libnvidia-container1_***.debdpkg -i libnvidia-container-tools_***.debdpkg -i nvidia-container-toolkit_***.debdpkg -i nvidia-container-runtime_***.debdpkg -i nvidia-docker2_***.deb</code></pre></div></li></ul></li><li><p>安装完成后重启Docker</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl restart docker</code></pre></div></li><li><p>使用该版本Docker创建容器时使用<code>--gpus</code>参数指定使用的GPU编号：</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo docker run -it --gpus all imagename</code></pre></div></li></ul><h5 id="3-1-1-2-加入Docker用户组"><a href="#3-1-1-2-加入Docker用户组" class="headerlink" title="3.1.1.2 加入Docker用户组"></a>3.1.1.2 加入Docker用户组</h5><ul><li><p>创建docker用户组</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo groupadd docker</code></pre></div></li><li><p>将用户加入docker用户组</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$&#123;USER&#125;</span></code></pre></div></li><li><p>重启docker服务</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl restart docker</code></pre></div></li><li><p>切换或者退出当前账户，再重新登入</p>  <div class="code-wrapper"><pre><code class="hljs bash">su rootsu <span class="hljs-variable">$&#123;USER&#125;</span></code></pre></div></li><li><p>添加访问和执行权限(普通用户可不加<code>sudo</code>使用docker)</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> a+rw /var/run/docker.sock</code></pre></div></li></ul><h5 id="3-1-1-3-查看Docker安装信息"><a href="#3-1-1-3-查看Docker安装信息" class="headerlink" title="3.1.1.3 查看Docker安装信息"></a>3.1.1.3 查看Docker安装信息</h5><p>使用<code>docker info</code>查看 Docker 系统信息，包括镜像和容器数。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker info</code></pre></div><p><strong>示例：</strong><br>查看Docker版本信息。</p><div class="code-wrapper"><pre><code class="hljs bash">docker info</code></pre></div><h5 id="3-1-1-4-查看Docker版本"><a href="#3-1-1-4-查看Docker版本" class="headerlink" title="3.1.1.4 查看Docker版本"></a>3.1.1.4 查看Docker版本</h5><p>使用<code>docker version</code>查看Docker的版本信息。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker version [Options]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-f：指定返回值的模板文件</li></ul><p><strong>示例：</strong><br>查看Docker版本信息。</p><div class="code-wrapper"><pre><code class="hljs bash">docker version</code></pre></div><h5 id="3-1-1-5-卸载Docker"><a href="#3-1-1-5-卸载Docker" class="headerlink" title="3.1.1.5 卸载Docker"></a>3.1.1.5 卸载Docker</h5><ul><li>确定您拥有什么已安装的软件包</li></ul><div class="code-wrapper"><pre><code class="hljs bash">dpkg -l | grep -i docker</code></pre></div><ul><li>删除软件包服务</li></ul><div class="code-wrapper"><pre><code class="hljs bash">sudo apt-get purge -y docker.io docker-engine dockersudo apt-get autoremove -y --purge docker.io docker-engine docker</code></pre></div><ul><li>删除主机上的映像，容器，卷或用户创建的配置文件</li></ul><div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> -rf /var/lib/docker /etc/dockersudo <span class="hljs-built_in">rm</span> /etc/apparmor.d/dockersudo groupdel dockersudo <span class="hljs-built_in">rm</span> -rf /var/run/docker.sock</code></pre></div><h4 id="3-1-2-Windows安装"><a href="#3-1-2-Windows安装" class="headerlink" title="3.1.2 Windows安装"></a>3.1.2 Windows安装</h4><h5 id="3-1-2-1-启动依赖环境"><a href="#3-1-2-1-启动依赖环境" class="headerlink" title="3.1.2.1 启动依赖环境"></a>3.1.2.1 启动依赖环境</h5><ul><li><p><strong>Hyper-V</strong></p><ul><li><p>以管理员身份运行Powershell：</p>  <div class="code-wrapper"><pre><code class="hljs bash">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All</code></pre></div></li><li><p>在BIOS中开启Virtualization<br>  不同的主板设置不同，基本位于Advanced-&gt;CPU设置中。</p></li></ul></li><li><p><strong>WSL2</strong></p><ul><li>必须运行Windows10版本2004及更高版本(内部版本19041及更高版本)或Windows 11。</li><li>Windows11中默认安装了WSL内核，如果没有可手动安装。</li><li>以管理员身份运行Powershell：  <div class="code-wrapper"><pre><code class="hljs bash">wsl --install</code></pre></div>  此命令将启用所需的可选组件，下载最新的Linux内核，将WSL2设置为默认值，并安装 Linux发行版(默认安装Ubuntu)。</li></ul></li></ul><h5 id="3-1-2-2-安装Docker-Desktop-for-Windows"><a href="#3-1-2-2-安装Docker-Desktop-for-Windows" class="headerlink" title="3.1.2.2 安装Docker Desktop for Windows"></a>3.1.2.2 安装Docker Desktop for Windows</h5><ul><li><p>下载安装包<br>  进入<a href="https://hub.docker.com/?overlay=onboarding">Dokcer官网下载地址</a>，并下载Windows的版本Docker，如果你还没有登录，会要求注册登录。</p></li><li><p>安装<br>  双击安装文件并根据指引完成安装。</p></li></ul><h5 id="3-1-2-3-下载Linux内核更新包"><a href="#3-1-2-3-下载Linux内核更新包" class="headerlink" title="3.1.2.3 下载Linux内核更新包"></a>3.1.2.3 下载Linux内核更新包</h5><p>启动Docker Desktop时可能会要求更新WSL内核版本，在<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">WSL文档中</a>获取<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于x64计算机的WSL2 Linux内核更新包</a>。完成安装后重启Docker即可。</p><h5 id="3-1-2-4-注意事项"><a href="#3-1-2-4-注意事项" class="headerlink" title="3.1.2.4 注意事项"></a>3.1.2.4 注意事项</h5><ul><li>docker运行出现错误<code>error during connect: This error may indicate that the docker daemon is not running.:</code><ul><li>powershell进入目录”C:\Program Files\Docker\Docker”  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Docker\Docker&quot;</span></code></pre></div></li><li>执行以下命令  <div class="code-wrapper"><pre><code class="hljs bash">./DockerCli.exe -SwitchDaemon</code></pre></div></li></ul></li></ul><h3 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h3><h4 id="3-2-1-登入-x2F-登出-login-x2F-logout"><a href="#3-2-1-登入-x2F-登出-login-x2F-logout" class="headerlink" title="3.2.1 登入&#x2F;登出(login&#x2F;logout)"></a>3.2.1 登入&#x2F;登出(login&#x2F;logout)</h4><p>使用<code>docker login</code>登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub；<br>使用<code>docker logout</code>登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub。<br><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker login [Options] [Server]</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">logout</span> [Options] [Server]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-u：登陆的用户名</li><li>-p：登陆的密码</li></ul><p><strong>示例：</strong><br>登陆到Docker Hub。</p><div class="code-wrapper"><pre><code class="hljs bash">docker login -u username -p password</code></pre></div><p>登出Docker Hub。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">logout</span></code></pre></div><h4 id="3-2-2-查找镜像-search"><a href="#3-2-2-查找镜像-search" class="headerlink" title="3.2.2 查找镜像(search)"></a>3.2.2 查找镜像(search)</h4><p>使用<code>docker search</code>从Docker Hub查找镜像。<br><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker search [Options] TERM</code></pre></div><p><strong>常用Options：</strong></p><ul><li>–automated：只列出 automated build类型的镜像</li><li>–no-trunc：显示完整的镜像描述</li><li>-s：列出收藏数不小于指定值的镜像</li></ul><p><strong>查找到的镜像列表包含：</strong></p><ul><li><strong>NAME</strong> 镜像名称</li><li><strong>DESCRIPTION</strong> 镜像描述</li><li><strong>STARS</strong> 星标数量</li><li><strong>OFFICIAL</strong> 是否为官方镜像</li><li><strong>AUTOMATED</strong> 是否是自动构建的镜像</li></ul><p><strong>示例：</strong><br>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像。</p><div class="code-wrapper"><pre><code class="hljs bash">docker search -s 10 java</code></pre></div><h4 id="3-2-3-拉取镜像-pull"><a href="#3-2-3-拉取镜像-pull" class="headerlink" title="3.2.3 拉取镜像(pull)"></a>3.2.3 拉取镜像(pull)</h4><p>使用<code>docker pull</code>从镜像仓库中拉取或者更新指定镜像。<br><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker pull [Options] NAME[:TAG|@DIGEST]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-a：拉取所有tagged镜像</li><li>–disable-content-trust：忽略镜像的校验，默认开启</li></ul><p><strong>示例：</strong><br>从Docker Hub下载<code>java</code>最新版镜像。</p><div class="code-wrapper"><pre><code class="hljs bash">docker pull java</code></pre></div><p>从Docker Hub下载<code>Repository</code>为<code>java</code>的所有镜像。</p><div class="code-wrapper"><pre><code class="hljs bash">docker pull -a java</code></pre></div><h4 id="3-2-4-上传镜像-push"><a href="#3-2-4-上传镜像-push" class="headerlink" title="3.2.4 上传镜像(push)"></a>3.2.4 上传镜像(push)</h4><p>使用<code>docker push</code>将本地的镜像上传到镜像仓库，要先登陆到镜像仓库<br><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker push [Options] NAME[:TAG]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>–disable-content-trust：忽略镜像的校验，默认开启</li></ul><p><strong>示例：</strong><br>上传本地镜像<code>myapache:v1</code>到镜像仓库中。</p><div class="code-wrapper"><pre><code class="hljs bash">docker push myapache:v1</code></pre></div><h4 id="3-2-5-查看镜像-images"><a href="#3-2-5-查看镜像-images" class="headerlink" title="3.2.5 查看镜像(images)"></a>3.2.5 查看镜像(images)</h4><p>使用<code>docker images</code>查看本地存在的镜像。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker images [Options] [Repository[:Tag]]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-a：列出本地所有的镜像(含中间映像层，默认情况下，过滤掉中间映像层)</li><li>–digests：显示镜像的摘要信息</li><li>-f：显示满足条件的镜像</li><li>–format：指定返回值的模板文件</li><li>–no-trunc：显示完整的镜像信息</li><li>-q：只显示镜像ID</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker images</code></pre></div><p>列出的镜像列表包含以下信息：</p><ul><li><strong>REPOSITORY</strong> 镜像来自于哪个仓库，比如ubuntu</li><li><strong>TAG</strong> 镜像的标记，比如 14.04</li><li><strong>IMAGE ID</strong> 镜像的ID号(唯一)</li><li><strong>CREATED</strong> 镜像创建时间</li><li><strong>VIRTUAL SIZE</strong> 镜像大小</li></ul><h4 id="3-2-6-载入镜像-load"><a href="#3-2-6-载入镜像-load" class="headerlink" title="3.2.6 载入镜像(load)"></a>3.2.6 载入镜像(load)</h4><p>使用 <code>docker load</code>对于本地其他方式获得的镜像进行导入。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">docker</span> <span class="hljs-variable">load</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Options</span><span class="hljs-punctuation">]</span> <span class="hljs-built_in">Image</span></code></pre></div><p><strong>常用Options：</strong></p><ul><li>–input ， -i：指定导入的文件，代替 STDIN。</li><li>–quiet ， -q：精简输出信息。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker load --input fedora.tar</code></pre></div><h4 id="3-2-7-存出镜像-save"><a href="#3-2-7-存出镜像-save" class="headerlink" title="3.2.7 存出镜像(save)"></a>3.2.7 存出镜像(save)</h4><p>可以使用<code>docker save</code>将指定镜像保存成tar归档文件。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker save [Options] Image</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-o：输出到的文件。</li></ul><p><strong>示例：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker save -o ubuntu_16.04.tar ubuntu:16.04</code></pre></div><h4 id="3-2-8-删除镜像-rmi"><a href="#3-2-8-删除镜像-rmi" class="headerlink" title="3.2.8 删除镜像(rmi)"></a>3.2.8 删除镜像(rmi)</h4><p>使用<code>docker rmi</code>删除镜像。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker rmi [Options] Image</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-f：强制删除</li><li>–no-prune：不移除该镜像的过程镜像，默认移除</li></ul><p><strong>示例：</strong><br>强制删除本地镜像。</p><div class="code-wrapper"><pre><code class="hljs bash">docker rmi -f ubuntu_16.04.tar</code></pre></div><p><strong>注意：</strong></p><blockquote><ul><li><code>docker rm</code>命令是删除容器，而<code>docker rmi</code>命令是删除镜像(remove <strong>i</strong>mage)。</li><li>当出现同一个Image ID对应多个Repository:Tag时，使用<code>docker rmi Repository:Tag</code>可以删除对应的镜像，此时会显示<code>Untagged: Repository:Tag</code>；而加上参数<code>-f</code>，使用<code>docker rmi -f ImageID</code>会删除对应Image ID的所有镜像。</li></ul></blockquote><h4 id="3-2-9-创建Dockerfile"><a href="#3-2-9-创建Dockerfile" class="headerlink" title="3.2.9 创建Dockerfile"></a>3.2.9 创建Dockerfile</h4><p>我们可以使用<code>docker build</code>来创建一个新的镜像。首先需要创建一个Dockerfile，包含一些如何创建镜像的指令。</p><p>新建一个目录和一个Dockerfile</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> Dockerfile</code></pre></div><p>在Dockerfile中写入创建信息，Dockerfile 中每一条指令都创建镜像的一层，例如：</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># This is a comment</span><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">14.04</span><span class="hljs-keyword">MAINTAINER</span> Docker Newbee &lt;newbee@docker.com&gt;<span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -qq update</span><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -qqy install ruby ruby-dev</span><span class="hljs-keyword">RUN</span><span class="language-bash"> gem install sinatra</span></code></pre></div><p><strong>Dockerfile 基本的语法是：</strong></p><ul><li><code>#</code> 注释</li><li><code>FROM</code> 告诉Docker使用哪个镜像作为基础</li><li><code>MAINTAINER</code> 维护者信息</li><li><code>RUN</code> 该指令会在创建中运行，比如安装一个软件包，在这里使用<code>apt-get</code>来安装了一些软件</li></ul><h4 id="3-2-10-从Dockerfile创建镜像-build"><a href="#3-2-10-从Dockerfile创建镜像-build" class="headerlink" title="3.2.10 从Dockerfile创建镜像(build)"></a>3.2.10 从Dockerfile创建镜像(build)</h4><p>对于已有的Dockerfile，可以使用<code>docker build</code>来生成镜像。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker build [Options] Path | Url | -</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-f：指定要使用的Dockerfile路径</li><li>-t&#x2F;-tag：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签</li><li>–build-arg&#x3D;[]：设置镜像创建时的变量</li><li>–cpu-shares：设置 cpu 使用权重</li><li>–cpu-period：限制 CPU CFS周期</li><li>–cpu-quota：限制 CPU CFS配额</li><li>–cpuset-cpus：指定使用的CPU id</li><li>–cpuset-mems：指定使用的内存 id</li><li>–disable-content-trust：忽略校验，默认开启</li><li>–force-rm：设置镜像过程中删除中间容器</li><li>–isolation：使用容器隔离技术</li><li>–label&#x3D;[]：设置镜像使用的元数据</li><li>-m：设置内存最大值</li><li>–memory-swap：设置Swap的最大值为内存+swap，”-1”表示不限swap</li><li>–no-cache：创建镜像的过程不使用缓存</li><li>–pull：尝试去更新镜像的新版本</li><li>–quiet， -q：安静模式，成功后只输出镜像ID</li><li>–rm：设置镜像成功后删除中间容器</li><li>–shm-size：设置&#x2F;dev&#x2F;shm的大小，默认值是64M</li><li>–ulimit：Ulimit配置</li><li>–squash：将 Dockerfile 中所有的操作压缩为一层</li><li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p><strong>示例：</strong><br>使用当前目录(用<code>.</code>表示)的 Dockerfile 创建镜像，标签为 walker&#x2F;ubuntu:v1。</p><div class="code-wrapper"><pre><code class="hljs bash">docker build -t walker/ubuntu:v1 .</code></pre></div><p>使用URL github.com&#x2F;creack&#x2F;docker-firefox 的 Dockerfile 创建镜像。</p><div class="code-wrapper"><pre><code class="hljs bash">docker build github.com/creack/docker-firefox</code></pre></div><p>也可以通过<code>-f</code>指定Dockerfile文件的位置。</p><div class="code-wrapper"><pre><code class="hljs bash">docker build -f /path/to/a/Dockerfile .</code></pre></div><p><strong>注意：</strong>  </p><blockquote><p>在使用<code>docker build</code>命令时，<code>Docker client</code>会发送执行命令时同级目录下的所有文件到<code>Docker daemon</code>，因此建议<code>cd</code>到Dockerfile所在路径，并保证该路径下无其他大文件。</p></blockquote><h4 id="3-2-11-标记镜像-tag"><a href="#3-2-11-标记镜像-tag" class="headerlink" title="3.2.11 标记镜像(tag)"></a>3.2.11 标记镜像(tag)</h4><p>使用<code>docker tag</code>标记本地镜像，将其归入某一仓库。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker tag [Options] Image[:Tag] [RegistryHost/][Username/]Name[:Tag]</code></pre></div><p><strong>示例：</strong><br>将镜像ubuntu:15.10标记为 walker&#x2F;ubuntu:v3 镜像。</p><div class="code-wrapper"><pre><code class="hljs bash">docker tag ubuntu:15.10 walker/ubuntu:v3</code></pre></div><h4 id="3-2-12-镜像历史-history"><a href="#3-2-12-镜像历史-history" class="headerlink" title="3.2.12 镜像历史(history)"></a>3.2.12 镜像历史(history)</h4><p>使用<code>docker history</code>查看指定镜像的创建历史。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> [Options] Image</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-H：以可读的格式打印镜像大小和日期，默认为true</li><li>–no-trunc：显示完整的提交记录</li><li>-q：仅列出提交记录ID</li></ul><p><strong>示例：</strong><br>查看本地镜像walker&#x2F;ubuntu:v3的创建历史。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> walker/ubuntu:v3</code></pre></div><h4 id="3-2-13-导入镜像-import"><a href="#3-2-13-导入镜像-import" class="headerlink" title="3.2.13 导入镜像(import)"></a>3.2.13 导入镜像(import)</h4><p>使用<code>docker import</code>从归档文件中创建镜像。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker import [Options] file|URL|- [REPOSITORY[:TAG]]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-c：应用docker 指令创建镜像</li><li>-m：提交时的说明文字</li></ul><p><strong>示例：</strong><br>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为walker&#x2F;ubuntu:v4。</p><div class="code-wrapper"><pre><code class="hljs bash">docker import my_ubuntu_v3.tar walker/ubuntu:v4</code></pre></div><p><strong>注意：</strong> </p><blockquote><ul><li><code>import</code>与[<code>export</code>](# 3.3.3 导出容器(export))是一对命令，<code>export</code>用于从<strong>容器</strong>导出得到归档文件；而<code>import</code>用于导入归档文件获得镜像 。</li><li><code>save</code>与<code>load</code>是一对命令，<code>save</code>用于将镜像到处得到归档文件；而load用于导入归档文件获得镜像。</li><li>这四个命令中只有<code>export</code>的操作对象是容器。</li></ul></blockquote><h3 id="3-3-容器操作"><a href="#3-3-容器操作" class="headerlink" title="3.3 容器操作"></a>3.3 容器操作</h3><h4 id="3-3-1-列出容器-ps"><a href="#3-3-1-列出容器-ps" class="headerlink" title="3.3.1 列出容器(ps)"></a>3.3.1 列出容器(ps)</h4><p>使用<code>docker ps</code>列出容器。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker ps [Options]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-a：显示所有的容器，包括未运行的</li><li>-f：根据条件过滤显示的内容</li><li>–format：指定返回值的模板文件</li><li>-l：显示最近创建的容器</li><li>-n：列出最近创建的n个容器</li><li>–no-trunc：不截断输出</li><li>-q：静默模式，只显示容器编号</li><li>-s：显示总的文件大小</li></ul><p><strong>示例：</strong><br>列出所有在运行的容器信息。</p><div class="code-wrapper"><pre><code class="hljs bash">docker ps</code></pre></div><h4 id="3-3-2-连接进入容器-attach"><a href="#3-3-2-连接进入容器-attach" class="headerlink" title="3.3.2 连接进入容器(attach)"></a>3.3.2 连接进入容器(attach)</h4><p>使用<code>docker attach</code>连接到正在运行中的容器。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker attach [Options] CONTAINER</code></pre></div><p><strong>注意：</strong> </p><blockquote><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕(与screen命令的attach类似)。官方文档中说attach后可以通过Ctrl+C来detach，但实际上经过我的测试，如果container当前在运行bash，Ctrl+C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，Ctrl+C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy&#x3D;false来确保Ctrl+D或Ctrl+C不会关闭容器。</p></blockquote><p><strong>示例：</strong><br>容器<code>mynginx</code>将访问日志指到标准输出，连接到容器查看访问信息。</p><div class="code-wrapper"><pre><code class="hljs bash">docker attach --sig-proxy=<span class="hljs-literal">false</span> mynginx</code></pre></div><h4 id="3-3-3-导出容器-export"><a href="#3-3-3-导出容器-export" class="headerlink" title="3.3.3 导出容器(export)"></a>3.3.3 导出容器(export)</h4><p>使用<code>docker export</code>将文件系统作为一个tar归档文件导出。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> [Options] CONTAINER</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-o：将输入内容写到文件。</li></ul><p><strong>示例：</strong><br>将<code>id</code>为<code>a404c6c174a2</code>的容器按日期保存为tar文件。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> -o mysql-`<span class="hljs-built_in">date</span> +%Y%m%d`.tar a404c6c174a2</code></pre></div><h4 id="3-3-4-获取元数据-inspect"><a href="#3-3-4-获取元数据-inspect" class="headerlink" title="3.3.4 获取元数据(inspect)"></a>3.3.4 获取元数据(inspect)</h4><p>使用<code>docker inspect</code>获取容器&#x2F;镜像的元数据。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker inspect [Options] NAME|ID [NAME|ID...]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-f：指定返回值的模板文件</li><li>-s：显示总的文件大小</li><li>–type：为指定类型返回JSON</li></ul><p><strong>示例：</strong><br>获取镜像mysql:5.6的元信息。</p><div class="code-wrapper"><pre><code class="hljs bash">docker inspect mysql:5.6</code></pre></div><h4 id="3-3-5-容器进程-top"><a href="#3-3-5-容器进程-top" class="headerlink" title="3.3.5 容器进程(top)"></a>3.3.5 容器进程(top)</h4><p>使用<code>docker top</code>查看容器中运行的进程信息，支持<code>ps</code>命令参数。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker top [Options] Container [ps Options]</code></pre></div><p><strong>注意：</strong></p><blockquote><p>容器运行时不一定有<code>/bin/bash</code>终端来交互执行<code>top</code>命令，而且容器还不一定有<code>top</code>命令，可以使用<code>docker top</code>来实现查看container中正在运行的进程。</p></blockquote><p><strong>示例：</strong><br>查看容器<code>mymysql</code>的进程信息。</p><div class="code-wrapper"><pre><code class="hljs bash">docker top mymysql</code></pre></div><h4 id="3-3-6-容器事件-events"><a href="#3-3-6-容器事件-events" class="headerlink" title="3.3.6 容器事件(events)"></a>3.3.6 容器事件(events)</h4><p>使用<code>docker events</code>从服务器获取实时事件。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker events [Options]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-f ：根据条件过滤事件；</li><li>–since ：从指定的时间戳后显示所有事件;</li><li>–until ：流水时间显示到指定的时间为止；</li></ul><p><strong>示例：</strong><br>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</p><div class="code-wrapper"><pre><code class="hljs bash">docker events -f <span class="hljs-string">&quot;image&quot;</span>=<span class="hljs-string">&quot;mysql:5.6&quot;</span> --since=<span class="hljs-string">&quot;1467302400&quot;</span></code></pre></div><p><strong>注意：</strong></p><blockquote><p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如<code>--since=&quot;2016-07-01</code>。</p></blockquote><h4 id="3-3-7-容器日志-logs"><a href="#3-3-7-容器日志-logs" class="headerlink" title="3.3.7 容器日志(logs)"></a>3.3.7 容器日志(logs)</h4><p>使用<code>docker logs</code>获取容器的日志。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker logs [Options] Container</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-f： 跟踪日志输出</li><li>–since：显示某个开始时间的所有日志</li><li>-t： 显示时间戳</li><li>–tail：仅列出最新N条容器日志</li></ul><p><strong>示例：</strong><br>跟踪查看容器mynginx的日志输出。</p><div class="code-wrapper"><pre><code class="hljs bash">docker logs -f mynginx</code></pre></div><p>查看容器mynginx从2016年7月1日后的最新10条日志。</p><div class="code-wrapper"><pre><code class="hljs bash">docker logs --since=<span class="hljs-string">&quot;2016-07-01&quot;</span> --<span class="hljs-built_in">tail</span>=10 mynginx</code></pre></div><h4 id="3-3-8-阻塞容器-wait"><a href="#3-3-8-阻塞容器-wait" class="headerlink" title="3.3.8 阻塞容器(wait)"></a>3.3.8 阻塞容器(wait)</h4><p>使用<code>docker wait</code>阻塞运行直到容器停止，然后打印出它的退出代码。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">wait</span> [Options] Container [Container...]</code></pre></div><p><strong>示例：</strong><br>跟踪查看容器mynginx的日志输出。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">wait</span> mynginx</code></pre></div><h4 id="3-3-9-容器端口-port"><a href="#3-3-9-容器端口-port" class="headerlink" title="3.3.9 容器端口(port)"></a>3.3.9 容器端口(port)</h4><p>使用<code>docker port</code>列出指定的容器的端口映射，或者查找将<code>PRIVATE_PORT NAT</code>到面向公众的端口。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker port [Options] Container [Private_Port[/Proto]]</code></pre></div><p><strong>示例：</strong><br>查看容器mynginx的端口映射情况。</p><div class="code-wrapper"><pre><code class="hljs bash">docker port mymysql</code></pre></div><h4 id="3-3-10-容器提交-commit"><a href="#3-3-10-容器提交-commit" class="headerlink" title="3.3.10 容器提交(commit)"></a>3.3.10 容器提交(commit)</h4><p>使用<code>docker commit</code>从容器创建一个新的镜像。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker commit [Options] Container [Repository[:Tag]]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-a：提交的镜像作者；</li><li>-c：使用Dockerfile指令来创建镜像；</li><li>-m：提交时的说明文字；</li><li>-p：在commit时，将容器暂停。</li></ul><p><strong>yuhong示例：</strong><br>将容器<code>a404c6c174a2</code>保存为新的镜像，并添加提交人信息和说明信息。</p><div class="code-wrapper"><pre><code class="hljs bash">docker commit -a <span class="hljs-string">&quot;walker.com&quot;</span> -m <span class="hljs-string">&quot;my apache&quot;</span> a404c6c174a2  mymysql:v1</code></pre></div><h4 id="3-3-11-容器数据拷贝-cp"><a href="#3-3-11-容器数据拷贝-cp" class="headerlink" title="3.3.11 容器数据拷贝(cp)"></a>3.3.11 容器数据拷贝(cp)</h4><p>使用<code>docker cp</code>进行容器与主机之间的数据拷贝。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> [Options] Container:Src_Path Dest_Path|-</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> [Options] Src_Path|- Container:Dedt_Path</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-L：保持源目标中的链接</li></ul><p><strong>示例：</strong><br>将主机<code>/www/walker</code>目录拷贝到容器<code>96f7f14e99ab</code>的<code>/www</code>目录下。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /www/walker 96f7f14e99ab:/www/</code></pre></div><p>将主机<code>/www/walker</code>目录拷贝到容器<code>96f7f14e99ab</code>中，目录重命名为<code>www</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /www/walker 96f7f14e99ab:/www</code></pre></div><p>将容器<code>96f7f14e99ab</code>的<code>/www</code>目录拷贝到主机的<code>/tmp</code>目录中。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span>  96f7f14e99ab:/www /tmp/</code></pre></div><h4 id="3-3-12-容器文件结构-diff"><a href="#3-3-12-容器文件结构-diff" class="headerlink" title="3.3.12 容器文件结构(diff)"></a>3.3.12 容器文件结构(diff)</h4><p>使用<code>docker diff</code>检查容器里文件结构的更改。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker diff [Options] Container</code></pre></div><p><strong>示例：</strong><br>查看容器mymysql的文件结构更改。</p><div class="code-wrapper"><pre><code class="hljs bash">docker diff mymysql</code></pre></div><h3 id="3-4-容器生命周期管理"><a href="#3-4-容器生命周期管理" class="headerlink" title="3.4 容器生命周期管理"></a>3.4 容器生命周期管理</h3><h4 id="3-4-1-创建容器-create"><a href="#3-4-1-创建容器-create" class="headerlink" title="3.4.1 创建容器(create)"></a>3.4.1 创建容器(create)</h4><p>使用<code>docker create</code>创建一个新的容器但不启动它。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker create [Options] Inage [Command] [Arg...]</code></pre></div><p><strong>示例：</strong><br>使用docker镜像nginx:latest创建一个容器，并将容器命名为mywalker</p><div class="code-wrapper"><pre><code class="hljs bash">docker create --name mywalker nginx:latest</code></pre></div><h4 id="3-4-2-运行容器-run"><a href="#3-4-2-运行容器-run" class="headerlink" title="3.4.2 运行容器(run)"></a>3.4.2 运行容器(run)</h4><p>使用<code>docker run</code>创建一个新的容器并运行一个命令。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker run [Options] Image [Command] [Arg...]</code></pre></div><p><strong>常用Options：</strong></p><table><thead><tr><th align="left">option</th><th align="left">descriptipon</th></tr></thead><tbody><tr><td align="left">-a， –attach&#x3D;[]</td><td align="left">指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项</td></tr><tr><td align="left">–add-host&#x3D;[]</td><td align="left">Add a custom host-to-IP mapping (host:ip)</td></tr><tr><td align="left">–blkio-weight&#x3D;0</td><td align="left">Block IO (relative weight)， between 10 and 1000</td></tr><tr><td align="left">–cpu-shares&#x3D;0</td><td align="left">CPU shares (relative weight)</td></tr><tr><td align="left">–cap-add&#x3D;[]</td><td align="left">Add Linux capabilities</td></tr><tr><td align="left">–cap-drop&#x3D;[]</td><td align="left">Drop Linux capabilities</td></tr><tr><td align="left">–cgroup-parent&#x3D;</td><td align="left">Optional parent cgroup for the container</td></tr><tr><td align="left">–cidfile&#x3D;</td><td align="left">Write the container ID to the file</td></tr><tr><td align="left">–cpu-period&#x3D;0</td><td align="left">Limit CPU CFS (Completely Fair Scheduler) period</td></tr><tr><td align="left">–cpu-quota&#x3D;0</td><td align="left">Limit CPU CFS (Completely Fair Scheduler) quota</td></tr><tr><td align="left">–cpuset-cpus&#x3D;</td><td align="left">CPUs in which to allow execution (0-3， 0，1)</td></tr><tr><td align="left">–cpuset-mems&#x3D;</td><td align="left">MEMs in which to allow execution (0-3， 0，1)</td></tr><tr><td align="left">-d， –detach&#x3D;false</td><td align="left">后台运行容器，并返回容器ID</td></tr><tr><td align="left">–device&#x3D;[]</td><td align="left">Add a host device to the container</td></tr><tr><td align="left">–disable-content-trust&#x3D;true</td><td align="left">Skip image verification</td></tr><tr><td align="left">–dns&#x3D;[]</td><td align="left">指定容器使用的DNS服务器，默认和宿主一致</td></tr><tr><td align="left">–dns-opt&#x3D;[]</td><td align="left">Set DNS options</td></tr><tr><td align="left">–dns-search&#x3D;[]</td><td align="left">指定容器DNS搜索域名，默认和宿主一致</td></tr><tr><td align="left">-e， –env&#x3D;[]</td><td align="left">设置环境变量</td></tr><tr><td align="left">–entrypoint&#x3D;</td><td align="left">Overwrite the default ENTRYPOINT of the image</td></tr><tr><td align="left">–env-file&#x3D;[]</td><td align="left">从指定文件读入环境变量</td></tr><tr><td align="left">–expose&#x3D;[]</td><td align="left">开放一个端口或一组端口</td></tr><tr><td align="left">–gpu</td><td align="left">使用GPU启动</td></tr><tr><td align="left">–group-add&#x3D;[]</td><td align="left">Add additional groups to join</td></tr><tr><td align="left">-h， –hostname&#x3D;</td><td align="left">指定容器的hostname</td></tr><tr><td align="left">–help&#x3D;false</td><td align="left">Print usage</td></tr><tr><td align="left">-i， –interactive&#x3D;false</td><td align="left">以交互模式运行容器，通常与<code>-t</code>一起同时使用</td></tr><tr><td align="left">–ipc&#x3D;</td><td align="left">IPC namespace to use</td></tr><tr><td align="left">–kernel-memory&#x3D;</td><td align="left">Kernel memory limit</td></tr><tr><td align="left">-l， –label&#x3D;[]</td><td align="left">Set meta data on a container</td></tr><tr><td align="left">–label-file&#x3D;[]</td><td align="left">Read in a line delimited file of labels</td></tr><tr><td align="left">–link&#x3D;[]</td><td align="left">添加链接到另一个容器</td></tr><tr><td align="left">–log-driver&#x3D;</td><td align="left">Logging driver for container</td></tr><tr><td align="left">–log-opt&#x3D;[]</td><td align="left">Log driver options</td></tr><tr><td align="left">–lxc-conf&#x3D;[]</td><td align="left">Add custom lxc options</td></tr><tr><td align="left">-m， –memory&#x3D;</td><td align="left">Memory limit</td></tr><tr><td align="left">–mac-address&#x3D;</td><td align="left">Container MAC address (e.g. 92:d0:c6:0a:29:33)</td></tr><tr><td align="left">–memory-reservation&#x3D;</td><td align="left">Memory soft limit</td></tr><tr><td align="left">–memory-swap&#x3D;</td><td align="left">Total memory (memory + swap)， ‘-1’ to disable swap</td></tr><tr><td align="left">–memory-swappiness&#x3D;-1</td><td align="left">Tuning container memory swappiness (0 to 100)</td></tr><tr><td align="left">–name&#x3D;</td><td align="left">为容器指定一个名称</td></tr><tr><td align="left">–net&#x3D;default</td><td align="left">指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型</td></tr><tr><td align="left">–oom-kill-disable&#x3D;false</td><td align="left">Disable OOM Killer</td></tr><tr><td align="left">-P， –publish-all&#x3D;false</td><td align="left">Publish all exposed ports to random ports</td></tr><tr><td align="left">-p， –publish&#x3D;[]</td><td align="left">指定端口映射，格式为：主机(宿主)端口:容器端口</td></tr><tr><td align="left">–pid&#x3D;</td><td align="left">PID namespace to use</td></tr><tr><td align="left">–privileged&#x3D;false</td><td align="left">Give extended privileges to this container</td></tr><tr><td align="left">–read-only&#x3D;false</td><td align="left">Mount the container’s root filesystem as read only</td></tr><tr><td align="left">–restart&#x3D;no</td><td align="left">Restart policy to apply when a container exits</td></tr><tr><td align="left">–rm&#x3D;false</td><td align="left">Automatically remove the container when it exits</td></tr><tr><td align="left">–runtime&#x3D;nvidia</td><td align="left">在安装nvidia-docker的情况下，使用该参数可以在docker中使用GPU及Nvidia驱动</td></tr><tr><td align="left">–security-opt&#x3D;[]</td><td align="left">Security Options</td></tr><tr><td align="left">–shm-size&#x3D;</td><td align="left">指定容器的shared memory</td></tr><tr><td align="left">–sig-proxy&#x3D;true</td><td align="left">Proxy received signals to the process</td></tr><tr><td align="left">–stop-signal&#x3D;SIGTERM</td><td align="left">Signal to stop a container， SIGTERM by default</td></tr><tr><td align="left"><strong>-t， –tty&#x3D;false</strong></td><td align="left">为容器重新分配一个伪输入终端</td></tr><tr><td align="left">-u， –user&#x3D;</td><td align="left">Username or UID (format: &lt;name</td></tr><tr><td align="left">–ulimit&#x3D;[]</td><td align="left">Ulimit options</td></tr><tr><td align="left">–uts&#x3D;</td><td align="left">UTS namespace to use</td></tr><tr><td align="left">-v， –volume&#x3D;[]</td><td align="left">挂载目录</td></tr><tr><td align="left">–volume-driver&#x3D;</td><td align="left">Optional volume driver for the container</td></tr><tr><td align="left">–volumes-from&#x3D;[]</td><td align="left">Mount volumes from the specified container(s)</td></tr><tr><td align="left">-w， –workdir&#x3D;</td><td align="left">Working directory inside the container</td></tr></tbody></table><p><strong>示例：</strong></p><p><strong>使用镜像nginx:latest以交互模式启动一个容器，命名为mynginx，使用GPU启动，同时将宿主机<code>/data1/walker</code>挂载到docker的<code>/share</code>文件夹下，将宿主机2333端口映射到容器的22端口，为容器分配2G共享内存(Shared Memory)</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker run -it --runtime=nvidia --name=mynginx -v /data1/walker:/share -p 2323:22 --shm-size=<span class="hljs-string">&quot;2g&quot;</span> nginx:latest</code></pre></div><p>使用docker镜像nginx:latest以后台模式启动一个容器，并将容器命名为mynginx。</p><div class="code-wrapper"><pre><code class="hljs bash">docker run --name mynginx -d nginx:latest</code></pre></div><p>使用镜像nginx:latest以后台模式启动一个容器，并将容器的80端口映射到主机随机端口。</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -P -d nginx:latest</code></pre></div><p>使用镜像 nginx:latest，以后台模式启动一个容器，将容器的 80 端口映射到主机的 80 端口，主机的目录 &#x2F;data 映射到容器的 &#x2F;data。</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -p 80:80 -v /data:/data -d nginx:latest</code></pre></div><p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</code></pre></div><h4 id="3-4-3-容器启动-x2F-停止-x2F-重启-start-x2F-stop-x2F-restart"><a href="#3-4-3-容器启动-x2F-停止-x2F-重启-start-x2F-stop-x2F-restart" class="headerlink" title="3.4.3 容器启动&#x2F;停止&#x2F;重启(start&#x2F;stop&#x2F;restart)"></a>3.4.3 容器启动&#x2F;停止&#x2F;重启(start&#x2F;stop&#x2F;restart)</h4><p>使用<code>docker start</code>启动一个或多个已经被停止的容器；<br>使用<code>docker stop</code>停止一个运行中的容器；<br>使用<code>docker restart</code>重启容器。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker start [Options] Container [Container...]</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">docker stop [Options] Container [Container...]</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">docker restart [Options] Container [Container...]</code></pre></div><p><strong>示例：</strong><br>启动已被停止的容器<code>mywalker</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">docker start mywalker</code></pre></div><p>停止运行中的容器<code>mywalker</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">docker stop mywalker</code></pre></div><p>重启容器<code>mywalker</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">docker restart mywalker</code></pre></div><h4 id="3-4-4-容器强制停止-kill"><a href="#3-4-4-容器强制停止-kill" class="headerlink" title="3.4.4 容器强制停止(kill)"></a>3.4.4 容器强制停止(kill)</h4><p>使用<code>docker kill</code>杀掉一个运行中的容器。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> [Options] Container [Container...]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-s：向容器发送一个信号</li></ul><p><strong>示例：</strong><br>杀掉运行中的容器mynginx。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> -s KILL myngin</code></pre></div><p><strong>注意：</strong> </p><blockquote><p><code>docker kill</code>命令不管容器同不同意，执行强行终止；<code>docker stop</code>命令首先给容器发送一个SIGTERM信号，让容器做一些退出前必须的保护性、安全性操作，然后让容器自动停止运行，这是一种更为优雅的退出方式；如果在一段时间内，容器还是没有停止，再考虑使用<code>docker kill</code>命令强行终止。</p></blockquote><h4 id="3-4-5-删除容器-rm"><a href="#3-4-5-删除容器-rm" class="headerlink" title="3.4.5 删除容器(rm)"></a>3.4.5 删除容器(rm)</h4><p>使用<code>docker rm</code>删除一个或多个容器。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> [Options] Container [Container...]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-f：通过 SIGKILL 信号强制删除一个运行中的容器</li><li>-l：移除容器间的网络连接，而非容器本身</li><li>-v：删除与容器关联的卷</li></ul><p><strong>示例：</strong><br>强制删除容器 db01、db02。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f db01 db02</code></pre></div><p>移除容器 nginx01 对容器 db01 的连接，连接名 db。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f db01 db02</code></pre></div><p>删除容器 nginx01， 并删除容器挂载的数据卷。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -v nginx01</code></pre></div><p>删除所有已经停止的容器。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)</code></pre></div><p><strong>注意：</strong></p><blockquote><p><code>docker rm</code>命令是删除容器，而<code>docker rmi</code>命令是删除镜像(remove <strong>i</strong>mage)。</p></blockquote><h4 id="3-4-6-容器暂停与恢复-pause-x2F-unpause"><a href="#3-4-6-容器暂停与恢复-pause-x2F-unpause" class="headerlink" title="3.4.6 容器暂停与恢复(pause&#x2F;unpause)"></a>3.4.6 容器暂停与恢复(pause&#x2F;unpause)</h4><p>使用<code>docker pause</code>暂停容器中所有的进程；<br>使用<code>docker unpause</code>恢复容器中所有的进程。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker pause [Options] Container [Container...]</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">docker unpause [Options] Container [Container...]</code></pre></div><p><strong>示例：</strong><br>暂停数据库容器db01提供服务。</p><div class="code-wrapper"><pre><code class="hljs bash">docker pause db01</code></pre></div><p>恢复数据库容器db01提供服务。</p><div class="code-wrapper"><pre><code class="hljs bash">docker unpause db01</code></pre></div><h4 id="3-4-7-容器执行命令-exec"><a href="#3-4-7-容器执行命令-exec" class="headerlink" title="3.4.7 容器执行命令(exec)"></a>3.4.7 容器执行命令(exec)</h4><p>使用<code>docker exec</code>在运行的容器中执行命令。</p><p><strong>语法：</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> [Options] Container Command [Arg...]</code></pre></div><p><strong>常用Options：</strong></p><ul><li>-d：分离模式: 在后台运行</li><li>-i：即使没有附加也保持STDIN 打开</li><li>-t：分配一个伪终端</li></ul><p><strong>示例：</strong><br>在容器<code>mynginx</code>中以交互模式执行容器内<code>/root/runoob.sh</code>脚本。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mynginx /bin/sh /root/runoob.sh</code></pre></div><p>在容器 mynginx 中开启一个交互模式的终端。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  mynginx /bin/bash</code></pre></div><p>也可以通过<code>docker ps</code>命令查看已经在运行的容器，然后使用容器ID进入容器，再通过<code>docker exec</code>命令对指定的容器执行bash。</p><div class="code-wrapper"><pre><code class="hljs bash">docker psdocker <span class="hljs-built_in">exec</span> -it 9df70f9a0714 /bin/bash</code></pre></div><h3 id="3-5-Docker清理命令汇总"><a href="#3-5-Docker清理命令汇总" class="headerlink" title="3.5 Docker清理命令汇总"></a>3.5 Docker清理命令汇总</h3><p><strong>杀死所有正在运行的容器</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> $(docker ps -a -q)</code></pre></div><p><strong>删除所有已经停止的容器</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)</code></pre></div><p><strong>删除所有未打<code>dangling</code>标签的镜像</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker rmi $(docker images -q -f dangling=<span class="hljs-literal">true</span>)</code></pre></div><p><strong>通过镜像的<code>id</code>来删除指定镜像</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker rmi $(docker images -q)</code></pre></div><p><strong>删除所有镜像</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker rmi &lt;image <span class="hljs-built_in">id</span>&gt;</code></pre></div><h2 id="4-Docker仓库管理"><a href="#4-Docker仓库管理" class="headerlink" title="4 Docker仓库管理"></a>4 Docker仓库管理</h2><p>仓库<code>Repository</code>是集中存放镜像的地方。以下介绍一下 <a href="https://hub.docker.com/">Docker Hub</a>。当然不止DockerHub，只是远程的服务商不一样，操作都是一样的。</p><h3 id="4-1-Docker-Hub"><a href="#4-1-Docker-Hub" class="headerlink" title="4.1 Docker Hub"></a>4.1 Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库<a href="https://hub.docker.com/">Docker Hub</a>。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><ul><li><p><strong>注册</strong><br>在<a href="https://hub.docker.com/">Docker Hub</a>免费注册一个 Docker 账号。</p></li><li><p><strong>登录和退出</strong><br>登录需要输入用户名和密码，使用[<code>docker login(点击查看)</code>](#3.2.1 登入&#x2F;登出(login&#x2F;logout))命令登录成功后，我们就可以从Docker Hub上拉取自己账号下的全部镜像。使用[<code>docker logout(点击查看)</code>](#3.2.1 登入&#x2F;登出(login&#x2F;logout))命令即可退出登录。</p></li><li><p><strong>拉取镜像</strong><br>你可以通过[<code>docker search</code>](#3.2.2 查找镜像(search))命令来查找官方仓库中的镜像，并利用[<code>docker pull</code>](#3.2.3 拉取镜像(pull))命令来将它下载到本地。以 ubuntu 为关键词进行搜索：</p></li><li><p><strong>推送镜像</strong><br>用户登录后，可以通过[<code>docker push</code>](#3.2.4 上传镜像(push))命令将自己的镜像推送到Docker Hub。</p></li></ul><h3 id="4-2-阿里云容器Hub"><a href="#4-2-阿里云容器Hub" class="headerlink" title="4.2 阿里云容器Hub"></a>4.2 阿里云容器Hub</h3><p>我们使用Docker的第一步，应该是获取一个官方的镜像，例如mysql、wordpress，基于这些基础镜像我们可以开发自己个性化的应用。我们可以使用Docker命令行工具来下载官方镜像。但是因为网络原因，我们下载一个300M的镜像需要很长的时间，甚至下载失败。可以通过设置镜像代理站点&#x2F;加速器的方式来对下载加速。<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云容器Hub</a>服务提供了官方的镜像站点加速官方镜像的下载速度。在该网站登录可以获得加速器地址，格式为<code>https://*****.mirror.aliyuncs.com</code>。  </p><p>当你下载安装的Docker Version不低于1.10时，建议直接通过<code>daemon config</code>进行配置。  </p><p>使用配置文件 &#x2F;etc&#x2F;docker&#x2F;daemon.json(没有时新建该文件)。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&lt;your accelerate address&gt;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>然后重启Docker Daemon就可以了。</p><div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div><h2 id="5-Docker网络模式"><a href="#5-Docker网络模式" class="headerlink" title="5 Docker网络模式"></a>5 Docker网络模式</h2><p>docker共有4种网络模式，其中自带3种网络模式：分别是<code>bridge</code>网络，<code>host</code>网络，<code>none</code>网络，可以使用以下命令查看。</p><div class="code-wrapper"><pre><code class="hljs bash">$ docker network <span class="hljs-built_in">ls</span>NETWORK ID     NAME      DRIVER    SCOPE40bf4cb78250   bridge    bridge    <span class="hljs-built_in">local</span>59609bcae8c7   host      host      <span class="hljs-built_in">local</span>4ba3f22b12f7   none      null      <span class="hljs-built_in">local</span></code></pre></div><h3 id="5-1-host网络"><a href="#5-1-host网络" class="headerlink" title="5.1 host网络"></a>5.1 host网络</h3><p>创建容器时，可以使用<code>-net=host</code>指定。</p><p>启动的容器如果指定了网络类型为<code>host</code>模式，那么新创建的容器不会创建自己的虚拟网卡，而是直接使用宿主机的网卡和IP地址，因此容器里面查看到的IP信息就是宿主机的信息，访问容器的时候直接使用<code>宿主机IP:容器端口</code>即可，不过容器的其它资源们比如文件系统，系统进程等还是和宿主机保持隔离。</p><p>此模式的网络性能最高，但是各容器之间端口不能相同(因为该模式直接使用的是宿主机的网络)，适用于运行容器端口比较固定的业务，比如Mysql，Redis等。</p><p>该模式也有一个缺点，容器内已经使用的端口就不能再用了，并且网络的隔离性不好。例如，当通过ssh的方式直接远程登陆至该容器内部时，端口号<code>22</code>已经被宿主机占用，此时需要修改容器内部ssh端口号，并通过<code>宿主机IP:修改后的端口</code>登录。</p><h3 id="5-2-none模式"><a href="#5-2-none模式" class="headerlink" title="5.2 none模式"></a>5.2 none模式</h3><p>创建容器时，可以使用<code>-net=none</code>指定。</p><p>在使用<code>none</code>模式后，docker容器不会进行任何网络配置，其没有网卡，没有IP也没有路由，因此默认无法与外界通信，需要手动添加配置IP等，所以极少使用。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p><h3 id="5-3-bridge模式"><a href="#5-3-bridge模式" class="headerlink" title="5.3 bridge模式"></a>5.3 bridge模式</h3><p>docker的默认模式就是<code>bridge</code>模式，也是使用比较多的模式，此模式创建的容器会为每一个容器分配自己的网络IP等信息，并将容器连接到一个虚拟网桥与外界通信。</p><h3 id="5-4-container模式"><a href="#5-4-container模式" class="headerlink" title="5.4 container模式"></a>5.4 container模式</h3><p>创建容器时，可以使用”-net&#x3D;container:容器名称或容器ID”指定。</p><p>使用此模式创建的容器需指定和一个已经存在的容器共享一个网络，而不是和宿主机共享网络，换句话说，就是两个容器公用同一个IP地址。</p><p>新创建的容器不会创建自己的网卡也不会配置自己的IP，而是和一个已经存在的被指定的容器IP和端口范围，因此这个容器的端口不能和被指定的端口冲突，除了网络之外的文件系统，进程信息等仍然保持相互隔离，两个容器的进程可以通过lo网卡设备通信。</p><h2 id="6-Docker-SSH远程调试"><a href="#6-Docker-SSH远程调试" class="headerlink" title="6 Docker-SSH远程调试"></a>6 Docker-SSH远程调试</h2><p>本章详细讲述使用Pycharm进行远程调试的方法。</p><h3 id="6-1-远程服务器-Docker宿主机-SSH配置"><a href="#6-1-远程服务器-Docker宿主机-SSH配置" class="headerlink" title="6.1 远程服务器(Docker宿主机)SSH配置"></a>6.1 远程服务器(Docker宿主机)SSH配置</h3><p>确保宿主机正确安装openssh-server服务，默认端口22，可以自行修改。</p><h3 id="6-2-Docker-Container-SSH配置"><a href="#6-2-Docker-Container-SSH配置" class="headerlink" title="6.2 Docker Container SSH配置"></a>6.2 Docker Container SSH配置</h3><p>要想通过本地Pycharm调试服务器中的Docker容器中的代码，需要进行端口映射操作；即我们通过端口映射将容器内部向宿主机的一个端口转发出来，然后通过本地Pycharm连接该转发出来的端口，即可对容器内部代码进行调试。</p><ul><li><p>启动Dockers容器时指定参数<code>p</code>，将Dockers容器内部端口映射到宿主机端口：</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -it -p 2021:22 55914e782b13</code></pre></div><p>启动参数<code>-p 2021:22</code>表示端口映射，将容器内部的<code>22</code>端口映射到宿主机的<code>2021</code>端口。</p></li><li><p>Docker容器内安装openssh-server服务</p><div class="code-wrapper"><pre><code class="hljs bash">apt update &amp;&amp; apt install openssh-server</code></pre></div></li><li><p>Docker容器内配置openssh-server服务</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将root的密码修改为test</span>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:12345&#x27;</span> | chpasswd<span class="hljs-comment"># 允许使用root身份登录</span>$ sed -i <span class="hljs-string">&#x27;s/PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config<span class="hljs-comment"># 限制 PAM方式登录</span>$ sed <span class="hljs-string">&#x27;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#x27;</span> -i /etc/pam.d/sshd$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export VISIBLE=now&quot;</span> &gt;&gt; /etc/profile</code></pre></div><p>可将以上代码写成<code>docker_config.sh</code>文件，在Docker容器内运行</p></li><li><p>Docker容器内重启openssh-server服务</p><div class="code-wrapper"><pre><code class="hljs bash">service ssh restart</code></pre></div></li></ul><h3 id="6-3-测试SSH端口映射配置"><a href="#6-3-测试SSH端口映射配置" class="headerlink" title="6.3 测试SSH端口映射配置"></a>6.3 测试SSH端口映射配置</h3><ul><li>Docker容器中ssh服务端口在远程服务器上的映射<div class="code-wrapper"><pre><code class="hljs bash">docker port &lt;your container name&gt; 22<span class="hljs-comment"># 输出结果如下所示</span>0.0.0.0:2021</code></pre></div></li></ul><h3 id="6-4-本地设备-Windows-x2F-Linux-的Pycharm配置"><a href="#6-4-本地设备-Windows-x2F-Linux-的Pycharm配置" class="headerlink" title="6.4 本地设备(Windows&#x2F;Linux)的Pycharm配置"></a>6.4 本地设备(Windows&#x2F;Linux)的Pycharm配置</h3><ul><li><p>在Pycharm中配置Deployment</p>  <div style="text-align: center">  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Deployment.png" alt="Pycharm Deployment" width="40%">  </div></li><li><p>新建SFTP连接</p>  <div style="text-align: center">  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Connection.png" alt="Pycharm SFTP Connection" width="60%">  </div><p>  其中Host填写宿主机IP地址，Port填写Docker容器转发到宿主机的端口(即刚才的<code>2021</code>)，Usernam填写<code>root</code>，passward即为先前在容器内部设置的<code>12345</code>，选择好Root Path后选择Mappings。</p></li><li><p><strong>新建SFTP连接(ipv6)</strong><br>  如果你的宿主机IP地址是ipv6的，那么需要配置Pycharm的ipv6支持：</p><ul><li>在pycharm中打开<code>Help</code> -&gt; <code>Edit Custom VM Options</code></li><li>在该文件中添加一行<code>-Djava.net.preferIPv6Addresses=true</code></li><li>将<code>-Djava.net.preferIPv4Stack=false</code>由<code>true</code>改为<code>false</code>(备选)  <div style="text-align: center">  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-VM-Options.png" alt="Pycharm VM Options" width="60%">  </div></li><li>重启Pycharm</li><li>按照ipv4的方式新建SFTP连接，Host处填写ipv6地址，不过要使用英文中括号<code>[]</code>包裹  <div style="text-align: center">  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Connection-ipv6.png" alt="Pycharm SFTP Connection ipv6" width="60%">  </div></li></ul></li><li><p>映射本地项目至远程服务器</p>  <div style="text-align: center">  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Mappings.png" alt="Pycharm SFTP Mappings" width="70%">  </div><p>  Local path是当前项目路径，Deployment path是远程服务器同步的项目路径。选择完毕后确定。Tools -&gt; Deployment -&gt; Browse Remote Host可以查看远程项目文件。</p></li><li><p>配置Python远程解释器</p><ul><li><p>查看远程Python解释器位置(进入Docker容器内部)</p>   <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> python<span class="hljs-comment"># 输出如下</span>/opt/conda/bin/python</code></pre></div></li><li><p>添加远程Python解释器<br>   在Pycharm中Add Python Interpret，选择SSH Interpret -&gt; Existing server configuration，选择我们刚才配置的SFTP Deployment，若无法下一步，点击<code>move</code>。接着Interpret路径选择刚才找到的Python解释器位置，同步文件夹(Sync folders)修改为远程项目地址，去掉勾选自动上传。</p>   <div style="text-align: center">   <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Interpret-Add.png" alt="Pycharm Interpret Add" width="70%">   </div>   <div style="text-align: center">   <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Interpret-Config.png" alt="Pycharm Interpret Config" width="70%">   </div></li></ul></li><li><p>配置上传方式Tools -&gt; Deployment -&gt; Options，将自动上传改为<code>Ctrl+S</code>。</p>  <div style="text-align: center">  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Deployment-Options.png" alt="Pycharm Deployment Options" width="50%">  </div></li></ul><h2 id="7-Docker使用常见问题"><a href="#7-Docker使用常见问题" class="headerlink" title="7. Docker使用常见问题"></a>7. Docker使用常见问题</h2><h3 id="7-1-Docker容器内用户选择"><a href="#7-1-Docker容器内用户选择" class="headerlink" title="7.1 Docker容器内用户选择"></a>7.1 Docker容器内用户选择</h3><p>Docker在启动时，默认使用的时宿主机的root用户的uid，这就导致两个问题：一时Docker具有宿主机的root权限，安全性很低；二是这样启动的容器如果挂载了宿主机文件，那么在运行时容器所生成的文件在宿主机看来具有root权限，owner是root，这样可能会存在权限上的一些问题。相应的解决方法有两个：</p><ul><li><p>启动容器时指定uid与gid<br>  如果我们想以宿主机的某个用户启动docker，那么在启动时指定参数<code>-u</code>，获取宿主机用户uid和gid的方法如下：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> &lt;username&gt;</code></pre></div><p>  然后根据获得的id指定启动参数</p>  <div class="code-wrapper"><pre><code class="hljs bash">docker run -it --gpus all --name=yuhong -u 1001:1001  55914e782b13</code></pre></div><p>  但是这种方法要求docker容器内已经有对应id的用户组及用户，因此不方便使用。</p></li><li><p>启动容器后在内部建立用户<br>  同样的，我们先在获取宿主机用户uid和gid：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> &lt;username&gt;</code></pre></div><p>  接着在容器内部建立对应id的用户，例如：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 首先设定root密码，防止无法切回账号</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:12345&#x27;</span> | chpasswdgroupadd -g 1001 student<span class="hljs-comment"># 指定命令行为bash</span>useradd -u 1001 -g student -s /bin/bash yuhong <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;yuhong:12345&#x27;</span> | chpasswd</code></pre></div><p>  切换至新建的用户</p>  <div class="code-wrapper"><pre><code class="hljs bash">su yuhong</code></pre></div></li><li><p>如果容器内部所使用的Python环境并非对所有用户有效(例如Conda环境)，可以先查找环境位置，切换用户再激活环境。</p>  <div class="code-wrapper"><pre><code class="hljs bash">su root<span class="hljs-built_in">which</span> pythonsu yuhong<span class="hljs-built_in">cd</span> &lt;python path&gt;<span class="hljs-built_in">source</span> activate</code></pre></div></li><li><p>当在Pycharm中使用非root用户的Deployment时，此用户连接ssh远程解释器可能出现permission denied的情况，此时可以考虑在Docker容器内部建立该用户的home文件夹，并将文件夹权限修改为该用户可用(xrw)，由于此时该用户uid和gid都与root不同，因此需要给<code>777</code>权限。</p></li></ul><h3 id="7-2-Docker容器内部无法联网"><a href="#7-2-Docker容器内部无法联网" class="headerlink" title="7.2 Docker容器内部无法联网"></a>7.2 Docker容器内部无法联网</h3><p>解决方法：在启动时增加参数<code>--net host</code></p><div class="code-wrapper"><pre><code class="hljs bash">docker run -it --gpus all --name=yuhong --net host  55914e782b13</code></pre></div><h3 id="7-3-ImportError"><a href="#7-3-ImportError" class="headerlink" title="7.3 ImportError"></a>7.3 ImportError</h3><p>在容器内部使用python，导入模块时报错”ImportError: libGL.so.1: cannot open shared object file: No such file or directory”。</p><p>解决方法：容器内安装libgl1-mesa-glx</p><div class="code-wrapper"><pre><code class="hljs bash">apt install libgl1-mesa-glx</code></pre></div><h3 id="7-4-No-command-specified"><a href="#7-4-No-command-specified" class="headerlink" title="7.4 No command specified"></a>7.4 No command specified</h3><p>从容器启动Docker的时候报错”Error response from daemon: No command specified”。</p><p>解决方法：指定命令行</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -t -i 87e5b6b3ccc1 /bin/bash</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH</title>
    <link href="/2021/05/29/SSH/"/>
    <url>/2021/05/29/SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><h2 id="1-SSH基本知识"><a href="#1-SSH基本知识" class="headerlink" title="1 SSH基本知识"></a>1 SSH基本知识</h2><p>SSH(SecureShell的缩写)是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。</p><p>实务中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p><h3 id="1-1-SSH是什么"><a href="#1-1-SSH是什么" class="headerlink" title="1.1 SSH是什么"></a>1.1 SSH是什么</h3><p>历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全，一个典型的例子就是服务器登录。登录远程服务器的时候，需要将用户输入的密码传给服务器，如果这个过程是明文通信，就意味着传递过程中，线路经过的中间计算机都能看到密码，这是很可怕的。</p><p>SSH就是为了解决这个问题而诞生的，它能够加密计算机之间的通信，保证不被窃听或篡改。它还能对操作者进行认证(authentication)和授权(authorization)。明文的网络协议可以套用在它里面，从而实现加密。</p><h3 id="1-2-历史"><a href="#1-2-历史" class="headerlink" title="1.2 历史"></a>1.2 历史</h3><p>1995年，芬兰赫尔辛基工业大学的研究员TatuYlönen设计了SSH协议的第一个版本(现称为SSH1)，同时写出了第一个实现(称为SSH1)。</p><p>当时，他所在的大学网络一直发生密码嗅探攻击，他不得不为服务器设计一个更安全的登录方式。写完以后，他就把这个工具公开了，允许其他人免费使用。</p><p>SSH可以替换rlogin、TELNET、FTP和rsh这些不安全的协议，所以大受欢迎，用户快速增长，1995年底已经发展到五十个国家的20,000个用户。SSH1协议也变成IETF的标准文档。</p><p>1995年12月，由于客服需求越来越大，TatuYlönen就成立了一家公司SCS，专门销售和开发SSH。这个软件的后续版本，逐渐从免费软件变成了专有的商业软件。</p><p>SSH1协议存在一些安全漏洞，所以1996年又提出了SSH2协议(或者称为SSH2.0)。这个协议与1.0版不兼容，在1997年进行了标准化，1998年推出了软件实现SSH2。但是，官方的SSH2软件是一个专有软件，不能免费使用，而且SSH1的有些功能也没有提供。</p><p>1999年，OpenBSD的开发人员决定写一个SSH2协议的开源实现，这就是OpenSSH项目。该项目最初是基于SSH1.2.12版本，那是当时SSH1最后一个开源版本。但是，OpenSSH很快就完全摆脱了原始的官方代码，在许多开发者的参与下，按照自己的路线发展。OpenSSH随OpenBSD2.6版本一起提供，以后又移植到其他操作系统，成为最流行的SSH实现。目前，Linux的所有发行版几乎都自带OpenSSH。</p><p>现在，SSH-2有多种实现，既有免费的，也有收费的。本书的内容主要是针对OpenSSH。</p><h3 id="1-3-SSH架构"><a href="#1-3-SSH架构" class="headerlink" title="1.3 SSH架构"></a>1.3 SSH架构</h3><p>SSH的软件架构是服务器-客户端模式(Server-Client)。在这个架构中，SSH软件分成两个部分：向服务器发出请求的部分，称为客户端(client)，OpenSSH的实现为ssh；接收客户端发出的请求的部分，称为服务器(server)，OpenSSH的实现为sshd。</p><p>本教程约定，大写的SSH表示协议，小写的ssh表示客户端软件。</p><p>另外，OpenSSH还提供一些辅助工具软件(比如ssh-keygen、ssh-agent)和专门的客户端工具(比如scp和sftp)，这个教程也会予以介绍。</p><h2 id="2-SSH证书登录"><a href="#2-SSH证书登录" class="headerlink" title="2 SSH证书登录"></a>2 SSH证书登录</h2><p>SSH是服务器登录工具，一般情况下都采用密码登录或密钥登录。</p><p>但是，SSH还有第三种登录方法，那就是证书登录。某些情况下，它是更合理、更安全的登录方法，本节就介绍这种登录方法。</p><h3 id="2-1-非证书登录的缺点"><a href="#2-1-非证书登录的缺点" class="headerlink" title="2.1 非证书登录的缺点"></a>2.1 非证书登录的缺点</h3><p>密码登录和密钥登录，都有各自的缺点。</p><p>密码登录需要输入服务器密码，这非常麻烦，也不安全，存在被暴力破解的风险。</p><p>密钥登录需要服务器保存用户的公钥，也需要用户保存服务器公钥的指纹。这对于多用户、多服务器的大型机构很不方便，如果有员工离职，需要将他的公钥从每台服务器删除。</p><h3 id="2-2-证书登录是什么？"><a href="#2-2-证书登录是什么？" class="headerlink" title="2.2 证书登录是什么？"></a>2.2 证书登录是什么？</h3><p>证书登录就是为了解决上面的缺点而设计的。它引入了一个证书颁发机构(Certificate Authority，简称CA)，对信任的服务器颁发服务器证书，对信任的用户颁发用户证书。</p><p>登录时，用户和服务器不需要提前知道彼此的公钥，只需要交换各自的证书，验证是否可信即可。</p><p>证书登录的主要优点有两个：</p><ol><li>用户和服务器不用交换公钥，这更容易管理，也具有更好的可扩展性。</li><li>证书可以设置到期时间，而公钥没有到期时间。针对不同的情况，可以设置有效期很短的证书，进一步提高安全性。</li></ol><h3 id="2-3-证书登录的流程"><a href="#2-3-证书登录的流程" class="headerlink" title="2.3 证书登录的流程"></a>2.3 证书登录的流程</h3><p>SSH 证书登录之前，如果还没有证书，需要生成证书。具体方法是：</p><ol><li>用户和服务器都将自己的公钥，发给CA；</li><li>CA使用服务器公钥，生成服务器证书，发给服务器；</li><li>CA使用用户的公钥，生成用户证书，发给用户。</li></ol><p>有了证书以后，用户就可以登录服务器了。整个过程都是SSH自动处理，用户无感知。</p><ul><li>第一步，用户登录服务器时，SSH自动将用户证书发给服务器。</li><li>第二步，服务器检查用户证书是否有效，以及是否由可信的CA颁发。证实以后，就可以信任用户。</li><li>第三步，SSH自动将服务器证书发给用户。</li><li>第四步，用户检查服务器证书是否有效，以及是否由信任的CA颁发。证实以后，就可以信任服务器。</li><li>第五步，双方建立连接，服务器允许用户登录。</li></ul><h4 id="2-4-1-生成CA的密钥"><a href="#2-4-1-生成CA的密钥" class="headerlink" title="2.4.1 生成CA的密钥"></a>2.4.1 生成CA的密钥</h4><p>证书登录的前提是，必须有一个CA，而CA本质上就是一对密钥，跟其他密钥没有不同，CA就用这对密钥去签发证书。</p><p>虽然CA可以用同一对密钥签发用户证书和服务器证书，但是出于安全性和灵活性，最好用不同的密钥分别签发。所以，CA至少需要两对密钥，一对是签发用户证书的密钥，假设叫做<code>user_ca</code>，另一对是签发服务器证书的密钥，假设叫做<code>host_ca</code>。</p><p>使用下面的命令，生成<code>user_ca</code>。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 生成CA签发用户证书的密钥</span>$ ssh-keygen -t rsa -b 4096 -f ~/.ssh/user_ca -C user_ca</code></pre></div><p>上面的命令会在<code>~/.ssh</code>目录生成一对密钥：<code>user_ca</code>(私钥)和<code>user_ca.pub</code>(公钥)。</p><p>这个命令的各个参数含义如下。</p><ul><li><code>-t rsa</code>：指定密钥算法RSA。</li><li><code>-b 4096</code>：指定密钥的位数是4096位。安全性要求不高的场合，这个值可以小一点，但是不应小于1024。</li><li><code>-f ~/.ssh/user_ca</code>：指定生成密钥的位置和文件名。</li><li><code>-C user_ca</code>：指定密钥的识别字符串，相当于注释，可以随意设置。</li></ul><p>使用下面的命令，生成<code>host_ca</code>。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 生成CA签发服务器证书的密钥</span>$ ssh-keygen -t rsa -b 4096 -f host_ca -C host_ca</code></pre></div><p>上面的命令会在<code>~/.ssh</code>目录生成一对密钥：<code>host_ca</code>(私钥)和<code>host_ca.pub</code>(公钥)。</p><p>现在，<code>~/.ssh</code>目录应该至少有四把密钥。</p><ul><li><code>~/.ssh/user_ca</code></li><li><code>~/.ssh/user_ca.pub</code></li><li><code>~/.ssh/host_ca</code></li><li><code>~/.ssh/host_ca.pub</code></li></ul><h4 id="2-4-2-CA签发服务器证书"><a href="#2-4-2-CA签发服务器证书" class="headerlink" title="2.4.2 CA签发服务器证书"></a>2.4.2 CA签发服务器证书</h4><p>有了CA以后，就可以签发服务器证书了。</p><p>签发证书，除了CA的密钥以外，还需要服务器的公钥。一般来说，SSH服务器(通常是<code>sshd</code>)安装时，已经生成密钥<code>/etc/ssh/ssh_host_rsa_key</code>了。如果没有的话，可以用下面的命令生成。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo ssh-keygen -f /etc/ssh/ssh_host_rsa_key -b 4096 -t rsa</code></pre></div><p>上面命令会在<code>/etc/ssh</code>目录，生成<code>ssh_host_rsa_key</code>(私钥)和<code>ssh_host_rsa_key.pub</code>(公钥)。然后，需要把服务器公钥<code>ssh_host_rsa_key.pub</code>，复制或上传到CA所在的服务器。</p><p>上传以后，CA 就可以使用密钥<code>host_ca</code>为服务器的公钥<code>ssh_host_rsa_key.pub</code>签发服务器证书。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -s host_ca -I host.example.com -h -n host.example.com -V +52w ssh_host_rsa_key.pub</code></pre></div><p>上面的命令会生成服务器证书<code>ssh_host_rsa_key-cert.pub</code>(服务器公钥名字加后缀<code>-cert</code>)。这个命令各个参数的含义如下。</p><ul><li><code>-s</code>：指定CA签发证书的密钥。</li><li><code>-I</code>：身份字符串，可以随便设置，相当于注释，方便区分证书，将来可以使用这个字符串撤销证书。</li><li><code>-h</code>：指定该证书是服务器证书，而不是用户证书。</li><li><code>-n host.example.com</code>：指定服务器的域名，表示证书仅对该域名有效。如果有多个域名，则使用逗号分隔。用户登录该域名服务器时，SSH 通过证书的这个值，分辨应该使用哪张证书发给用户，用来证明服务器的可信性。</li><li><code>-V +52w</code>：指定证书的有效期，这里为52周(一年)。默认情况下，证书是永远有效的。建议使用该参数指定有效期，并且有效期最好短一点，最长不超过52周。</li><li><code>ssh_host_rsa_key.pub</code>：服务器公钥。</li></ul><p>生成证书以后，可以使用下面的命令，查看证书的细节。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -L -f ssh_host_rsa_key-cert.pub</code></pre></div><p>最后，为证书设置权限。</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> 600 ssh_host_rsa_key-cert.pub</code></pre></div><h4 id="2-4-3-CA签发用户证书"><a href="#2-4-3-CA签发用户证书" class="headerlink" title="2.4.3 CA签发用户证书"></a>2.4.3 CA签发用户证书</h4><p>下面，再用CA签发用户证书。这时需要用户的公钥，如果没有的话，客户端可以用下面的命令生成一对密钥。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -f ~/.ssh/user_key -b 4096 -t rsa</code></pre></div><p>上面命令会在<code>~/.ssh</code>目录，生成<code>user_key</code>(私钥)和<code>user_key.pub</code>(公钥)。</p><p>然后，将用户公钥<code>user_key.pub</code>，上传或复制到CA服务器。接下来，就可以使用CA的密钥<code>user_ca</code>为用户公钥<code>user_key.pub</code>签发用户证书。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -s user_ca -I user@example.com -n user -V +1d user_key.pub</code></pre></div><p>上面的命令会生成用户证书<code>user_key-cert.pub</code>(用户公钥名字加后缀<code>-cert</code>)。这个命令各个参数的含义如下。</p><ul><li><code>-s</code>：指定CA签发证书的密钥</li><li><code>-I</code>：身份字符串，可以随便设置，相当于注释，方便区分证书，将来可以使用这个字符串撤销证书。</li><li><code>-n user</code>：指定用户名，表示证书仅对该用户名有效。如果有多个用户名，使用逗号分隔。用户以该用户名登录服务器时，SSH 通过这个值，分辨应该使用哪张证书，证明自己的身份，发给服务器。</li><li><code>-V +1d</code>：指定证书的有效期，这里为1天，强制用户每天都申请一次证书，提高安全性。默认情况下，证书是永远有效的。</li><li><code>user_key.pub</code>：用户公钥。</li></ul><p>生成证书以后，可以使用下面的命令，查看证书的细节。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -L -f user_key-cert.pub</code></pre></div><p>最后，为证书设置权限。</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> 600 user_key-cert.pub</code></pre></div><h4 id="2-4-4-服务器安装证书"><a href="#2-4-4-服务器安装证书" class="headerlink" title="2.4.4 服务器安装证书"></a>2.4.4 服务器安装证书</h4><p>CA生成服务器证书<code>ssh_host_rsa_key-cert.pub</code>以后，需要将该证书发回服务器，可以使用下面的<code>scp</code>命令，将证书拷贝过去。</p><div class="code-wrapper"><pre><code class="hljs bash">$ scp ~/.ssh/ssh_host_rsa_key-cert.pub root@host.example.com:/etc/ssh/</code></pre></div><p>然后，将下面一行添加到服务器配置文件<code>/etc/ssh/sshd_config</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">HostCertificate /etc/ssh/ssh_host_rsa_key-cert.pub</code></pre></div><p>上面的代码告诉sshd，服务器证书是哪一个文件。</p><p>重新启动sshd。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo systemctl restart sshd.service<span class="hljs-comment"># 或者</span>$ sudo service sshd restart</code></pre></div><h4 id="2-4-5-服务器安装CA公钥"><a href="#2-4-5-服务器安装CA公钥" class="headerlink" title="2.4.5 服务器安装CA公钥"></a>2.4.5 服务器安装CA公钥</h4><p>为了让服务器信任用户证书，必须将CA签发用户证书的公钥<code>user_ca.pub</code>，拷贝到服务器。</p><div class="code-wrapper"><pre><code class="hljs bash">$ scp ~/.ssh/user_ca.pub root@host.example.com:/etc/ssh/</code></pre></div><p>上面的命令，将CA签发用户证书的公钥<code>user_ca.pub</code>，拷贝到SSH服务器的<code>/etc/ssh</code>目录。</p><p>然后，将下面一行添加到服务器配置文件<code>/etc/ssh/sshd_config</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">TrustedUserCAKeys /etc/ssh/user_ca.pub</code></pre></div><p>上面的做法是将<code>user_ca.pub</code>加到<code>/etc/ssh/sshd_config</code>，这会产生全局效果，即服务器的所有账户都会信任<code>user_ca</code>签发的所有用户证书。</p><p>另一种做法是将<code>user_ca.pub</code>加到服务器某个账户的<code>~/.ssh/authorized_keys</code>文件，只让该账户信任<code>user_ca</code>签发的用户证书。具体方法是打开<code>~/.ssh/authorized_keys</code>，追加一行，开头是<code>@cert-authority principals=&quot;...&quot;</code>，然后后面加上<code>user_ca.pub</code>的内容，大概是下面这个样子。</p><div class="code-wrapper"><pre><code class="hljs bash">@cert-authority principals=<span class="hljs-string">&quot;user&quot;</span> ssh-rsa AAAAB3Nz...XNRM1EX2gQ==</code></pre></div><p>上面代码中，<code>principals=&quot;user&quot;</code>指定用户登录的服务器账户名，一般就是<code>authorized_keys</code>文件所在的账户。</p><p>重新启动 sshd。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo systemctl restart sshd.service<span class="hljs-comment"># 或者</span>$ sudo service sshd restart</code></pre></div><p>至此，SSH 服务器已配置为信任<code>user_ca</code>签发的证书。</p><h4 id="2-4-6-客户端安装证书"><a href="#2-4-6-客户端安装证书" class="headerlink" title="2.4.6 客户端安装证书"></a>2.4.6 客户端安装证书</h4><p>客户端安装用户证书很简单，就是从CA将用户证书<code>user_key-cert.pub</code>复制到客户端，与用户的密钥<code>user_key</code>保存在同一个目录即可。</p><h4 id="2-4-7-客户端安装CA公钥"><a href="#2-4-7-客户端安装CA公钥" class="headerlink" title="2.4.7 客户端安装CA公钥"></a>2.4.7 客户端安装CA公钥</h4><p>为了让客户端信任服务器证书，必须将CA签发服务器证书的公钥<code>host_ca.pub</code>，加到客户端的<code>/etc/ssh/ssh_known_hosts</code>文件(全局级别)或者<code>~/.ssh/known_hosts</code>文件(用户级别)。</p><p>具体做法是打开<code>ssh_known_hosts</code>或<code>known_hosts</code>文件，追加一行，开头为<code>@cert-authority *.example.com</code>，然后将<code>host_ca.pub</code>文件的内容(即公钥)粘贴在后面，大概是下面这个样子。</p><div class="code-wrapper"><pre><code class="hljs bash">@cert-authority *.example.com ssh-rsa AAAAB3Nz...XNRM1EX2gQ==</code></pre></div><p>上面代码中，<code>*.example.com</code>是域名的模式匹配，表示只要服务器符合该模式的域名，且签发服务器证书的CA匹配后面给出的公钥，就都可以信任。如果没有域名限制，这里可以写成<code>*</code>。如果有多个域名模式，可以使用逗号分隔；如果服务器没有域名，可以用主机名(比如<code>host1,host2,host3</code>)或者 IP 地址(比如<code>11.12.13.14,21.22.23.24</code>)。</p><p>然后，就可以使用证书，登录远程服务器了。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-i ~/.ssh/user_key user@host.example.com</code></pre></div><p>上面命令的<code>-i</code>参数用来指定用户的密钥。如果证书与密钥在同一个目录，则连接服务器时将自动使用该证书。</p><h4 id="2-4-8-废除证书"><a href="#2-4-8-废除证书" class="headerlink" title="2.4.8 废除证书"></a>2.4.8 废除证书</h4><p>废除证书的操作，分成用户证书的废除和服务器证书的废除两种。</p><p>服务器证书的废除，用户需要在<code>known_hosts</code>文件里面，修改或删除对应的<code>@cert-authority</code>命令的那一行。</p><p>用户证书的废除，需要在服务器新建一个<code>/etc/ssh/revoked_keys</code>文件，然后在配置文件<code>sshd_config</code>添加一行，内容如下。</p><div class="code-wrapper"><pre><code class="hljs bash">RevokedKeys /etc/ssh/revoked_keys</code></pre></div><p><code>revoked_keys</code>文件保存不再信任的用户公钥，由下面的命令生成。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -kf /etc/ssh/revoked_keys -z 1 ~/.ssh/user1_key.pub</code></pre></div><p>上面命令中，<code>-z</code>参数用来指定用户公钥保存在<code>revoked_keys</code>文件的哪一行，这个例子是保存在第1行。</p><p>如果以后需要废除其他的用户公钥，可以用下面的命令保存在第2行。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -ukf /etc/ssh/revoked_keys -z 2 ~/.ssh/user2_key.pub</code></pre></div><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://smallstep.com/blog/ssh-emergency-access/">SSH Emergency Access</a>, Carl Tashian</li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-using_openssh_certificate_authentication">Using OpenSSH Certificate Authentication</a>, Red Hat Enterprise Linux Deployment Guide</li><li><a href="https://gravitational.com/blog/how-to-ssh-properly/">How toSSHProperly</a>, Gus Luxton</li></ul><h2 id="3-SSH客户端"><a href="#3-SSH客户端" class="headerlink" title="3 SSH客户端"></a>3 SSH客户端</h2><h3 id="3-1-OpenSSH"><a href="#3-1-OpenSSH" class="headerlink" title="3.1 OpenSSH"></a>3.1 OpenSSH</h3><p>OpenSSH是SSH的开源版本，并且应用广泛。OpenSSH的客户端是二进制程序ssh。它在Linux&#x2F;Unix系统的位置是<code>/usr/local/bin/ssh</code>，Windows系统的位置是<code>\Program Files\OpenSSH\bin\ssh.exe</code>。</p><p>OpenSSH 包含一系列组件和工具，用于提供一种安全且简单的远程系统管理方法，其中包括：</p><ul><li><code>sshd.exe</code>：它是远程所管理的系统上必须运行的SSH服务器组件</li><li><code>ssh.exe</code>：它是在用户的本地系统上运行的SSH客户端组件</li><li><code>ssh-keygen.exe</code>：为SSH生成、管理和转换身份验证密钥</li><li><code>ssh-agent.exe</code>：存储用于公钥身份验证的私钥</li><li><code>ssh-add.exe</code>：将私钥添加到服务器允许的列表中，即添加到ssh-agent中</li><li><code>ssh-keyscan</code>.exe：帮助从许多主机收集公用SSH主机密钥</li><li><code>sftp.exe</code>：这是提供安全文件传输协议的服务，通过SSH运行</li><li><code>scp.exe</code>：SSH上运行的文件复制实用工具</li></ul><h3 id="3-2-安装SSH服务"><a href="#3-2-安装SSH服务" class="headerlink" title="3.2 安装SSH服务"></a>3.2 安装SSH服务</h3><h4 id="3-2-1-Ubuntu安装SSH服务"><a href="#3-2-1-Ubuntu安装SSH服务" class="headerlink" title="3.2.1 Ubuntu安装SSH服务"></a>3.2.1 Ubuntu安装SSH服务</h4><ul><li><p>安装openssh-server</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo apt install openssh-server</code></pre></div></li><li><p>开启ssh服务</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo service sshd start</code></pre></div></li><li><p>查看ssh服务状态</p>  <div class="code-wrapper"><pre><code class="hljs bash">sudo service sshd status</code></pre></div></li><li><p>安装完即可使用ssh命令行或ssh终端工具(如mobaXterm)在局域网内使用内网IP地址和22端口访问服务器。</p></li></ul><h4 id="3-2-2-Windows安装SSH服务"><a href="#3-2-2-Windows安装SSH服务" class="headerlink" title="3.2.2 Windows安装SSH服务"></a>3.2.2 Windows安装SSH服务</h4><ul><li><p>方式一：设置中安装<br>  对于Windows10系统，可以在设置中安装OpenSSH服务器。从开始菜单打开<code>设置</code>，然后选择<code>应用和功能</code>-&gt;<code>可选功能</code>，搜索并安装<code>OpenSSH服务器</code>。</p></li><li><p>方式二：使用PowerShell部署SSH</p><ul><li><p>用管理员身份启动 PowerShell，使用如下命令看一下，要确保 OpenSSH 可用于安装：</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ Get-WindowsCapability -Online | ? Name -like <span class="hljs-string">&#x27;OpenSSH*&#x27;</span>Name  : OpenSSH.Client~~~~0.0.1.0State : NotPresentName  : OpenSSH.Server~~~~0.0.1.0State : NotPresent</code></pre></div></li><li><p>使用PowerShell安装服务器：</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0Path          :Online        : TrueRestartNeeded : False</code></pre></div></li><li><p>开启SSHD服务</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ Start-Service sshd</code></pre></div></li><li><p>设置自启动SSHD服务</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ Set-Service -Name sshd -StartupType <span class="hljs-string">&#x27;Automatic&#x27;</span></code></pre></div></li><li><p>确认防火墙是否是放开</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ Get-NetFirewallRule -Name *ssh*</code></pre></div><p>  Enabled为True表示防火墙开放。</p></li></ul></li><li><p>Windows上的不同SSH</p><ul><li>Windows操作系统的SSH(C:\Windows\System32\OpenSSH)</li><li>Windows上安装Git后自带的SSH(D:\SoftwarePath\Git\usr\bin)。</li></ul><p>  这两个SSH的ssh-agent是相互独立的，载入私钥时需要独立添加，这意味着如果你在Windows的SSH的ssh-agent中添加了你登录GitHub的私钥，在Git Bash中登录GitHub时仍然可能无法免密登录。但不同SSH共用客户端配置文件<code>~/.ssh/config</code>以及<code>.ssh</code>目录下的私钥。</p></li></ul><h3 id="3-3-基本用法"><a href="#3-3-基本用法" class="headerlink" title="3.3 基本用法"></a>3.3 基本用法</h3><h4 id="3-3-1-用户密码登录"><a href="#3-3-1-用户密码登录" class="headerlink" title="3.3.1 用户密码登录"></a>3.3.1 用户密码登录</h4><p>ssh最常见的用途就是登录服务器，这要求服务器安装并正在运行SSH服务器软件。</p><p>ssh登录服务器的命令如下。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh hostname</code></pre></div><p>上面命令中，<code>hostname</code>是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。如果要指定用户名，可以采用下面的语法。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh user@hostname</code></pre></div><p>上面的命令中，用户名和主机名写在一起了，之间使用<code>@</code>分隔。</p><p>用户名也可以使用<code>ssh</code>的<code>-l</code>参数指定，这样的话，用户名和主机名就不用写在一起了。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh -l username host</code></pre></div><p>ssh 默认连接服务器的22端口，<code>-p</code>参数可以指定其他端口。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh -p 8821 foo.com</code></pre></div><p>上面命令连接服务器<code>foo.com</code>的8821端口。</p><h4 id="3-3-2-连接流程"><a href="#3-3-2-连接流程" class="headerlink" title="3.3.2 连接流程"></a>3.3.2 连接流程</h4><p>ssh 连接远程服务器后，首先有一个验证过程，验证远程服务器是否为陌生地址。</p><p>如果是第一次连接某一台服务器，命令行会显示一段文字，表示不认识这台机器，提醒用户确认是否需要连接。</p><div class="code-wrapper"><pre><code class="hljs bash">The authenticity of host <span class="hljs-string">&#x27;foo.com (192.168.121.111)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span><span class="hljs-string">ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.</span><span class="hljs-string">Are you sure you want to continue connecting (yes/no)?</span></code></pre></div><p>上面这段文字告诉用户，<code>foo.com</code>这台服务器的指纹是陌生的，让用户选择是否要继续连接(输入yes或no)。</p><p>所谓“服务器指纹”，指的是 SSH服务器公钥的哈希值。每台SSH服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。</p><p>下面的命令可以查看某个公钥的指纹。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub256 da:24:43:0b:2e:c1:3f:a1:84:13:92:01:52:b4:84:ff   (ECDSA)</code></pre></div><p>上面的例子中，<code>ssh-keygen -l -f</code>命令会输出公钥<code>/etc/ssh/ssh_host_ecdsa_key.pub</code>的指纹。</p><p>ssh 会将本机连接过的所有服务器公钥的指纹，都储存在本机的<code>~/.ssh/known_hosts</code>文件中。每次连接服务器时，通过该文件判断是否为陌生主机（陌生公钥）。</p><p>在上面这段文字后面，输入<code>yes</code>，就可以将当前服务器的指纹也储存在本机<code>~/.ssh/known_hosts</code>文件中，并显示下面的提示。以后再连接的时候，就不会再出现警告了。</p><div class="code-wrapper"><pre><code class="hljs bash">Warning: Permanently added <span class="hljs-string">&#x27;foo.com (192.168.121.111)&#x27;</span> (RSA) to the list of known hosts</code></pre></div><p>然后，客户端就会跟服务器建立连接。接着，ssh就会要求用户输入所要登录账户的密码。用户输入并验证密码正确以后，就能登录远程服务器的Shell了。</p><h4 id="3-3-3-服务器密钥变更"><a href="#3-3-3-服务器密钥变更" class="headerlink" title="3.3.3 服务器密钥变更"></a>3.3.3 服务器密钥变更</h4><p>服务器指纹可以防止有人恶意冒充远程主机。如果服务器的密钥发生变更(比如重装了SSH服务器)，客户端再次连接时，就会发生公钥指纹不吻合的情况。这时，客户端就会中断连接，并显示一段警告信息。</p><div class="code-wrapper"><pre><code class="hljs bash">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that the RSA host key has just been changed.The fingerprint <span class="hljs-keyword">for</span> the RSA key sent by the remote host is77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.Please contact your system administrator.Add correct host key <span class="hljs-keyword">in</span> /home/me/.ssh/known_hosts to get rid of this message.Offending key <span class="hljs-keyword">in</span> /home/me/.ssh/known_hosts:36</code></pre></div><p>上面这段文字的意思是，该主机的公钥指纹跟<code>~/.ssh/known_hosts</code>文件储存的不一样，必须处理以后才能连接。这时，你需要确认是什么原因，使得公钥指纹发生变更，到底是恶意劫持，还是管理员变更了SSH服务器公钥。</p><p>如果新的公钥确认可以信任，需要继续执行连接，你可以执行下面的命令，将原来的公钥指纹从<code>~/.ssh/known_hosts</code>文件删除。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -R hostname</code></pre></div><p>上面命令中，<code>hostname</code>是发生公钥变更的主机名。</p><p>除了使用上面的命令，你也可以手工修改<code>known_hosts</code>文件，将公钥指纹删除。</p><p>删除了原来的公钥指纹以后，重新执行SSH命令连接远程服务器，将新的指纹加入<code>known_hosts</code>文件，就可以顺利连接了。</p><h4 id="3-3-4-执行远程命令"><a href="#3-3-4-执行远程命令" class="headerlink" title="3.3.4 执行远程命令"></a>3.3.4 执行远程命令</h4><p>SSH登录成功后，用户就进入了远程主机的命令行环境，所看到的提示符，就是远程主机的提示符。这时，你就可以输入想要在远程主机执行的命令。</p><p>另一种执行远程命令的方法，是将命令直接写在<code>ssh</code>命令的后面。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSHusername</span>@hostname <span class="hljs-built_in">command</span></code></pre></div><p>上面的命令会使得SSH在登录成功后，立刻在远程主机上执行命令<code>command</code>。</p><p>下面是一个例子。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSHfoo</span>@server.example.com <span class="hljs-built_in">cat</span> /etc/hosts</code></pre></div><p>上面的命令会在登录成功后，立即远程执行命令<code>cat /etc/hosts</code>。</p><p>采用这种语法执行命令时，ssh 客户端不会提供互动式的 Shell 环境，而是直接将远程命令的执行结果输出在命令行。但是，有些命令需要互动式的 Shell 环境，这时就要使用<code>-t</code>参数。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 报错</span><span class="hljs-variable">$SSHremote</span>.server.com emacsemacs: standard input is not a <span class="hljs-built_in">tty</span><span class="hljs-comment"># 不报错</span><span class="hljs-variable">$SSH</span>-t server.example.com emacs</code></pre></div><p>上面代码中，<code>emacs</code>命令需要一个互动式 Shell，所以报错。只有加上<code>-t</code>参数，ssh 才会分配一个互动式 Shell。</p><h4 id="3-3-5-加密参数"><a href="#3-3-5-加密参数" class="headerlink" title="3.3.5 加密参数"></a>3.3.5 加密参数</h4><p>SSH 连接的握手阶段，客户端必须跟服务端约定加密参数集(cipher suite)。</p><p>加密参数集包含了若干不同的加密参数，它们之间使用下划线连接在一起，下面是一个例子。</p><div class="code-wrapper"><pre><code class="hljs bash">TLS_RSA_WITH_AES_128_CBC_SHA</code></pre></div><p>它的含义如下。</p><ul><li>TLS：加密通信协议</li><li>RSA：密钥交换算法</li><li>AES：加密算法</li><li>128：加密算法的强度</li><li>CBC：加密算法的模式</li><li>SHA：数字签名的 Hash 函数</li></ul><p>下面是一个例子，客户端向服务器发出的握手信息。</p><div class="code-wrapper"><pre><code class="hljs http">Handshake protocol: ClientHello    Version: TLS 1.2    Random        Client time: May 22, 2030 02:43:46 GMT        Random bytes: b76b0e61829557eb4c611adfd2d36eb232dc1332fe29802e321ee871    Session ID: (empty)    Cipher Suites        Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256”        Suite: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256        Suite: TLS_RSA_WITH_AES_128_GCM_SHA256        Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA        Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA        Suite: TLS_RSA_WITH_AES_128_CBC_SHA        Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA        Suite: TLS_RSA_WITH_RC4_128_SHA    Compression methods        Method: null    Extensions        Extension: server_name            Hostname: www.feistyduck.com        Extension: renegotiation_info        Extension: elliptic_curves            Named curve: secp256r1            Named curve: secp384r1        Extension: signature_algorithms            Algorithm: sha1/rsa            Algorithm: sha256/rsa            Algorithm: sha1/ecdsa            Algorithm: sha256/ecdsa”</code></pre></div><p>上面的握手信息(ClientHello)之中，<code>Cipher Suites</code>字段就是客户端列出可选的加密参数集，服务器在其中选择一个自己支持的参数集。</p><p>服务器选择完毕之后，向客户端发出回应。</p><div class="code-wrapper"><pre><code class="hljs http">Handshake protocol: ServerHello    Version: TLS 1.2    Random        Server time: Mar 10, 2059 02:35:57 GMT”        Random bytes: 8469b09b480c1978182ce1b59290487609f41132312ca22aacaf5012    Session ID: 4cae75c91cf5adf55f93c9fb5dd36d19903b1182029af3d527b7a42ef1c32c80    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    Compression method: null    Extensions        Extension: server_name        Extension: renegotiation_info”</code></pre></div><p>上面的回应信息(ServerHello)中，<code>Cipher Suite</code>字段就是服务器最终选定的加密参数。</p><h3 id="3-4-SSH命令行配置项"><a href="#3-4-SSH命令行配置项" class="headerlink" title="3.4 SSH命令行配置项"></a>3.4 SSH命令行配置项</h3><ul><li><p><code>-c</code><br>  作用：指定加密算法。<br>  举例：指定使用加密算法<code>blowfish</code>或<code>3des</code>。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-c blowfish -c 3des server.example.com</code></pre></div></li><li><p><code>-C</code><br>  作用：压缩数据传输。<br>  举例：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-C server.example.com</code></pre></div></li><li><p><code>-D</code><br>  作用：指定本机的 Socks 监听端口，该端口收到的请求，都将转发到远程的SSH主机，又称动态端口转发。<br>  举例：将本机<code>1080</code>端口收到的请求，都转发到服务器<code>server</code>。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-D 1080 server</code></pre></div></li><li><p><code>-f</code><br>  作用：SSH 连接在后台运行。</p></li><li><p><code>-F</code><br>  作用：指定配置文件。<br>  举例：指定使用配置文件<code>other_config</code>。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-F /usr/local/ssh/other_config</code></pre></div></li><li><p><code>-i</code><br>  作用：指定私钥，意为“identity_file”，默认值为<code>~/.ssh/id_dsa</code>(DSA 算法)和<code>~/.ssh/id_rsa</code>(RSA 算法)。<br>  举例：指定使用配置文件<code>other_config</code>。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-F /usr/local/ssh/other_config</code></pre></div></li><li><p><code>-l</code><br>  作用：指定远程登录的账户名。<br>  举例：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-l sally server.example.com<span class="hljs-comment"># 等同于</span><span class="hljs-variable">$SSHsally</span>@server.example.com</code></pre></div></li><li><p><code>-L</code><br>  作用：设置本地端口转发。<br>  举例：下面命令中，所有发向本地9999端口的请求，都会经过remoteServer发往targetServer的<code>80</code>端口，这就相当于直接连上了targetServer的<code>80</code>端口。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L 9999:targetServer:80 user@remoteserver</code></pre></div></li><li><p><code>-m</code><br>  作用：指定校验数据完整性的算法(message authentication code，简称MAC)。<br>  举例：下面命令指定数据校验算法为<code>hmac-sha1</code>或<code>hmac-md5</code>。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-m hmac-sha1,hmac-md5 server.example.com</code></pre></div></li><li><p><code>-N</code><br>  作用：用于端口转发，表示建立的SSH只用于端口转发，不能执行远程命令，这样可以提供安全性。<br>  举例：指定使用配置文件<code>other_config</code>。</p></li><li><p><code>-o</code><br>  作用：指定一个配置命令。<br>  举例：指定使用配置文件<code>Keyword Value</code>，配置文件里面有如下内容：</p>  <div class="code-wrapper"><pre><code class="hljs txt">User sallyPort 220</code></pre></div><p>  通过<code>-o</code>参数，可以把上面两个配置命令从命令行传入：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-o <span class="hljs-string">&quot;User sally&quot;</span> -o <span class="hljs-string">&quot;Port 220&quot;</span> server.example.com</code></pre></div><p>  使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-o User=sally -o Port=220 server.example.com</code></pre></div></li><li><p><code>-p</code><br>  作用：指定SSH客户端连接的服务器端口。<br>  举例：上面命令连接服务器的<code>2021</code>端口。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>–q foo.comroot’s password:</code></pre></div></li><li><p><code>-q</code><br>  作用：安静模式(quiet)，不向用户输出任何警告信息。<br>  举例：下面命令使用该参数，只输出要求用户输入密码的提示。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-F /usr/local/ssh/other_config</code></pre></div></li><li><p><code>-R</code><br>  作用：指定远程端口转发。<br>  举例：下面命令需在跳板服务器执行，指定本地计算机local监听自己的<code>9999</code>端口，所有发向这个端口的请求，都会转向targetServer的<code>902</code>端口。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-R 9999:targetServer:902 <span class="hljs-built_in">local</span></code></pre></div></li><li><p><code>-t</code><br>  作用：在SSH直接运行远端命令时，提供一个互动式Shell。<br>  举例：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-t server.example.com emacs</code></pre></div></li><li><p><code>-v</code><br>  作用：显示详细信息。<br>  举例：该参数可以重复多次，表示信息的详细程度，比如<code>-vv</code>和<code>-vvv</code>。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-v server.example.com<span class="hljs-comment"># 或者</span><span class="hljs-variable">$SSH</span>-vvv server.example.com<span class="hljs-comment"># 或者</span><span class="hljs-variable">$SSH</span>-v -v -v server.example.com</code></pre></div></li><li><p><code>-V</code><br>  作用：输出SSH客户端的版本。<br>  举例：下面命令使用该参数，只输出要求用户输入密码的提示。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>–VOpenSSH_for_Windows_8.1p1, LibreSSL 3.0.2</code></pre></div></li><li><p><code>-X</code><br>  作用：打开X窗口转发。<br>  举例：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-X server.example.com</code></pre></div></li><li><p><code>-1, -2</code><br>  作用：<code>-1</code>参数指定使用SSH1协议。<code>-2</code>参数指定使用SSH2协议。<br>  举例：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-2 server.example.com</code></pre></div></li><li><p><code>-4, -6</code><br>  作用：<code>-4</code>指定使用IPv4协议，这是默认值；<code>-6</code>指定使用IPv6协议。<br>  举例：</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-6 server.example.com</code></pre></div></li></ul><h3 id="3-5客户端配置文件"><a href="#3-5客户端配置文件" class="headerlink" title="3.5客户端配置文件"></a>3.5客户端配置文件</h3><h4 id="3-5-1-位置"><a href="#3-5-1-位置" class="headerlink" title="3.5.1 位置"></a>3.5.1 位置</h4><p>SSH 客户端的全局配置文件是<code>/etc/ssh/ssh_config</code>，用户个人的配置文件在<code>~/.ssh/config</code>，优先级高于全局配置文件。</p><p>除了配置文件，<code>~/.ssh</code>目录还有一些用户个人的密钥文件和其他文件。下面是其中一些常见的文件。</p><ul><li><code>~/.ssh/id_ecdsa</code>：用户的ECDSA私钥。</li><li><code>~/.ssh/id_ecdsa.pub</code>：用户的ECDSA公钥。</li><li><code>~/.ssh/id_rsa</code>：用于SSH协议版本2的RSA私钥。</li><li><code>~/.ssh/id_rsa.pub</code>：用于SSH 协议版本2的RSA公钥。</li><li><code>~/.ssh/identity</code>：用于SSH协议版本1的RSA私钥。</li><li><code>~/.ssh/identity.pub</code>：用于SSH协议版本1的RSA公钥。</li><li><code>~/.ssh/known_hosts</code>：包含SSH服务器的公钥指纹。</li></ul><h4 id="3-5-2-主机设置"><a href="#3-5-2-主机设置" class="headerlink" title="3.5.2 主机设置"></a>3.5.2 主机设置</h4><p>用户个人的配置文件<code>~/.ssh/config</code>，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数。下面是一个例子。</p><div class="code-wrapper"><pre><code class="hljs bash">Host *     Port 2222Host remoteserver     HostName remote.example.com     User neo     Port 2112</code></pre></div><p>上面代码中，<code>Host *</code>表示对所有主机生效，后面的<code>Port 2222</code>表示所有主机的默认连接端口都是2222，这样就不用在登录时特别指定端口了。这里的缩进并不是必需的，只是为了视觉上，易于识别针对不同主机的设置。</p><p>后面的<code>Host remoteserver</code>表示，下面的设置只对主机<code>remoteserver</code>生效。<code>remoteserver</code>只是一个别名，具体的主机由<code>HostName</code>命令指定，<code>User</code>和<code>Port</code>这两项分别表示用户名和端口。这里的<code>Port</code>会覆盖上面<code>Host *</code>部分的<code>Port</code>设置。</p><p>以后，登录<code>remote.example.com</code>时，只要执行<code>ssh remoteserver</code>命令，就会自动套用config文件里面指定的参数。<br>单个主机的配置格式如下。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSHremoteserver</span><span class="hljs-comment"># 等同于</span><span class="hljs-variable">$SSH</span>-p 2112 neo@remote.example.com</code></pre></div><p><code>Host</code>命令的值可以使用通配符，比如<code>Host *</code>表示对所有主机都有效的设置，<code>Host *.edu</code>表示只对一级域名为<code>.edu</code>的主机有效的设置。它们的设置都可以被单个主机的设置覆盖。</p><h4 id="3-5-3-配置命令的语法"><a href="#3-5-3-配置命令的语法" class="headerlink" title="3.5.3 配置命令的语法"></a>3.5.3 配置命令的语法</h4><p>ssh客户端配置文件的每一行，就是一个配置命令。配置命令与对应的值之间，可以使用空格，也可以使用等号。</p><div class="code-wrapper"><pre><code class="hljs bash">Compression <span class="hljs-built_in">yes</span><span class="hljs-comment"># 等同于</span>Compression = <span class="hljs-built_in">yes</span></code></pre></div><p><code>#</code>开头的行表示注释，会被忽略。空行等同于注释。</p><h3 id="3-5-4-主要配置命令"><a href="#3-5-4-主要配置命令" class="headerlink" title="3.5.4 主要配置命令"></a>3.5.4 主要配置命令</h3><p>下面是SSH客户端的一些主要配置命令，以及它们的范例值。</p><ul><li><code>AddressFamily inet</code>：表示只使用 IPv4 协议。如果设为<code>inet6</code>，表示只使用 IPv6 协议。</li><li><code>BindAddress 192.168.10.235</code>：指定本机的 IP 地址(如果本机有多个 IP 地址)。</li><li><code>CheckHostIP yes</code>：检查SSH服务器的 IP 地址是否跟公钥数据库吻合。</li><li><code>Ciphers blowfish,3des</code>：指定加密算法。</li><li><code>Compression yes</code>：是否压缩传输信号。</li><li><code>ConnectionAttempts 10</code>：客户端进行连接时，最大的尝试次数。</li><li><code>ConnectTimeout 60</code>：客户端进行连接时，服务器在指定秒数内没有回复，则中断连接尝试。</li><li><code>DynamicForward 1080</code>：指定动态转发端口。</li><li><code>GlobalKnownHostsFile /users/smith/.ssh/my_global_hosts_file</code>：指定全局的公钥数据库文件的位置。</li><li><code>Host server.example.com</code>：指定连接的域名或 IP 地址，也可以是别名，支持通配符。<code>Host</code>命令后面的所有配置，都是针对该主机的，直到下一个<code>Host</code>命令为止。</li><li><code>HostKeyAlgorithms ssh-dss,ssh-rsa</code>：指定密钥算法，优先级从高到低排列。</li><li><code>HostName myserver.example.com</code>：在<code>Host</code>命令使用别名的情况下，<code>HostName</code>指定域名或 IP 地址。</li><li><code>IdentityFile keyfile</code>：指定私钥文件。</li><li><code>LocalForward 2001 localhost:143</code>：指定本地端口转发。</li><li><code>LogLevel QUIET</code>：指定日志详细程度。如果设为<code>QUIET</code>，将不输出大部分的警告和提示。</li><li><code>MACs hmac-sha1,hmac-md5</code>：指定数据校验算法。</li><li><code>NumberOfPasswordPrompts 2</code>：密码登录时，用户输错密码的最大尝试次数。</li><li><code>PasswordAuthentication no</code>：指定是否支持密码登录。不过，这里只是客户端禁止，真正的禁止需要在SSH服务器设置。</li><li><code>Port 2035</code>：指定客户端连接的SSH服务器端口。</li><li><code>PreferredAuthentications publickey,hostbased,password</code>：指定各种登录方法的优先级。</li><li><code>Protocol 2</code>：支持的SSH协议版本，多个版本之间使用逗号分隔。</li><li><code>PubKeyAuthentication yes</code>：是否支持密钥登录。这里只是客户端设置，还需要在SSH服务器进行相应设置。</li><li><code>RemoteForward 2001 server:143</code>：指定远程端口转发。</li><li><code>SendEnv COLOR</code>：SSH 客户端向服务器发送的环境变量名，多个环境变量之间使用空格分隔。环境变量的值从客户端当前环境中拷贝。</li><li><code>ServerAliveCountMax 3</code>：如果没有收到服务器的回应，客户端连续发送多少次<code>keepalive</code>信号，才断开连接。该项默认值为3。</li><li><code>ServerAliveInterval 300</code>：客户端建立连接后，如果在给定秒数内，没有收到服务器发来的消息，客户端向服务器发送<code>keepalive</code>消息。如果不希望客户端发送，这一项设为<code>0</code>。</li><li><code>StrictHostKeyChecking yes</code>：<code>yes</code>表示严格检查，服务器公钥为未知或发生变化，则拒绝连接。<code>no</code>表示如果服务器公钥未知，则加入客户端公钥数据库，如果公钥发生变化，不改变客户端公钥数据库，输出一条警告，依然允许连接继续进行。<code>ask</code>(默认值)表示询问用户是否继续进行。</li><li><code>TCPKeepAlive yes</code>：客户端是否定期向服务器发送<code>keepalive</code>信息。</li><li><code>User userName</code>：指定远程登录的账户名。</li><li><code>UserKnownHostsFile /users/smith/.ssh/my_local_hosts_file</code>：指定当前用户的<code>known_hosts</code>文件(服务器公钥指纹列表)的位置。</li><li><code>VerifyHostKeyDNS yes</code>：是否通过检查SSH服务器的 DNS 记录，确认公钥指纹是否与<code>known_hosts</code>文件保存的一致。</li></ul><h2 id="4-SSH密钥登录"><a href="#4-SSH密钥登录" class="headerlink" title="4 SSH密钥登录"></a>4 SSH密钥登录</h2><p>SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是比密码登录更好的解决方案。</p><h3 id="4-1-密钥是什么"><a href="#4-1-密钥是什么" class="headerlink" title="4.1 密钥是什么"></a>4.1 密钥是什么</h3><p>密钥(key)是一个非常大的数字，通过加密算法得到。对称加密只需要一个密钥，非对称加密需要两个密钥成对使用，分为公钥(public key)和私钥(private key)。</p><p>SSH密钥登录采用的是非对称加密，每个用户通过自己的密钥登录。其中，私钥必须私密保存，不能泄漏；公钥则是公开的，可以对外发送。它们的关系是，公钥和私钥是一一对应的，每一个私钥都有且仅有一个对应的公钥，反之亦然。</p><p>如果数据使用公钥加密，那么只有使用对应的私钥才能解密，其他密钥都不行；反过来，如果使用私钥加密(这个过程一般称为“签名”)，也只有使用对应的公钥解密。</p><h3 id="4-2-密钥登录的过程"><a href="#4-2-密钥登录的过程" class="headerlink" title="4.2 密钥登录的过程"></a>4.2 密钥登录的过程</h3><p>SSH密钥登录分为以下的步骤。</p><p>预备步骤，客户端通过<code>ssh-keygen</code>生成自己的公钥和私钥。</p><ul><li>第一步，手动将客户端的公钥放入远程服务器的指定位置。</li><li>第二步，客户端向服务器发起SHH登录的请求。</li><li>第三步，服务器收到用户SHH登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。</li><li>第四步，客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。</li><li>第五步，服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。</li></ul><h4 id="4-2-1-ssh-keygen命令：生成密钥"><a href="#4-2-1-ssh-keygen命令：生成密钥" class="headerlink" title="4.2.1 ssh-keygen命令：生成密钥"></a>4.2.1 <code>ssh-keygen</code>命令：生成密钥</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>密钥登录时，首先需要生成公钥和私钥。OpenSSH提供了一个工具程序<code>ssh-keygen</code>命令，用来生成密钥。</p><p>直接输入<code>ssh-keygen</code>，程序会询问一系列问题，然后生成密钥。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen</code></pre></div><p>通常做法是使用<code>-t</code>参数，指定密钥的加密算法。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -t dsa</code></pre></div><p>上面示例中，<code>-t</code>参数用来指定密钥的加密算法，一般会选择 DSA 算法或 RSA 算法。如果省略该参数，默认使用 RSA 算法。</p><p>输入上面的命令以后，<code>ssh-keygen</code>会要求用户回答一些问题。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -t dsaGenerating public/private dsa key pair.Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/home/username/.ssh/id_dsa):  press ENTEREnter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): ********Enter same passphrase again: ********Your identification has been saved <span class="hljs-keyword">in</span> /home/username/.ssh/id_dsa.Your public key has been saved <span class="hljs-keyword">in</span> /home/username/.ssh/id_dsa.pub.The key fingerprint is:14:ba:06:98:a8:98:ad:27:b5:ce:55:85:ec:64:37:19 username@shell.isp.com</code></pre></div><p>上面示例中，执行<code>ssh-keygen</code>命令以后，会出现第一个问题，询问密钥保存的文件名，默认是<code>~/.ssh/id_dsa</code>文件，这个是私钥的文件名，对应的公钥文件<code>~/.ssh/id_dsa.pub</code>是自动生成的。用户的密钥一般都放在主目录的<code>.ssh</code>目录里面。</p><p>如果选择<code>rsa</code>算法，生成的密钥文件默认就会是<code>~/.ssh/id_rsa</code>(私钥)和<code>~/.ssh/id_rsa.pub</code>(公钥)。</p><p>接着，就会是第二个问题，询问是否要为私钥文件设定密码保护(passphrase)。这样的话，即使入侵者拿到私钥，还是需要破解密码。如果为了方便，不想设定密码保护，可以直接按回车键，密码就会为空。后面还会让你再输入一次密码，两次输入必须一致。注意，这里“密码”的英文单词是 passphrase，这是为了避免与 Linux 账户的密码单词 password 混淆，表示这不是用户系统账户的密码。</p><p>最后，就会生成私钥和公钥，屏幕上还会给出公钥的指纹，以及当前的用户名和主机名作为注释，用来识别密钥的来源。</p><p>公钥文件和私钥文件都是文本文件，可以用文本编辑器看一下它们的内容。公钥文件的内容类似下面这样。</p><div class="code-wrapper"><pre><code class="hljs bash">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAvpB4lUbAaEbh9u6HLig7amsfywD4fqSZq2ikACIUBn3GyRPfeF93l/weQh702ofXbDydZAKMcDvBJqRhUotQUwqV6HJxqoqPDlPGUUyo8RDIkLUIPRyqypZxmK9aCXokFiHoGCXfQ9imUP/w/jfqb9ByDtG97tUJF6nFMP5WzhM= username@shell.isp.com</code></pre></div><p>上面示例中，末尾的<code>username@shell.isp.com</code>是公钥的注释，用来识别不同的公钥，表示这是哪台主机(<code>shell.isp.com</code>)的哪个用户(<code>username</code>)的公钥，不是必需项。</p><p>注意，公钥只有一行。因为它太长了，所以上面分成三行显示。</p><p>下面的命令可以列出用户所有的公钥。</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -l ~/.ssh/id_*.pub</code></pre></div><p>生成密钥以后，建议修改它们的权限，防止其他人读取。</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa$ <span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa.pub</code></pre></div><h5 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h5><p><code>ssh-keygen</code>的命令行配置项，主要有下面这些。</p><ul><li><p><code>-b</code><br>  <code>-b</code>参数指定密钥的二进制位数。这个参数值越大，密钥就越不容易破解，但是加密解密的计算开销也会加大。一般来说，<code>-b</code>至少应该是<code>1024</code>，更安全一些可以设为<code>2048</code>或者更高。</p></li><li><p><code>-C</code><br>  <code>-C</code>参数可以为密钥文件指定新的注释，格式为<code>username@host</code>。<br>  下面命令生成一个4096位 RSA 加密算法的密钥对，并且给出了用户名和主机名。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@domain.com&quot;</span></code></pre></div></li><li><p><code>-f</code><br>  <code>-f</code>参数指定生成的私钥文件。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -t dsa -f mykey</code></pre></div><p>  上面命令会在当前目录生成私钥文件<code>mykey</code>和公钥文件<code>mykey.pub</code>。</p></li><li><p><code>-F</code><br>  <code>-F</code>参数检查某个主机名是否在<code>known_hosts</code>文件里面。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -F example.com</code></pre></div></li><li><p><code>-N</code><br>  <code>-N</code>参数用于指定私钥的密码(passphrase)。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -t dsa -N secretword</code></pre></div></li><li><p><code>-p</code><br>  <code>-p</code>参数用于重新指定私钥的密码(passphrase)。它与<code>-N</code>的不同之处在于，新密码不在命令中指定，而是执行后再输入。ssh 先要求输入旧密码，然后要求输入两遍新密码。</p></li><li><p><code>-R</code><br>  <code>-R</code>参数将指定的主机公钥指纹移出<code>known_hosts</code>文件。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -R example.com</code></pre></div></li><li><p><code>-t</code><br>  <code>-t</code>参数用于指定生成密钥的加密算法，一般为<code>dsa</code>或<code>rsa</code></p></li></ul><h4 id="4-2-2-手动上传公钥"><a href="#4-2-2-手动上传公钥" class="headerlink" title="4.2.2 手动上传公钥"></a>4.2.2 手动上传公钥</h4><p>生成密钥以后，公钥必须上传到服务器，才能使用私钥登录。</p><p>OpenSSH规定，用户公钥保存在服务器的<code>~/.ssh/authorized_keys</code>文件。你要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的<code>~/.ssh/authorized_keys</code>文件。只要把公钥添加到这个文件之中，就相当于公钥上传到服务器了。每个公钥占据一行。如果该文件不存在，可以手动创建。</p><p>用户可以手动编辑该文件，把公钥粘贴进去，也可以在本机计算机上，执行下面的命令。</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub | SHHuser@host <span class="hljs-string">&quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</span></code></pre></div><p>上面示例中，<code>user@host</code>要替换成你所要登录的用户名和主机名。</p><p>注意，<code>authorized_keys</code>文件的权限要设为<code>644</code>，即只有文件所有者才能写。如果权限设置不对，SSH 服务器可能会拒绝读取该文件。</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> 644 ~/.ssh/authorized_keys$ <span class="hljs-built_in">chmod</span> 700 ~/.ssh</code></pre></div><p>只要公钥上传到服务器，下次登录时，OpenSSH就会自动采用密钥登录，不再提示输入密码。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SHH</span>-l username shell.isp.comEnter passphrase <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;/home/you/.ssh/id_dsa&#x27;</span>: ************Last login: Mon Mar 24 02:17:27 2014 from ex.ample.comshell.isp.com&gt;</code></pre></div><p>上面例子中，SSH客户端使用私钥之前，会要求用户输入密码(passphrase)，用来解开私钥。</p><p>在terminal使用ssh连接服务器：</p><div class="code-wrapper"><pre><code class="hljs bash">ssh -i ~/.ssh/id_rsa -p 22 username@ip</code></pre></div><div style="text-align: center"><img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);"src="ssh-login.png" alt="SSH Login" width="60%"></div><p>使用ssh客户端连接服务器(以mobaXterm为例)：</p><div style="text-align: center"><img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);"src="ssh-login-mobaXterm.png"  alt="SSH Login" width="60%"></div><p>当远程服务器为Windows时，需要对配置项做如下修改：</p><ul><li>切换到<code>C:\ProgramData\ssh\</code>下，修改<code>sshd_config</code>文件</li><li>确保以下3条没有被注释并如下正确设置  <div class="code-wrapper"><pre><code class="hljs bash">PubkeyAuthentication <span class="hljs-built_in">yes</span>AuthorizedKeysFile  .ssh/authorized_keysPasswordAuthentication <span class="hljs-built_in">yes</span></code></pre></div></li><li>确保以下2条有注释  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#Match Group administrators</span>       <span class="hljs-comment">#AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys</span></code></pre></div></li><li>重启SSH服务(以管理员运行)  <div class="code-wrapper"><pre><code class="hljs bash">net stop sshdnet start sshd</code></pre></div></li><li>将本地主机的公钥写入服务器端的对应用户的.ssh&#x2F;authorized_keys文件，若没有该文件手动创建。</li><li>在本地主机terminal使用ssh连接服务器  <div class="code-wrapper"><pre><code class="hljs bash">ssh -i ~/.ssh/id_rsa -p 22 username@ip</code></pre></div></li></ul><h4 id="4-2-3-ssh-copy-id命令：自动上传公钥"><a href="#4-2-3-ssh-copy-id命令：自动上传公钥" class="headerlink" title="4.2.3 ssh-copy-id命令：自动上传公钥"></a>4.2.3 ssh-copy-id命令：自动上传公钥</h4><p>OpenSSH自带一个<code>ssh-copy-id</code>命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。如果<code>~/.ssh/authorized_keys</code>文件不存在，<code>ssh-copy-id</code>命令会自动创建该文件。</p><p>用户在本地计算机执行下面的命令，就可以把本地的公钥拷贝到服务器。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-copy-id -i key_file user@host</code></pre></div><p>上面命令中，<code>-i</code>参数用来指定公钥文件，<code>user</code>是所要登录的账户名，<code>host</code>是服务器地址。如果省略用户名，默认为当前的本机用户名。执行完该命令，公钥就会拷贝到服务器。</p><p>注意，公钥文件可以不指定路径和<code>.pub</code>后缀名，<code>ssh-copy-id</code>会自动在<code>~/.ssh</code>目录里面寻找。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-copy-id -i id_rsa user@host</code></pre></div><p>上面命令中，公钥文件会自动匹配到<code>~/.ssh/id_rsa.pub</code>。</p><p><code>ssh-copy-id</code>会采用密码登录，系统会提示输入远程服务器的密码。</p><p>注意，<code>ssh-copy-id</code>是直接将公钥添加到<code>authorized_keys</code>文件的末尾。如果<code>authorized_keys</code>文件的末尾不是一个换行符，会导致新的公钥添加到前一个公钥的末尾，两个公钥连在一起，使得它们都无法生效。所以，如果<code>authorized_keys</code>文件已经存在，使用<code>ssh-copy-id</code>命令之前，务必保证<code>authorized_keys</code>文件的末尾是换行符(假设该文件已经存在)。</p><h4 id="4-2-4-ssh-agent命令，ssh-add命令"><a href="#4-2-4-ssh-agent命令，ssh-add命令" class="headerlink" title="4.2.4 ssh-agent命令，ssh-add命令"></a>4.2.4 ssh-agent命令，ssh-add命令</h4><h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><p>私钥设置了密码以后，每次使用都必须输入密码，有时让人感觉非常麻烦。比如，连续使用<code>scp</code>命令远程拷贝文件时，每次都要求输入密码。</p><p><code>ssh-agent</code>命令就是为了解决这个问题而设计的，它让用户在整个Bash对话(session)之中，只在第一次使用SHH命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。</p><p>第一步，使用下面的命令新建一次命令行对话。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-agent bash</code></pre></div><p>上面命令中，如果你使用的命令行环境不是Bash，可以用其他的Shell命令代替。比如<code>zsh</code>和<code>fish</code>。</p><p>如果想在当前对话启用<code>ssh-agent</code>，可以使用下面的命令。</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">eval</span> `ssh-agent`</code></pre></div><p>上面命令中，<code>ssh-agent</code>会先自动在后台运行，并将需要设置的环境变量输出在屏幕上，类似下面这样。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-agentSSH_AUTH_SOCK=/tmp/ssh-barrett/ssh-22841-agent; <span class="hljs-built_in">export</span> SSH_AUTH_SOCK;SSH_AGENT_PID=22842; <span class="hljs-built_in">export</span> SSH_AGENT_PID;<span class="hljs-built_in">echo</span> Agent pid 22842;</code></pre></div><p><code>eval</code>命令的作用，就是运行上面的<code>ssh-agent</code>命令的输出，设置环境变量。</p><p>第二步，在新建的 Shell 对话里面，使用<code>ssh-add</code>命令添加默认的私钥(比如<code>~/.ssh/id_rsa</code>，或<code>~/.ssh/id_dsa</code>，或<code>~/.ssh/id_ecdsa</code>，或<code>~/.ssh/id_ed25519</code>)。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-addEnter passphrase <span class="hljs-keyword">for</span> /home/you/.ssh/id_dsa: ********Identity added: /home/you/.ssh/id_dsa (/home/you/.ssh/id_dsa)</code></pre></div><p>上面例子中，添加私钥时，会要求输入密码。以后，在这个对话里面再使用密钥时，就不需要输入私钥的密码了，因为私钥已经加载到内存里面了。</p><p>如果添加的不是默认私钥，<code>ssh-add</code>命令需要显式指定私钥文件。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-add my-other-key-file</code></pre></div><p>上面的命令中，<code>my-other-key-file</code>就是用户指定的私钥文件。</p><p>第三步，使用SHH命令正常登录远程服务器。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh remoteHost</code></pre></div><p>上面命令中，<code>remoteHost</code>是远程服务器的地址，ssh 使用的是默认的私钥。这时如果私钥设有密码，ssh 将不再询问密码，而是直接取出内存里面的私钥。</p><p>如果要使用其他私钥登录服务器，需要使用SHH命令的<code>-i</code>参数指定私钥文件。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh –i OpenSSHPrivateKey remoteHost</code></pre></div><p>最后，如果要退出<code>ssh-agent</code>，可以直接退出子 Shell(按下 Ctrl + d)，也可以使用下面的命令。</p><div class="code-wrapper"><pre><code class="hljs bash">$ ssh-agent -k</code></pre></div><h5 id="ssh-add命令"><a href="#ssh-add命令" class="headerlink" title="ssh-add命令"></a><code>ssh-add</code>命令</h5><p><code>ssh-add</code>命令用来将私钥加入<code>ssh-agent</code>，它有如下的参数。</p><ul><li><p><code>-d</code><br>  <code>-d</code>参数从内存中删除指定的私钥。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-add -d name-of-key-file</code></pre></div></li><li><p><code>-D</code><br>  <code>-D</code>参数从内存中删除所有已经添加的私钥。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-add -D</code></pre></div></li><li><p><code>-l</code><br>  <code>-l</code>参数列出所有已经添加的私钥。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ ssh-add -l</code></pre></div></li></ul><h4 id="4-2-5-关闭密码登录"><a href="#4-2-5-关闭密码登录" class="headerlink" title="4.2.5 关闭密码登录"></a>4.2.5 关闭密码登录</h4><p>为了安全性，启用密钥登录之后，最好关闭服务器的密码登录。</p><p>对于 OpenSSH，具体方法就是打开服务器 sshd 的配置文件<code>/etc/ssh/sshd_config</code>，将<code>PasswordAuthentication</code>这一项设为<code>no</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">PasswordAuthentication no</code></pre></div><p>修改配置文件以后，要重新启动sshd，否则不会生效。</p><div class="code-wrapper"><pre><code class="hljs bash">net stop sshdnet start sshd</code></pre></div><h2 id="5-端口转发"><a href="#5-端口转发" class="headerlink" title="5 端口转发"></a>5 端口转发</h2><p>SSH除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发(port forwarding)，又称SSH隧道(tunnel)。</p><p>端口转发有两个主要作用：</p><ol><li>将不加密的数据放在SSH安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。</li><li>作为数据通信的加密跳板，绕过网络防火墙。</li></ol><p>端口转发有三种使用方法：动态转发，本地转发，远程转发。下面逐一介绍。</p><h3 id="5-1-动态转发"><a href="#5-1-动态转发" class="headerlink" title="5.1 动态转发"></a>5.1 动态转发</h3><p>动态转发指的是，本机与SSH服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过SSH转发。</p><p>动态转发需要把本地端口绑定到SSH服务器。至于SSH服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-D local-port tunnel-host -N</code></pre></div><p>上面命令中，<code>-D</code>表示动态转发，<code>local-port</code>是本地端口，<code>tunnel-host</code>是SSH服务器，<code>-N</code>表示这个SSH连接只进行端口转发，不登录远程Shell，不能执行远程命令，只能充当隧道。</p><p>举例来说，如果本地端口是<code>2121</code>，那么动态转发的命令就是下面这样。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-D 2121 tunnel-host -N</code></pre></div><p>注意，这种转发采用了SOCKS5协议。访问外部网站时，需要把HTTP请求转成SOCKS5协议，才能把本地端口的请求转发出去。</p><p>下面是SSH隧道建立后的一个使用实例。</p><div class="code-wrapper"><pre><code class="hljs bash">$ curl -x socks5://localhost:2121 http://www.example.com</code></pre></div><p>上面命令中，curl的<code>-x</code>参数指定代理服务器，即通过SOCKS5协议的本地<code>2121</code>端口，访问<code>http://www.example.com</code>。</p><p>如果经常使用动态转发，可以将设置写入SSH客户端的用户个人配置文件(~&#x2F;.ssh&#x2F;config)。</p><div class="code-wrapper"><pre><code class="hljs txt">DynamicForward tunnel-host:local-port</code></pre></div><h3 id="5-2-本地转发"><a href="#5-2-本地转发" class="headerlink" title="5.2 本地转发"></a>5.2 本地转发</h3><p>本地转发(local forwarding)指的是，SSH服务器作为中介的跳板机，建立本地计算机与特定目标网站之间的加密连接。本地转发是在本地计算机的SSH客户端建立的转发规则。</p><p>它会指定一个本地端口(local-port)，所有发向那个端口的请求，都会转发到SSH跳板机(tunnel-host)，然后SSH跳板机作为中介，将收到的请求发到目标服务器(target-host)的目标端口(target-host)。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L local-port:target-host:target-port tunnel-host</code></pre></div><p>上面命令中，<code>-L</code>参数表示本地转发，<code>local-port</code>是本地端口，<code>target-host</code>是你想要访问的目标服务器，<code>target-port</code>是目标服务器的端口，<code>tunnel-host</code>是SSH跳板机。</p><p>举例来说，现在有一台SSH跳板机<code>tunnel-host</code>，我们想要通过这台机器，在本地<code>2121</code>端口与目标网站<code>www.example.com</code>的<code>80</code>端口之间建立SSH隧道，就可以写成下面这样。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L 2121:www.example.com:80 tunnel-host -N</code></pre></div><p>然后，访问本机的<code>2121</code>端口，就是访问<code>www.example.com</code>的<code>80</code>端口。</p><div class="code-wrapper"><pre><code class="hljs bash">$ curl http://localhost:2121</code></pre></div><p>注意，本地端口转发采用HTTP协议，不用转成SOCKS5协议。</p><p>另一个例子是加密访问邮件获取协议POP3。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L 1100:mail.example.com:110 mail.example.com</code></pre></div><p>上面命令将本机的<code>1100</code>端口，绑定邮件服务器<code>mail.example.com</code>的<code>110</code>端口(POP3协议的默认端口)。端口转发建立以后，POP3邮件客户端只需要访问本机的<code>1100</code>端口，请求就会通过SSH跳板机(这里是<code>mail.example.com</code>)，自动转发到<code>mail.example.com</code>的<code>110</code>端口。</p><p>上面这种情况有一个前提条件，就是<code>mail.example.com</code>必须运行SSH服务器。否则，就必须通过另一台SSH服务器中介，执行的命令要改成下面这样。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L 1100:mail.example.com:110 other.example.com</code></pre></div><p>上面命令中，本机的<code>1100</code>端口还是绑定<code>mail.example.com</code>的<code>110</code>端口，但是由于<code>mail.example.com</code>没有运行SSH服务器，所以必须通过<code>other.example.com</code>中介。本机的POP3请求通过<code>1100</code>端口，先发给<code>other.example.com</code>的<code>22</code>端口(sshd默认端口)，再由后者转给<code>mail.example.com</code>，得到数据以后再原路返回。</p><p>注意，采用上面的中介方式，只有本机到<code>other.example.com</code>的这一段是加密的，<code>other.example.com</code>到<code>mail.example.com</code>的这一段并不加密。</p><p>这个命令最好加上<code>-N</code>参数，表示不在SSH跳板机执行远程命令，让SSH只充当隧道。另外还有一个<code>-f</code>参数表示SSH连接在后台运行。</p><p>如果经常使用本地转发，可以将设置写入SSH客户端的用户个人配置文件(<code>~/.ssh/config</code>)。</p><div class="code-wrapper"><pre><code class="hljs txt">Host test.example.comLocalForward client-IP:client-port server-IP:server-port</code></pre></div><h3 id="5-3-远程转发"><a href="#5-3-远程转发" class="headerlink" title="5.3 远程转发"></a>5.3 远程转发</h3><p>远程转发指的是在远程SSH服务器建立的转发规则。</p><p>它跟本地转发正好反过来。建立本地计算机到远程计算机的SSH隧道以后，本地转发是通过本地计算机访问远程计算机，而远程转发则是通过远程计算机访问本地计算机。它的命令格式如下。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-R remote-port:target-host:target-port -N remotehost</code></pre></div><p>上面命令中，<code>-R</code>参数表示远程端口转发，<code>remote-port</code>是远程计算机的端口，<code>target-host</code>和<code>target-port</code>是目标服务器及其端口，<code>remotehost</code>是远程计算机。</p><p>远程转发主要针对内网的情况。下面举两个例子。</p><p>第一个例子是内网某台服务器<code>localhost</code>在<code>80</code>端口开了一个服务，可以通过远程转发将这个<code>80</code>端口，映射到具有公网IP地址的<code>my.public.server</code>服务器的<code>8080</code>端口，使得访问<code>my.public.server:8080</code>这个地址，就可以访问到那台内网服务器的<code>80</code>端口。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-R 8080:localhost:80 -N my.public.server</code></pre></div><p>上面命令是在内网<code>localhost</code>服务器上执行，建立从<code>localhost</code>到<code>my.public.server</code>的SSH隧道。运行以后，用户访问<code>my.public.server:8080</code>，就会自动映射到<code>localhost:80</code>。</p><p>第二个例子是本地计算机<code>local</code>在外网，SSH跳板机和目标服务器<code>my.private.server</code>都在内网，必须通过SSH跳板机才能访问目标服务器。但是，本地计算机<code>local</code>无法访问内网之中的SSH跳板机，而SSH跳板机可以访问本机计算机。</p><p>由于本机无法访问内网SSH跳板机，就无法从外网发起SSH隧道，建立端口转发。必须反过来，从SSH跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。跳板机执行下面的命令，绑定本地计算机<code>local</code>的<code>2121</code>端口，去访问<code>my.private.server:80</code>。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-R 2121:my.private.server:80 -N <span class="hljs-built_in">local</span></code></pre></div><p>上面命令是在SSH跳板机上执行的，建立跳板机到<code>local</code>的隧道，并且这条隧道的出口映射到<code>my.private.server:80</code>。</p><p>显然，远程转发要求本地计算机<code>local</code>也安装了SSH服务器，这样才能接受SSH跳板机的远程登录。</p><p>执行上面的命令以后，跳板机到<code>local</code>的隧道已经建立了。然后，就可以从本地计算机访问目标服务器了，即在本机执行下面的命令。</p><div class="code-wrapper"><pre><code class="hljs bash">$ curl http://localhost:2121</code></pre></div><p>本机执行上面的命令以后，就会输出服务器<code>my.private.server</code>的<code>80</code>端口返回的内容。</p><p>如果经常执行远程端口转发，可以将设置写入SSH客户端的用户个人配置文件(<code>~/.ssh/config</code>)。</p><div class="code-wrapper"><pre><code class="hljs txt">Host remote-forward  HostName test.example.com  RemoteForward remote-port target-host:target-port</code></pre></div><p>完成上面的设置后，执行下面的命令就会建立远程转发。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-N remote-forward<span class="hljs-comment"># 等同于</span><span class="hljs-variable">$SSH</span>-R remote-port:target-host:target-port -N test.example.com</code></pre></div><h3 id="5-4-端口转发实例"><a href="#5-4-端口转发实例" class="headerlink" title="5.4 端口转发实例"></a>5.4 端口转发实例</h3><h4 id="5-4-1-ssh连接ipv6服务器"><a href="#5-4-1-ssh连接ipv6服务器" class="headerlink" title="5.4.1 ssh连接ipv6服务器"></a>5.4.1 ssh连接ipv6服务器</h4><p>本实例的目的在于解决高校内ipv4按流量计费的问题，通过连接具有ipv6的远程服务器并进行ssh动态端口转发达到节省ipv4流量的目的。</p><p>本实例的实施条件：</p><ul><li>高校校园网仅ipv4流量计费，ipv6流量不计费</li><li>远程服务器的ipv6地址所属骨干网与教育网骨干网ipv6联通</li></ul><p>具体步骤如下：</p><ul><li><p>获取远程教育网服务器ipv6地址，例如<code>2409:8754:51c0:0:1005:5917:7e7b:5da</code></p></li><li><p>在本地主机使用SSH进行动态端口转发</p>  <div class="code-wrapper"><pre><code class="hljs bash">SSH-D 2021 -N yuhong@2409:8754:51c0:0:1005:5917:7e7b:5da</code></pre></div></li><li><p>在本地配置SOCKS5代理<code>127.0.0.1:2021</code>，使用该代理访问互联网即可通过ipv6将访问请求转发至远程服务器，并通过ipv6返回请求响应。</p></li></ul><h4 id="5-4-2-简易VPN"><a href="#5-4-2-简易VPN" class="headerlink" title="5.4.2 简易VPN"></a>5.4.2 简易VPN</h4><p>VPN用来在外网与内网之间建立一条加密通道。内网的服务器不能从外网直接访问，必须通过一个跳板机，如果本机可以访问跳板机，就可以使用SSH本地转发，简单实现一个VPN。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L 2080:corp-server:80 -L 2443:corp-server:443 tunnel-host -N</code></pre></div><p>上面命令通过SSH跳板机，将本机的<code>2080</code>端口绑定内网服务器的<code>80</code>端口，本机的<code>2443</code>端口绑定内网服务器的<code>443</code>端口。</p><h4 id="5-4-3-两级跳板"><a href="#5-4-3-两级跳板" class="headerlink" title="5.4.3 两级跳板"></a>5.4.3 两级跳板</h4><p>端口转发可以有多级，比如新建两个SSH隧道，第一个隧道转发给第二个隧道，第二个隧道才能访问目标服务器。</p><p>首先，在本机新建第一级隧道。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L 7999:localhost:2999 tunnel1-host</code></pre></div><p>上面命令在本地<code>7999</code>端口与<code>tunnel1-host</code>之间建立一条隧道，隧道的出口是<code>tunnel1-host</code>的<code>localhost:2999</code>，也就是<code>tunnel1-host</code>收到本机的请求以后，转发给自己的<code>2999</code>端口。</p><p>然后，在第一台跳板机(<code>tunnel1-host</code>)执行下面的命令，新建第二级隧道。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$SSH</span>-L 2999:target-host:7999 tunnel2-host -N</code></pre></div><p>上面命令将第一台跳板机<code>tunnel1-host</code>的<code>2999</code>端口，通过第二台跳板机<code>tunnel2-host</code>，连接到目标服务器<code>target-host</code>的<code>7999</code>端口。</p><p>最终效果就是，访问本机的<code>7999</code>端口，就会转发到<code>target-host</code>的<code>7999</code>端口。</p><h2 id="6-rsync命令"><a href="#6-rsync命令" class="headerlink" title="6 rsync命令"></a>6 rsync命令</h2><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h3><p>rsync是一个常用的Linux应用程序，用于文件同步。</p><p>它可以在本地计算机与远程计算机之间，或者两个本地目录之间同步文件(但不支持两台远程计算机之间的同步)。它也可以当作文件复制工具，替代<code>cp</code>和<code>mv</code>命令。</p><p>它名称里面的<code>r</code>指的是remote，rsync其实就是“远程同步”(remote sync)的意思。与其他文件传输工具(如FTP或scp)不同，rsync的最大特点是会检查发送方和接收方已有的文件，仅传输<strong>有变动</strong>的部分(默认规则是文件大小或修改时间有变动)。</p><p>虽然rsync不是SSH工具集的一部分，但因为也涉及到远程操作，所以放在这里一起介绍。</p><h3 id="6-2-安装"><a href="#6-2-安装" class="headerlink" title="6.2 安装"></a>6.2 安装</h3><p>如果本机或者远程计算机没有安装rsync，可以用下面的命令安装。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Debian</span>$ sudo apt-get install rsync<span class="hljs-comment"># Red Hat</span>$ sudo yum install rsync<span class="hljs-comment"># Arch Linux</span>$ sudo pacman -S rsync</code></pre></div><p>注意，传输的双方都必须安装rsync。</p><h3 id="6-3-基本用法"><a href="#6-3-基本用法" class="headerlink" title="6.3 基本用法"></a>6.3 基本用法</h3><p>rsync可以用于本地计算机的两个目录之间的同步。下面就用本地同步举例，顺便讲解rsync几个主要参数的用法。</p><ul><li><p><code>-r</code><br>  本机使用rsync命令时，可以作为<code>cp</code>和<code>mv</code>命令的替代方法，将源目录拷贝到目标目录。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -r <span class="hljs-built_in">source</span> destination</code></pre></div><p>  上面命令中，<code>-r</code>表示递归，即包含子目录。注意，<code>-r</code>是必须的，否则rsync运行不会成功。<code>source</code>目录表示源目录，<code>destination</code>表示目标目录。上面命令执行以后，目标目录下就会出现<code>destination/source</code>这个子目录。</p><p>  如果有多个文件或目录需要同步，可以写成下面这样。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -r source1 source2 destination</code></pre></div><p>  上面命令中，<code>source1</code>、<code>source2</code>都会被同步到<code>destination</code>目录。</p></li><li><p><code>-a</code><br>  <code>-a</code>参数可以替代<code>-r</code>，除了可以递归同步以外，还可以同步元信息(比如修改时间、权限等)。由于rsync默认使用文件大小和修改时间决定文件是否需要更新，所以<code>-a</code>比<code>-r</code>更有用。下面的用法才是常见的写法。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -a <span class="hljs-built_in">source</span> destination</code></pre></div><p>  目标目录<code>destination</code>如果不存在，rsync 会自动创建。执行上面的命令后，源目录<code>source</code>被完整地复制到了目标目录<code>destination</code>下面，即形成了<code>destination/source</code>的目录结构。</p><p>  如果只想同步源目录<code>source</code>里面的内容到目标目录<code>destination</code>，则需要在源目录后面加上斜杠。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -a <span class="hljs-built_in">source</span> destination</code></pre></div><p>  上面命令执行后，<code>source</code>目录里面的内容，就都被复制到了<code>destination</code>目录里面，并不会在<code>destination</code>下面创建一个<code>source</code>子目录。</p></li><li><p><code>-n</code><br>  如果不确定rsync执行后会产生什么结果，可以先用<code>-n</code>或<code>--dry-run</code>参数模拟执行的结果。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -anv <span class="hljs-built_in">source</span> destination</code></pre></div><p>  上面命令中，<code>-n</code>参数模拟命令执行的结果，并不真的执行命令。<code>-v</code>参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。</p></li><li><p><code>--delete</code><br>  默认情况下，rsync只确保源目录的所有内容(明确排除的文件除外)都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用<code>--delete</code>参数，这将删除只存在于目标目录、不存在于源目录的文件。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av --delete <span class="hljs-built_in">source</span> destination</code></pre></div><p>  上面命令中，<code>--delete</code>参数会使得<code>destination</code>成为<code>source</code>的一个镜像。</p></li></ul><h3 id="6-4-排除文件"><a href="#6-4-排除文件" class="headerlink" title="6.4 排除文件"></a>6.4 排除文件</h3><ul><li><p><code>--exclude</code><br>  有时，我们希望同步时排除某些文件或目录，这时可以用<code>--exclude</code>参数指定排除模式。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av --exclude=<span class="hljs-string">&#x27;*.txt&#x27;</span> <span class="hljs-built_in">source</span>/ destination<span class="hljs-comment"># 或者</span>$ rsync -av --exclude <span class="hljs-string">&#x27;*.txt&#x27;</span> <span class="hljs-built_in">source</span>/ destination</code></pre></div><p>  上面命令排除了所有TXT文件。</p><p>  注意，rsync会同步以“点”开头的隐藏文件，如果要排除隐藏文件，可以这样写<code>--exclude=&quot;.*&quot;</code>。</p><p>  如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av --exclude <span class="hljs-string">&#x27;dir1/*&#x27;</span> <span class="hljs-built_in">source</span>/ destination</code></pre></div><p>  多个排除模式，可以用多个<code>--exclude</code>参数。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av --exclude <span class="hljs-string">&#x27;file1.txt&#x27;</span> --exclude <span class="hljs-string">&#x27;dir1/*&#x27;</span> <span class="hljs-built_in">source</span>/ destination</code></pre></div><p>  多个排除模式也可以利用Bash的大扩号的扩展功能，只用一个<code>--exclude</code>参数。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av --exclude=&#123;<span class="hljs-string">&#x27;file1.txt&#x27;</span>,<span class="hljs-string">&#x27;dir1/*&#x27;</span>&#125; <span class="hljs-built_in">source</span>/ destination</code></pre></div><p>  如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用<code>--exclude-from</code>参数指定这个文件。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av --exclude-from=<span class="hljs-string">&#x27;exclude-file.txt&#x27;</span> <span class="hljs-built_in">source</span>/ destination</code></pre></div></li><li><p><code>--include</code><br>  <code>--include</code>参数用来指定必须同步的文件模式，往往与<code>--exclude</code>结合使用。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av --include=<span class="hljs-string">&quot;*.txt&quot;</span> --exclude=<span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">source</span>/ destination</code></pre></div><p>  上面命令指定同步时，排除所有文件，但是会包括TXT文件。</p></li></ul><h3 id="6-5-远程同步"><a href="#6-5-远程同步" class="headerlink" title="6.5 远程同步"></a>6.5 远程同步</h3><h4 id="6-5-1-SSH协议"><a href="#6-5-1-SSH协议" class="headerlink" title="6.5.1 SSH协议"></a>6.5.1 SSH协议</h4><p>rsync除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av <span class="hljs-built_in">source</span>/ username@remote_host:destination</code></pre></div><p>也可以将远程内容同步到本地。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av username@remote_host:<span class="hljs-built_in">source</span>/ destination</code></pre></div><p>rsync默认使用SSH进行远程登录和数据传输。</p><p>由于早期rsync不使用SSH协议，需要用<code>-e</code>参数指定协议，后来才改的。所以，下面<code>-e ssh</code>可以省略。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av -e ssh <span class="hljs-built_in">source</span>/ user@remote_host:/destination</code></pre></div><p>但是，如果ssh命令有附加的参数，则必须使用<code>-e</code>参数指定所要执行的 SSH 命令。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av -e <span class="hljs-string">&#x27;ssh -p 2234&#x27;</span> <span class="hljs-built_in">source</span>/ user@remote_host:/destination</code></pre></div><p>上面命令中，<code>-e</code>参数指定SSH使用2234端口。</p><h4 id="6-5-2-rsync协议"><a href="#6-5-2-rsync协议" class="headerlink" title="6.5.2 rsync协议"></a>6.5.2 rsync协议</h4><p>除了使用SSH，如果另一台服务器安装并运行了rsync守护程序，则也可以用<code>rsync://</code>协议(默认端口<code>873</code>)进行传输。具体写法是服务器与目标目录之间使用双冒号分隔<code>::</code>。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av <span class="hljs-built_in">source</span>/ 192.168.122.32::module/destination</code></pre></div><p>注意，上面地址中的<code>module</code>并不是实际路径名，而是rsync守护程序指定的一个资源名，由管理员分配。</p><p>如果想知道rsync守护程序分配的所有module列表，可以执行下面命令。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync rsync://192.168.122.32</code></pre></div><p>rsync协议除了使用双冒号，也可以直接用<code>rsync://</code>协议指定地址。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync -av <span class="hljs-built_in">source</span>/ rsync://192.168.122.32/module/destination</code></pre></div><h3 id="6-6-增量备份"><a href="#6-6-增量备份" class="headerlink" title="6.6 增量备份"></a>6.6 增量备份</h3><p>rsync的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。</p><p>除了源目录与目标目录直接比较，rsync还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。</p><p>具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。</p><p><code>--link-dest</code>参数用来指定同步时的基准目录。</p><div class="code-wrapper"><pre><code class="hljs bash">$ rsync -a --delete --link-dest /compare/path /source/path /target/path</code></pre></div><p>上面命令中，<code>--link-dest</code>参数指定基准目录<code>/compare/path</code>，然后源目录<code>/source/path</code>跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录<code>/target/path</code>。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了。</p><p>下面是一个脚本示例，备份用户的主目录。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># A script to perform incremental backups using rsync</span><span class="hljs-built_in">set</span> -o errexit<span class="hljs-built_in">set</span> -o nounset<span class="hljs-built_in">set</span> -o pipefail<span class="hljs-built_in">readonly</span> SOURCE_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOME&#125;</span>&quot;</span><span class="hljs-built_in">readonly</span> BACKUP_DIR=<span class="hljs-string">&quot;/mnt/data/backups&quot;</span><span class="hljs-built_in">readonly</span> DATETIME=<span class="hljs-string">&quot;<span class="hljs-subst">$(date &#x27;+%Y-%m-%d_%H:%M:%S&#x27;)</span>&quot;</span><span class="hljs-built_in">readonly</span> BACKUP_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span><span class="hljs-built_in">readonly</span> LATEST_LINK=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>/latest&quot;</span><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>&quot;</span>rsync -av --delete \  <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>/&quot;</span> \  --link-dest <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span> \  --exclude=<span class="hljs-string">&quot;.cache&quot;</span> \  <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_PATH&#125;</span>&quot;</span><span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span><span class="hljs-built_in">ln</span> -s <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_PATH&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span></code></pre></div><p>上面脚本中，每一次同步都会生成一个新目录<code>$&#123;BACKUP_DIR&#125;/$&#123;DATETIME&#125;</code>，并将软链接<code>$&#123;BACKUP_DIR&#125;/latest</code>指向这个目录。下一次备份时，就将<code>$&#123;BACKUP_DIR&#125;/latest</code>作为基准目录，生成新的备份目录。最后，再将软链接<code>$&#123;BACKUP_DIR&#125;/latest</code>指向新的备份目录。</p><h3 id="6-7-配置项"><a href="#6-7-配置项" class="headerlink" title="6.7 配置项"></a>6.7 配置项</h3><p><code>-a</code>、<code>--archive</code>参数表示存档模式，保存所有的元数据，比如修改时间(modification time)、权限、所有者等，并且软链接也会同步过去。</p><p><code>--append</code>参数指定文件接着上次中断的地方，继续传输。</p><p><code>--append-verify</code>参数跟<code>--append</code>参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。</p><p><code>-b</code>、<code>--backup</code>参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由<code>--suffix</code>参数指定的文件后缀名，默认是<code>~</code>。</p><p><code>--backup-dir</code>参数指定文件备份时存放的目录，比如<code>--backup-dir=/path/to/backups</code>。</p><p><code>--bwlimit</code>参数指定带宽限制，默认单位是 KB&#x2F;s，比如<code>--bwlimit=100</code>。</p><p><code>-c</code>、<code>--checksum</code>参数改变<code>rsync</code>的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。</p><p><code>--delete</code>参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。</p><p><code>-e</code>参数指定使用 SSH 协议传输数据。</p><p><code>--exclude</code>参数指定排除不进行同步的文件，比如<code>--exclude=&quot;*.iso&quot;</code>。</p><p><code>--exclude-from</code>参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。</p><p><code>--existing</code>、<code>--ignore-non-existing</code>参数表示不同步目标目录中不存在的文件和目录。</p><p><code>-h</code>参数表示以人类可读的格式输出。</p><p><code>-h</code>、<code>--help</code>参数返回帮助信息。</p><p><code>-i</code>参数表示输出源目录与目标目录之间文件差异的详细情况。</p><p><code>--ignore-existing</code>参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。</p><p><code>--include</code>参数指定同步时要包括的文件，一般与<code>--exclude</code>结合使用。</p><p><code>--link-dest</code>参数指定增量备份的基准目录。</p><p><code>-m</code>参数指定不同步空目录。</p><p><code>--max-size</code>参数设置传输的最大文件的大小限制，比如不超过200KB(<code>--max-size=&#39;200k&#39;</code>)。</p><p><code>--min-size</code>参数设置传输的最小文件的大小限制，比如不小于10KB(<code>--min-size=10k</code>)。</p><p><code>-n</code>参数或<code>--dry-run</code>参数模拟将要执行的操作，而并不真的执行。配合<code>-v</code>参数使用，可以看到哪些内容会被同步过去。</p><p><code>-P</code>参数是<code>--progress</code>和<code>--partial</code>这两个参数的结合。</p><p><code>--partial</code>参数允许恢复中断的传输。不使用该参数时，<code>rsync</code>会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与<code>--append</code>或<code>--append-verify</code>配合使用。</p><p><code>--partial-dir</code>参数指定将传输到一半的文件保存到一个临时目录，比如<code>--partial-dir=.rsync-partial</code>。一般需要与<code>--append</code>或<code>--append-verify</code>配合使用。</p><p><code>--progress</code>参数表示显示进展。</p><p><code>-r</code>参数表示递归，即包含子目录。</p><p><code>--remove-source-files</code>参数表示传输成功后，删除发送方的文件。</p><p><code>--size-only</code>参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。</p><p><code>--suffix</code>参数指定文件名备份时，对文件名添加的后缀，默认是<code>~</code>。</p><p><code>-u</code>、<code>--update</code>参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。</p><p><code>-v</code>参数表示输出细节。<code>-vv</code>表示输出更详细的信息，<code>-vvv</code>表示输出最详细的信息。</p><p><code>--version</code>参数返回 rsync 的版本。</p><p><code>-z</code>参数指定同步时压缩数据。</p><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories-on-a-vps">How To Use Rsync to Sync Local and Remote Directories on a VPS</a>, Justin Ellingwood</li><li><a href="https://www.howtoforge.com/mirroring_with_rsync">Mirror Your Web Site With rsync</a>, Falko Timme</li><li><a href="https://linuxconfig.org/examples-on-how-to-use-rsync-for-local-and-remote-data-backups-and-synchonization">Examples on how to use Rsync</a>, Egidio Docile</li><li><a href="https://linuxconfig.org/how-to-create-incremental-backups-using-rsync-on-linux">How to create incremental backups using rsync on Linux</a>, Egidio Docile</li></ul><h2 id="7-scp命令"><a href="#7-scp命令" class="headerlink" title="7 scp命令"></a>7 scp命令</h2><p><code>scp</code>是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件(即复制文件)。</p><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h3><p><code>scp</code>是secure copy的缩写，相当于<code>cp</code>命令+SSH。它的底层是SSH协议，默认端口是<code>22</code>，相当于先使用<code>ssh</code>命令登录远程主机，然后再执行拷贝操作。</p><p><code>scp</code>主要用于以下三种复制操作。</p><ul><li>本地复制到远程。</li><li>远程复制到本地。</li><li>两个远程系统之间的复制。</li></ul><p>使用<code>scp</code>传输数据时，文件和密码都是加密的，不会泄漏敏感信息。</p><h3 id="7-2-基本语法"><a href="#7-2-基本语法" class="headerlink" title="7.2 基本语法"></a>7.2 基本语法</h3><p><code>scp</code>的语法类似<code>cp</code>的语法。</p><div class="code-wrapper"><pre><code class="hljs bash">$ scp <span class="hljs-built_in">source</span> destination</code></pre></div><p>上面命令中，<code>source</code>是文件当前的位置，<code>destination</code>是文件所要复制到的位置。它们都可以包含用户名和主机名。</p><div class="code-wrapper"><pre><code class="hljs bash">$ scp user@host:foo.txt bar.txt</code></pre></div><p>上面命令将远程主机(<code>user@host</code>)用户主目录下的<code>foo.txt</code>，复制为本机当前目录的<code>bar.txt</code>。可以看到，主机与文件之间要使用冒号(<code>:</code>)分隔。</p><p><code>scp</code>会先用SSH登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码，这部分是跟SSH的用法一致的。</p><p>用户名和主机名都是可以省略的。用户名的默认值是本机的当前用户名，主机名默认为当前主机。注意，<code>scp</code>会使用SSH客户端的配置文件<code>.ssh/config</code>，如果配置文件里面定义了主机的别名，这里也可以使用别名连接。</p><p><code>scp</code>支持一次复制多个文件。</p><div class="code-wrapper"><pre><code class="hljs bash">$ scp source1 source2 destination</code></pre></div><p>上面命令会将<code>source1</code>和<code>source2</code>两个文件，复制到<code>destination</code>。</p><p>注意，如果所要复制的文件，在目标位置已经存在同名文件，<code>scp</code>会在没有警告的情况下覆盖同名文件。</p><h3 id="7-3-用法示例"><a href="#7-3-用法示例" class="headerlink" title="7.3 用法示例"></a>7.3 用法示例</h3><ul><li><p>本地文件复制到远程</p><p>  复制本机文件到远程系统的用法如下。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 语法</span>$ scp SourceFile user@host:directory/TargetFile<span class="hljs-comment"># 示例</span>$ scp file.txt remote_username@10.10.0.2:/remote/directory</code></pre></div><p>  下面是复制整个目录的例子。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将本机的 documents 目录拷贝到远程主机，</span><span class="hljs-comment"># 会在远程主机创建 documents 目录</span>$ scp -r documents username@server_ip:/path_to_remote_directory<span class="hljs-comment"># 将本机整个目录拷贝到远程目录下</span>$ scp -r localmachine/path_to_the_directory username@server_ip:/path_to_remote_directory/<span class="hljs-comment"># 将本机目录下的所有内容拷贝到远程目录下</span>$ scp -r localmachine/path_to_the_directory/* username@server_ip:/path_to_remote_directory/</code></pre></div></li><li><p>远程文件复制到本地</p><p>  从远程主机复制文件到本地的用法如下。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 语法</span>$ scp user@host:directory/SourceFile TargetFile<span class="hljs-comment"># 示例</span>$ scp remote_username@10.10.0.2:/remote/file.txt /local/directory</code></pre></div><p>  下面是复制整个目录的例子。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 拷贝一个远程目录到本机目录下</span>$ scp -r username@server_ip:/path_to_remote_directory local-machine/path_to_the_directory/<span class="hljs-comment"># 拷贝远程目录下的所有内容，到本机目录下</span>$ scp -r username@server_ip:/path_to_remote_directory/* local-machine/path_to_the_directory/$ scp -r user@host:directory/SourceFolder TargetFolder</code></pre></div></li><li><p>两个远程系统之间的复制</p><p>  本机发出指令，从远程主机 A 拷贝到远程主机 B 的用法如下。</p>  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 语法</span>$ scp user@host1:directory/SourceFile user@host2:directory/SourceFile<span class="hljs-comment"># 示例</span>$ scp user1@host1.com:/files/file.txt user2@host2.com:/files</code></pre></div><p>  系统将提示你输入两个远程帐户的密码。数据将直接从一个远程主机传输到另一个远程主机。</p></li></ul><h3 id="7-4-配置项"><a href="#7-4-配置项" class="headerlink" title="7.4 配置项"></a>7.4 配置项</h3><ul><li><p><code>-c</code></p><p>  <code>-c</code>参数用来指定文件拷贝数据传输的加密算法。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -c blowfish some_file your_username@remotehost.edu:~</code></pre></div><p>  上面代码指定加密算法为<code>blowfish</code>。</p></li><li><p><code>-C</code></p><p>  <code>-C</code>参数表示是否在传输时压缩文件。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -c blowfish -C local_file your_username@remotehost.edu:~</code></pre></div></li><li><p><code>-F</code></p><p>  <code>-F</code>参数用来指定ssh_config文件，供ssh使用。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -F /home/pungki/proxy_ssh_config Label.pdf root@172.20.10.8:/root</code></pre></div></li><li><p><code>-i</code></p><p>  <code>-i</code>参数用来指定密钥。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -vCq -i private_key.pem ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre></div></li><li><p><code>-l</code></p><p>  <code>-l</code>参数用来限制传输数据的带宽速率，单位是<code>Kbit/sec</code>。对于多人分享的带宽，这个参数可以留出一部分带宽供其他人使用。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -l 80 yourusername@yourserver:/home/yourusername/* .</code></pre></div><p>  上面代码中，<code>scp</code>命令占用的带宽限制为每秒80K比特位，即每秒10K字节。</p></li><li><p><code>-p</code></p><p>  <code>-p</code>参数用来保留修改时间(modification time)、访问时间(access time)、文件状态(mode)等原始文件的信息。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -p ~/test.txt root@192.168.1.3:/some/path/test.txt</code></pre></div></li><li><p><code>-P</code></p><p>  <code>-P</code>参数用来指定远程主机的SSH端口。如果远程主机使用默认端口<code>22</code>，可以不用指定，否则需要用<code>-P</code>参数在命令中指定。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -P 2222 user@host:directory/SourceFile TargetFile</code></pre></div></li><li><p><code>-q</code></p><p>  <code>-q</code>参数用来关闭显示拷贝的进度条。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -q Label.pdf mrarianto@202.x.x.x:.</code></pre></div></li><li><p><code>-r</code></p><p>  <code>-r</code>参数表示是否以递归方式复制目录。</p></li><li><p><code>-v</code></p><p>  <code>-v</code>参数用来显示详细的输出。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ scp -v ~/test.txt root@192.168.1.3:/root/help2356.txt</code></pre></div></li></ul><h2 id="8-SSH服务器"><a href="#8-SSH服务器" class="headerlink" title="8 SSH服务器"></a>8 SSH服务器</h2><h3 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h3><p>SSH的架构是服务器&#x2F;客户端模式，两端运行的软件是不一样的。OpenSSH的客户端软件是ssh，服务器软件是sshd。本章介绍sshd的各种知识。</p><p>如果没有安装sshd，可以用下面的命令安装。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Debian</span>$ sudo aptitude install openssh-server<span class="hljs-comment"># Red Hat</span>$ sudo yum install openssh-server</code></pre></div><p>一般来说，sshd安装后会跟着系统一起启动。如果当前sshd没有启动，可以用下面的命令启动。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sshd</code></pre></div><p>上面的命令运行后，如果提示“sshd re-exec requires execution with an absolute path”，就需要使用绝对路径来启动。这是为了防止有人出于各种目的，放置同名软件在<code>$PATH</code>变量指向的目录中，代替真正的 sshd。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Centos、Ubuntu、OS X</span>$ /usr/sbin/sshd</code></pre></div><p>上面的命令运行以后，sshd自动进入后台，所以命令后面不需要加上<code>&amp;</code>。</p><p>除了直接运行可执行文件，也可以通过Systemd启动sshd。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span>$ sudo systemctl start sshd.service<span class="hljs-comment"># 停止</span>$ sudo systemctl stop sshd.service<span class="hljs-comment"># 重启</span>$ sudo systemctl restart sshd.service</code></pre></div><p>下面的命令让sshd 在计算机下次启动时自动运行。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo systemctl <span class="hljs-built_in">enable</span> sshd.service</code></pre></div><h3 id="8-2-sshd配置文件"><a href="#8-2-sshd配置文件" class="headerlink" title="8.2 sshd配置文件"></a>8.2 sshd配置文件</h3><p>sshd 的配置文件在<code>/etc/ssh</code>目录，主配置文件是<code>sshd_config</code>，此外还有一些安装时生成的密钥。</p><ul><li><code>/etc/ssh/sshd_config</code>：配置文件</li><li><code>/etc/ssh/ssh_host_ecdsa_key</code>：ECDSA 私钥。</li><li><code>/etc/ssh/ssh_host_ecdsa_key.pub</code>：ECDSA 公钥。</li><li><code>/etc/ssh/ssh_host_key</code>：用于 SSH 1 协议版本的 RSA 私钥。</li><li><code>/etc/ssh/ssh_host_key.pub</code>：用于 SSH 1 协议版本的 RSA 公钥。</li><li><code>/etc/ssh/ssh_host_rsa_key</code>：用于 SSH 2 协议版本的 RSA 私钥。</li><li><code>/etc/ssh/ssh_host_rsa_key.pub</code>：用于 SSH 2 协议版本的 RSA 公钥。</li><li><code>/etc/pam.d/sshd</code>：PAM 配置文件。</li></ul><p>注意，如果重装sshd，上面这些密钥都会重新生成，导致客户端重新连接ssh服务器时，会跳出警告，拒绝连接。为了避免这种情况，可以在重装sshd时，先备份<code>/etc/ssh</code>目录，重装后再恢复这个目录。</p><p>配置文件<code>sshd_config</code>的格式是，每个命令占据一行。每行都是配置项和对应的值，配置项的大小写不敏感，与值之间使用空格分隔。</p><div class="code-wrapper"><pre><code class="hljs bash">Port 2034</code></pre></div><p>上面的配置命令指定，配置项<code>Port</code>的值是<code>2034</code>。<code>Port</code>写成<code>port</code>也可。</p><p>配置文件还有另一种格式，就是配置项与值之间有一个等号，等号前后的空格可选。</p><div class="code-wrapper"><pre><code class="hljs bash">Port = 2034</code></pre></div><p>配置文件里面，<code>#</code>开头的行表示注释。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 这是一行注释</span></code></pre></div><p>注意，注释只能放在一行的开头，不能放在一行的结尾。</p><div class="code-wrapper"><pre><code class="hljs bash">Port 2034 <span class="hljs-comment"># 此处不允许注释</span></code></pre></div><p>上面的写法是错误的。</p><p>另外，空行等同于注释。</p><p>sshd 启动时会自动读取默认的配置文件。如果希望使用其他的配置文件，可以用 sshd 命令的<code>-f</code>参数指定。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sshd -f /usr/local/ssh/my_config</code></pre></div><p>上面的命令指定 sshd 使用另一个配置文件<code>my_config</code>。</p><p>修改配置文件以后，可以用 sshd 命令的<code>-t</code>(test)检查有没有语法错误。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sshd -t</code></pre></div><p>配置文件修改以后，并不会自动生效，必须重新启动 sshd。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo systemctl restart sshd.service</code></pre></div><h3 id="8-3-sshd密钥"><a href="#8-3-sshd密钥" class="headerlink" title="8.3 sshd密钥"></a>8.3 sshd密钥</h3><p>sshd有自己的一对或多对密钥。它使用密钥向客户端证明自己的身份。所有密钥都是公钥和私钥成对出现，公钥的文件名一般是私钥文件名加上后缀<code>.pub</code>。</p><p>DSA 格式的密钥文件默认为<code>/etc/ssh/ssh_host_dsa_key</code>(公钥为<code>ssh_host_dsa_key.pub</code>)，RSA 格式的密钥为<code>/etc/ssh/ssh_host_rsa_key</code>(公钥为<code>ssh_host_rsa_key.pub</code>)。如果需要支持 SSH 1 协议，则必须有密钥<code>/etc/ssh/ssh_host_key</code>。</p><p>如果密钥不是默认文件，那么可以通过配置文件<code>sshd_config</code>的<code>HostKey</code>配置项指定。默认密钥的<code>HostKey</code>设置如下。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># HostKey for protocol version 1</span><span class="hljs-comment"># HostKey /etc/ssh/ssh_host_key</span><span class="hljs-comment"># HostKeys for protocol version 2</span><span class="hljs-comment"># HostKey /etc/ssh/ssh_host_rsa_key</span><span class="hljs-comment"># HostKey /etc/ssh/ssh_host_dsa_ke</span></code></pre></div><p>上面命令前面的<code>#</code>表示这些行都是注释，因为这是默认值，有没有这几行都一样。</p><p>如果要修改密钥，就要去掉行首的<code>#</code>，指定其他密钥。</p><div class="code-wrapper"><pre><code class="hljs bash">HostKey /usr/local/ssh/my_dsa_keyHostKey /usr/local/ssh/my_rsa_keyHostKey /usr/local/ssh/my_old_ssh1_key</code></pre></div><h3 id="8-4-sshd配置项"><a href="#8-4-sshd配置项" class="headerlink" title="8.4 sshd配置项"></a>8.4 sshd配置项</h3><p>以下是<code>/etc/ssh/sshd_config</code>文件里面的配置项。</p><ul><li><p><code>AcceptEnv</code><br>  指定允许接受客户端通过<code>SendEnv</code>命令发来的哪些环境变量，即允许客户端设置服务器的环境变量清单，变量名之间使用空格分隔(<code>AcceptEnv PATH TERM</code>)。</p></li><li><p><code>AllowGroups</code><br>  指定允许登录的用户组(<code>AllowGroups groupName</code>，多个组之间用空格分隔。如果不使用该项，则允许所有用户组登录。</p></li><li><p><code>AllowUsers</code><br>  指定允许登录的用户，用户名之间使用空格分隔(<code>AllowUsers user1 user2</code>)，也可以使用多行<code>AllowUsers</code>命令指定，用户名支持使用通配符。如果不使用该项，则允许所有用户登录。该项也可以使用<code>用户名@域名</code>的格式(比如<code>AllowUsers jones@example.com</code>)。</p></li><li><p><code>AllowTcpForwarding</code><br>  指定是否允许端口转发，默认值为<code>yes</code>(<code>AllowTcpForwarding yes</code>)，<code>local</code>表示只允许本地端口转发，<code>remote</code>表示只允许远程端口转发。</p></li><li><p><code>AuthorizedKeysFile</code><br>  指定储存用户公钥的目录，默认是用户主目录的<code>ssh/authorized_keys</code>目录(<code>AuthorizedKeysFile .ssh/authorized_keys</code>)。</p></li><li><p><code>Banner</code><br>  指定用户登录后，sshd 向其展示的信息文件(<code>Banner /usr/local/etc/warning.txt</code>)，默认不展示任何内容。</p></li><li><p><code>ChallengeResponseAuthentication</code><br>  指定是否使用“键盘交互”身份验证方案，默认值为<code>yes</code>(<code>ChallengeResponseAuthentication yes</code>)。</p><p>  从理论上讲，“键盘交互”身份验证方案可以向用户询问多重问题，但是实践中，通常仅询问用户密码。如果要完全禁用基于密码的身份验证，请将<code>PasswordAuthentication</code>和<code>ChallengeResponseAuthentication</code>都设置为<code>no</code>。</p></li><li><p><code>Ciphers</code><br>  指定sshd可以接受的加密算法(<code>Ciphers 3des-cbc</code>)，多个算法之间使用逗号分隔。</p></li><li><p><code>ClientAliveCountMax</code><br>  指定建立连接后，客户端失去响应时，服务器尝试连接的次数(<code>ClientAliveCountMax 8</code>)。</p></li><li><p><code>ClientAliveInterval</code><br>  指定允许客户端发呆的时间，单位为秒(<code>ClientAliveInterval 180</code>)。如果这段时间里面，客户端没有发送任何信号，SSH连接将关闭。</p></li><li><p><code>Compression</code><br>  指定客户端与服务器之间的数据传输是否压缩。默认值为<code>yes</code>(<code>Compression yes</code>)</p></li><li><p><code>DenyGroups</code><br>  指定不允许登录的用户组(<code>DenyGroups groupName</code>)。</p></li><li><p><code>DenyUsers</code><br>  指定不允许登录的用户(<code>DenyUsers user1</code>)，用户名之间使用空格分隔，也可以使用多行<code>DenyUsers</code>命令指定。</p></li><li><p><code>FascistLogging</code><br>  SSH 1 版本专用，指定日志输出全部 Debug 信息(<code>FascistLogging yes</code>)。</p></li><li><p><code>HostKey</code><br>  指定sshd服务器的密钥，详见前文。</p></li><li><p><code>KeyRegenerationInterval</code><br>  指定 SSH 1 版本的密钥重新生成时间间隔，单位为秒，默认是3600秒(<code>KeyRegenerationInterval 3600</code>)。</p></li><li><p><code>ListenAddress</code><br>  指定 sshd 监听的本机 IP 地址，即 sshd 启用的 IP 地址，默认是 0.0.0.0(<code>ListenAddress 0.0.0.0</code>)表示在本机所有网络接口启用。可以改成只在某个网络接口启用(比如<code>ListenAddress 192.168.10.23</code>)，也可以指定某个域名启用(比如<code>ListenAddress server.example.com</code>)。</p><p>  如果要监听多个指定的IP地址，可以使用多行<code>ListenAddress</code>命令。</p>  <div class="code-wrapper"><pre><code class="hljs bash">ListenAddress 172.16.1.1ListenAddress 192.168.0.1</code></pre></div></li><li><p><code>LoginGraceTime</code><br>  指定允许客户端登录时发呆的最长时间，比如用户迟迟不输入密码，连接就会自动断开，单位为秒(<code>LoginGraceTime 60</code>)。如果设为<code>0</code>，就表示没有限制。</p></li><li><p><code>LogLevel</code><br>  指定日志的详细程度，可能的值依次为<code>QUIET</code>、<code>FATAL</code>、<code>ERROR</code>、<code>INFO</code>、<code>VERBOSE</code>、<code>DEBUG</code>、<code>DEBUG1</code>、<code>DEBUG2</code>、<code>DEBUG3</code>，默认为<code>INFO</code>(<code>LogLevel INFO</code>)。</p></li><li><p><code>MACs</code><br>  指定sshd可以接受的数据校验算法(<code>MACs hmac-sha1</code>)，多个算法之间使用逗号分隔。</p></li><li><p><code>MaxAuthTries</code><br>  指定允许 SSH 登录的最大尝试次数(<code>MaxAuthTries 3</code>)，如果密码输入错误达到指定次数，SSH 连接将关闭。</p></li><li><p><code>MaxStartups</code><br>  指定允许同时并发的 SSH 连接数量(MaxStartups)。如果设为<code>0</code>，就表示没有限制。</p><p>  这个属性也可以设为<code>A:B:C</code>的形式，比如<code>MaxStartups 10:50:20</code>，表示如果达到10个并发连接，后面的连接将有50%的概率被拒绝；如果达到20个并发连接，则后面的连接将100%被拒绝。</p></li><li><p><code>PasswordAuthentication</code><br>  指定是否允许密码登录，默认值为<code>yes</code>(<code>PasswordAuthentication yes</code>)，建议改成<code>no</code>(禁止密码登录，只允许密钥登录)。</p></li><li><p><code>PermitEmptyPasswords</code><br>  指定是否允许空密码登录，即用户的密码是否可以为空，默认为<code>yes</code>(<code>PermitEmptyPasswords yes</code>)，建议改成<code>no</code>(禁止无密码登录)。</p></li><li><p><code>PermitRootLogin</code><br>  指定是否允许根用户登录，默认为<code>yes</code>(<code>PermitRootLogin yes</code>)，建议改成<code>no</code>(禁止根用户登录)。</p><p>  还有一种写法是写成<code>prohibit-password</code>，表示 root 用户不能用密码登录，但是可以用密钥登录。</p>  <div class="code-wrapper"><pre><code class="hljs bash">PermitRootLogin prohibit-password</code></pre></div></li><li><p><code>PermitUserEnvironment</code><br>  指定是否允许 sshd 加载客户端的<code>~/.ssh/environment</code>文件和<code>~/.ssh/authorized_keys</code>文件里面的<code>environment= options</code>环境变量设置。默认值为<code>no</code>(<code>PermitUserEnvironment no</code>)。</p></li><li><p><code>Port</code><br>  指定 sshd 监听的端口，即客户端连接的端口，默认是22(<code>Port 22</code>)。出于安全考虑，可以改掉这个端口(比如<code>Port 8822</code>)。</p><p>  配置文件可以使用多个<code>Port</code>命令，同时监听多个端口。</p>  <div class="code-wrapper"><pre><code class="hljs bash">Port 22Port 80Port 443Port 8080</code></pre></div><p>  上面的示例表示同时监听4个端口。</p></li><li><p><code>PrintMotd</code><br>  指定用户登录后，是否向其展示系统的 motd(Message of the day)的信息文件<code>/etc/motd</code>。该文件用于通知所有用户一些重要事项，比如系统维护时间、安全问题等等。默认值为<code>yes</code>(<code>PrintMotd yes</code>)，由于 Shell 一般会展示这个信息文件，所以这里可以改为<code>no</code>。</p></li><li><p><code>PrintLastLog</code><br>  指定是否打印上一次用户登录时间，默认值为<code>yes</code>(<code>PrintLastLog yes</code>)。</p></li><li><p><code>Protocol</code><br>  指定sshd使用的协议。<code>Protocol 1</code>表示使用SSH1协议，建议改成<code>Protocol 2</code>(使用SSH2协议)。<code>Protocol 2,1</code>表示同时支持两个版本的协议。</p></li><li><p><code>PubKeyAuthentication</code><br>  指定是否允许公钥登录，默认值为<code>yes</code>(<code>PubKeyAuthentication yes</code>)。</p></li><li><p><code>QuietMode</code><br>  SSH1版本专用，指定日志只输出致命的错误信息(<code>QuietMode yes</code>)。</p></li><li><p><code>RSAAuthentication</code><br>  指定允许 RSA 认证，默认值为<code>yes</code>(<code>RSAAuthentication yes</code>)。</p></li><li><p><code>ServerKeyBits</code><br>  指定 SSH 1 版本的密钥重新生成时的位数，默认是768(<code>ServerKeyBits 768</code>)。</p></li><li><p><code>StrictModes</code><br>  指定sshd是否检查用户的一些重要文件和目录的权限。默认为<code>yes</code>(<code>StrictModes yes</code>)，即对于用户的SSH配置文件、密钥文件和所在目录，SSH 要求拥有者必须是根用户或用户本人，用户组和其他人的写权限必须关闭。</p></li><li><p><code>SyslogFacility</code><br>  指定Syslog如何处理sshd的日志，默认是Auth(<code>SyslogFacility AUTH</code>)。</p></li><li><p><code>TCPKeepAlive</code><br>  指定打开sshd跟客户端TCP连接的keepalive参数(<code>TCPKeepAlive yes</code>)。</p></li><li><p><code>UseDNS</code><br>  指定用户SSH登录一个域名时，服务器是否使用DNS，确认该域名对应的IP地址包含本机(<code>UseDNS yes</code>)。打开该选项意义不大，而且如果DNS更新不及时，还有可能误判，建议关闭。</p></li><li><p><code>UseLogin</code><br>  指定用户认证内部是否使用<code>/usr/bin/login</code>替代SSH工具，默认为<code>no</code>(<code>UseLogin no</code>)。</p></li><li><p><code>UserPrivilegeSeparation</code><br>  指定用户认证通过以后，使用另一个子线程处理用户权限相关的操作，这样有利于提高安全性。默认值为<code>yes</code>(<code>UsePrivilegeSeparation yes</code>)。</p></li><li><p><code>VerboseMode</code><br>  SSH2版本专用，指定日志输出详细的Debug信息(<code>VerboseMode yes</code>)。</p></li><li><p><code>X11Forwarding</code><br>  指定是否打开X window的转发，默认值为no(<code>X11Forwarding no</code>)。</p></li></ul><p>修改配置文件以后，可以使用下面的命令验证，配置文件是否有语法错误。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sshd -t</code></pre></div><p>新的配置文件生效，必须重启 sshd。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sudo systemctl restart sshd</code></pre></div><h3 id="8-5-sshd的命令行配置项"><a href="#8-5-sshd的命令行配置项" class="headerlink" title="8.5 sshd的命令行配置项"></a>8.5 sshd的命令行配置项</h3><p>sshd 命令有一些配置项。这些配置项在调用时指定，可以覆盖配置文件的设置。</p><ul><li><p><code>-d</code><br>  <code>-d</code>参数用于显示 debug 信息。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -d</code></pre></div></li><li><p><code>-D</code><br>  <code>-D</code>参数指定 sshd 不作为后台守护进程运行。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -D</code></pre></div></li><li><p><code>-e</code><br>  <code>-e</code>参数将 sshd 写入系统日志 syslog 的内容导向标准错误(standard error)。</p></li><li><p><code>-f</code><br>  <code>-f</code>参数指定配置文件的位置。</p></li><li><p><code>-h</code><br>  <code>-h</code>参数用于指定密钥。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -h /usr/local/ssh/my_rsa_key</code></pre></div></li><li><p><code>-o</code><br>  <code>-o</code>参数指定配置文件的一个配置项和对应的值。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -o <span class="hljs-string">&quot;Port 2034&quot;</span></code></pre></div><p>  配置项和对应值之间，可以使用等号。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -o <span class="hljs-string">&quot;Port = 2034&quot;</span></code></pre></div><p>  如果省略等号前后的空格，也可以不使用引号。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -o Port=2034</code></pre></div><p>  <code>-o</code>参数可以多个一起使用，用来指定多个配置关键字。</p></li><li><p><code>-p</code><br>  <code>-p</code>参数指定 sshd 的服务端口。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -p 2034</code></pre></div><p>  上面命令指定 sshd 在<code>2034</code>端口启动。</p><p>  <code>-p</code>参数可以指定多个端口。</p>  <div class="code-wrapper"><pre><code class="hljs bash">$ sshd -p 2222 -p 3333</code></pre></div></li><li><p><code>-t</code><br>  <code>-t</code>参数检查配置文件的语法是否正确。</p></li></ul><h2 id="9-sftp命令"><a href="#9-sftp命令" class="headerlink" title="9 sftp命令"></a>9 sftp命令</h2><p><code>sftp</code>是SSH提供的一个客户端应用程序，主要用来安全地访问FTP。因为FTP是不加密协议，很不安全，<code>sftp</code>就相当于将FTP放入了SSH。</p><p>下面的命令连接FTP主机。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sftp username@hostname</code></pre></div><p>执行上面的命令，会要求输入FTP的密码。密码验证成功以后，就会出现FTP的提示符<code>sftp&gt;</code>，下面是一个例子。</p><div class="code-wrapper"><pre><code class="hljs bash">$ sftp USER@penguin.example.comUSER@penguin.example.com<span class="hljs-string">&#x27;s password:</span><span class="hljs-string">Connected to penguin.example.com.</span><span class="hljs-string">sftp&gt;</span></code></pre></div><p>FTP的提示符下面，就可以输入各种FTP命令了，这部分完全跟传统的FTP用法完全一样。</p><ul><li><code>ls [directory]</code>：列出一个远程目录的内容。如果没有指定目标目录，则默认列出当前目录。</li><li><code>cd directory</code>：从当前目录改到指定目录。</li><li><code>mkdir directory</code>：创建一个远程目录。</li><li><code>rmdir path</code>：删除一个远程目录。</li><li><code>put localfile [remotefile]</code>：本地文件传输到远程主机。</li><li><code>get remotefile [localfile]</code>：远程文件传输到本地。</li><li><code>help</code>：显示帮助信息。</li><li><code>bye</code>：退出sftp。</li><li><code>quit</code>：退出sftp。</li><li><code>exit</code>：退出sftp。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Technology Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
