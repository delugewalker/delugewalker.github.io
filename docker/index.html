

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/deluge.png">
  <link rel="icon" href="/img/deluge.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2b3f3d">
  <meta name="author" content="Deluge Walker">
  <meta name="keywords" content="">
  
    <meta name="description" content="Docker教程  1 概述 Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护，大概在2017年4月份左右Docker项目改名为Moby，可以在Github搜索Moby找到这个项目。 Docker的内核建立在LXC(Linux Contain">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="http://example.com/docker/index.html">
<meta property="og:site_name" content="覆舟之水">
<meta property="og:description" content="Docker教程  1 概述 Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护，大概在2017年4月份左右Docker项目改名为Moby，可以在Github搜索Moby找到这个项目。 Docker的内核建立在LXC(Linux Contain">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/articles/Docker.webp">
<meta property="article:published_time" content="2021-12-20T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-03T03:20:24.866Z">
<meta property="article:author" content="Deluge Walker">
<meta property="article:tag" content="Technology">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/articles/Docker.webp">
  
  
  <title>Docker - 覆舟之水</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>覆舟之水</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/articles/Docker.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Docker</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-12-21 00:00" pubdate>
          December 21, 2021 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          185 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Docker</h1>
            
            <div class="markdown-body">
              
              <h1 id="docker教程"><a class="markdownIt-Anchor" href="#docker教程"></a> Docker教程</h1>
<h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h2>
<p>Docker 是 Docker 公司的开源项目，使用 Google 公司推出的 Go 语言开发的，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护，大概在2017年4月份左右Docker项目改名为<a target="_blank" rel="noopener" href="https://github.com/moby/moby">Moby</a>，可以在Github搜索Moby找到这个项目。</p>
<p>Docker的内核建立在LXC(Linux Container)之上，作为容器的一种，同传统的虚拟机比起来，容器内的应用/进程直接运行在宿主机的内核上，容器没有自己的内核，所以容器更加轻量，运行效率也更高。同传统的虚拟机相比：Docker具有以下优点：</p>
<ul>
<li>更高效的资源利用</li>
<li>快速启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>轻松迁移</li>
<li>轻松维护和扩展</li>
</ul>
<h2 id="2-docker概念"><a class="markdownIt-Anchor" href="#2-docker概念"></a> 2 Docker概念</h2>
<ul>
<li><strong>镜像 Image</strong><br />
Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li>
<li><strong>容器 Container</strong><br />
Docker容器是Docker镜像的实例，镜像启动后可生成一个Docker实例，它可以被开始、停止、删除、每个容器都是互相隔离的，保证安全的平台，可以把容器看做是要给简易版的linux环境(包括root用户权限、镜像空间、用户空间和网络空间等)和运行在其中的应用程序当然也可以将Docker实例保存为一个镜像，供其他用户使用。</li>
<li><strong>仓库 Repository</strong><br />
Docker仓库是保存Docker镜像的地方，Docker的默认镜像仓库是在<code>hub.docker.com</code>，但用户只能在官网创建一个<code>private</code>项目，有些组织并不希望自己的镜像成为<code>public</code>项目(比如打包了云源码)，这时用户可以使用<code>registry</code>构建自己的仓库。</li>
</ul>
<h2 id="3-docker常用命令"><a class="markdownIt-Anchor" href="#3-docker常用命令"></a> 3 Docker常用命令</h2>
<h3 id="31-docker安装"><a class="markdownIt-Anchor" href="#31-docker安装"></a> 3.1 Docker安装</h3>
<h4 id="311-linux安装"><a class="markdownIt-Anchor" href="#311-linux安装"></a> 3.1.1 Linux安装</h4>
<p>接下来将基于<code>Ubuntu20.04</code>操作系统讲解Docker命令。</p>
<h5 id="3111-docker安装"><a class="markdownIt-Anchor" href="#3111-docker安装"></a> 3.1.1.1 Docker安装</h5>
<p><strong>第一种 安装<code>docker</code></strong></p>
<ul>
<li>
<p>安装docker</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo apt install docker</code></pre></div>
</li>
<li>
<p>安装nvidia-docker<br />
nvidia-docker是一个可以使用GPU的docker，它在docker上做了一层封装，通过nvidia-docker-plugin，然后调用到docker上，其最终实现的还是在docker的启动命令上携带一些必要的参数。因此在安装nvidia-docker之前，还是需要安装docker的。</p>
  <div style="text-align: center">
  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Nvidia-Docker.png" srcset="/img/loading.gif" lazyload alt="Nvidia Docker结构" width="60%">
  </div>
<p>docker一般都是使用基于CPU的应用，而如果是GPU的话，就需要安装特有的硬件环境，比如需要安装nvidia driver，所以docker容器并不直接支持Nvidia GPU。为了使docker image能很便利的使用Nvidia GPU，从而产生了nvidia-docker，由它来制作nvidia driver的image，这就要求在目标机器上启动container时，确保字符设备以及驱动文件已经被挂载。</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo apt install -y nvidia-docker2</code></pre></div>
</li>
</ul>
<p><strong>第二种 安装<code>docker.io</code>(推荐)</strong></p>
<p>Docker19版本更新了GPU驱动使用参数，下面介绍具体的安装方法。</p>
<ul>
<li>
<p><code>docker-ce</code>与<code>docker-io</code>的区别<br />
<code>docker-ce</code>是由docker团队认证并维护的一个社区版发行包，<code>docker.io</code>是ubuntu团队维护的一个包。由于之前ubuntu团队有很长一段时间没有维护docker的版本，导致有一段时间docker.io的版本还停留在远古版本。后来ubuntu版本重新开始维护，版本继续送代，截止2021-05-14日，版本已经更新到<code>Docker version 20.10.2</code>。两者使用相同的包管理，<code>docker-ce</code>是所有依赖包由docker团队管理，可以保证docker运行的稳定，适合作为纯docker管理的生产环境，即整个系统只有一个docker在跑，剩下所有应用都通过发布docker的容器来部署。<code>docker-io</code>的依赖包则是由ubuntu统一管理，更符合包管理的理念，也更规范，可以尽可能的保证系统和多个软件的运行稳定，适合作为多软件协同运行的服务器和个人桌面使用。Docker目前是一个被广泛使用的工具，ubuntu再次停止维护的概率不大。所以除了纯docker环境，个人建议直接用<code>docker.io</code>。</p>
</li>
<li>
<p>安装<code>docker.io</code></p>
  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Install Docker</span>
sudo apt install docker.io</code></pre></div>
</li>
<li>
<p>在线安装nvidia-container-toolkit</p>
<ul>
<li>
<p>首先配置package repositories</p>
   <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Get system version</span>
distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)
<span class="hljs-comment"># add public key</span>
curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
<span class="hljs-comment"># add source</span>
curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list
sudo apt-get update</code></pre></div>
</li>
<li>
<p>安装nvidia-container-toolkit</p>
   <div class="code-wrapper"><pre><code class="hljs bsah">sudo apt-get install -y nvidia-container-toolkit</code></pre></div>
</li>
</ul>
</li>
<li>
<p>离线安装nvidia-container-toolkit</p>
<ul>
<li>
<p>在有网络连接的设备上配置package repositories</p>
   <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Get system version</span>
distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)
<span class="hljs-comment"># add public key</span>
curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
<span class="hljs-comment"># add source</span>
curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list
sudo apt-get update</code></pre></div>
</li>
<li>
<p>下载nvidia-container-toolkit套件</p>
   <div class="code-wrapper"><pre><code class="hljs bsah">apt download libnvidia-container1
apt download libnvidia-container-tools
apt download nvidia-container-toolkit
apt download nvidia-container-runtime
apt download nvidia-docker2</code></pre></div>
</li>
<li>
<p>安装nvidia-container-toolkit套件(以下顺序不能改变)</p>
   <div class="code-wrapper"><pre><code class="hljs bsah">dpkg -i libnvidia-container1_***.deb
dpkg -i libnvidia-container-tools_***.deb
dpkg -i nvidia-container-toolkit_***.deb
dpkg -i nvidia-container-runtime_***.deb
dpkg -i nvidia-docker2_***.deb</code></pre></div>
</li>
</ul>
</li>
<li>
<p>安装完成后重启Docker</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl restart docker</code></pre></div>
</li>
<li>
<p>使用该版本Docker创建容器时使用<code>--gpus</code>参数指定使用的GPU编号：</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo docker run -it --gpus all imagename</code></pre></div>
</li>
</ul>
<h5 id="3112-加入docker用户组"><a class="markdownIt-Anchor" href="#3112-加入docker用户组"></a> 3.1.1.2 加入Docker用户组</h5>
<ul>
<li>
<p>创建docker用户组</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo groupadd docker</code></pre></div>
</li>
<li>
<p>将用户加入docker用户组</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$&#123;USER&#125;</span></code></pre></div>
</li>
<li>
<p>重启docker服务</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl restart docker</code></pre></div>
</li>
<li>
<p>切换或者退出当前账户，再重新登入</p>
  <div class="code-wrapper"><pre><code class="hljs bash">su root
su <span class="hljs-variable">$&#123;USER&#125;</span></code></pre></div>
</li>
<li>
<p>添加访问和执行权限(普通用户可不加<code>sudo</code>使用docker)</p>
  <div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> a+rw /var/run/docker.sock</code></pre></div>
</li>
</ul>
<h5 id="3113-查看docker安装信息"><a class="markdownIt-Anchor" href="#3113-查看docker安装信息"></a> 3.1.1.3 查看Docker安装信息</h5>
<p>使用<code>docker info</code>查看 Docker 系统信息，包括镜像和容器数。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker info</code></pre></div>
<p><strong>示例：</strong><br />
查看Docker版本信息。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker info</code></pre></div>
<h5 id="3114-查看docker版本"><a class="markdownIt-Anchor" href="#3114-查看docker版本"></a> 3.1.1.4 查看Docker版本</h5>
<p>使用<code>docker version</code>查看Docker的版本信息。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker version [Options]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-f：指定返回值的模板文件</li>
</ul>
<p><strong>示例：</strong><br />
查看Docker版本信息。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker version</code></pre></div>
<h5 id="3115-卸载docker"><a class="markdownIt-Anchor" href="#3115-卸载docker"></a> 3.1.1.5 卸载Docker</h5>
<ul>
<li>确定您拥有什么已安装的软件包</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">dpkg -l | grep -i docker</code></pre></div>
<ul>
<li>删除软件包服务</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">sudo apt-get purge -y docker.io docker-engine docker
sudo apt-get autoremove -y --purge docker.io docker-engine docker</code></pre></div>
<ul>
<li>删除主机上的映像，容器，卷或用户创建的配置文件</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> -rf /var/lib/docker /etc/docker
sudo <span class="hljs-built_in">rm</span> /etc/apparmor.d/docker
sudo groupdel docker
sudo <span class="hljs-built_in">rm</span> -rf /var/run/docker.sock</code></pre></div>
<h4 id="312-windows安装"><a class="markdownIt-Anchor" href="#312-windows安装"></a> 3.1.2 Windows安装</h4>
<h5 id="3121-启动依赖环境"><a class="markdownIt-Anchor" href="#3121-启动依赖环境"></a> 3.1.2.1 启动依赖环境</h5>
<ul>
<li>
<p><strong>Hyper-V</strong></p>
<ul>
<li>
<p>以管理员身份运行Powershell：</p>
  <div class="code-wrapper"><pre><code class="hljs bash">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All</code></pre></div>
</li>
<li>
<p>在BIOS中开启Virtualization<br />
不同的主板设置不同，基本位于Advanced-&gt;CPU设置中。</p>
</li>
</ul>
</li>
<li>
<p><strong>WSL2</strong></p>
<ul>
<li>必须运行Windows10版本2004及更高版本(内部版本19041及更高版本)或Windows 11。</li>
<li>Windows11中默认安装了WSL内核，如果没有可手动安装。</li>
<li>以管理员身份运行Powershell：  <div class="code-wrapper"><pre><code class="hljs bash">wsl --install</code></pre></div>
此命令将启用所需的可选组件，下载最新的Linux内核，将WSL2设置为默认值，并安装 Linux发行版(默认安装Ubuntu)。</li>
</ul>
</li>
</ul>
<h5 id="3122-安装docker-desktop-for-windows"><a class="markdownIt-Anchor" href="#3122-安装docker-desktop-for-windows"></a> 3.1.2.2 安装Docker Desktop for Windows</h5>
<ul>
<li>
<p>下载安装包<br />
进入<a target="_blank" rel="noopener" href="https://hub.docker.com/?overlay=onboarding">Dokcer官网下载地址</a>，并下载Windows的版本Docker，如果你还没有登录，会要求注册登录。</p>
</li>
<li>
<p>安装<br />
双击安装文件并根据指引完成安装。</p>
</li>
</ul>
<h5 id="3123-下载linux内核更新包"><a class="markdownIt-Anchor" href="#3123-下载linux内核更新包"></a> 3.1.2.3 下载Linux内核更新包</h5>
<p>启动Docker Desktop时可能会要求更新WSL内核版本，在<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">WSL文档中</a>获取<a target="_blank" rel="noopener" href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于x64计算机的WSL2 Linux内核更新包</a>。完成安装后重启Docker即可。</p>
<h5 id="3124-注意事项"><a class="markdownIt-Anchor" href="#3124-注意事项"></a> 3.1.2.4 注意事项</h5>
<ul>
<li>docker运行出现错误<code>error during connect: This error may indicate that the docker daemon is not running.:</code>
<ul>
<li>powershell进入目录&quot;C:\Program Files\Docker\Docker&quot;  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;C:\Program Files\Docker\Docker&quot;</span></code></pre></div>
</li>
<li>执行以下命令  <div class="code-wrapper"><pre><code class="hljs bash">./DockerCli.exe -SwitchDaemon</code></pre></div>
</li>
</ul>
</li>
</ul>
<h3 id="32-镜像命令"><a class="markdownIt-Anchor" href="#32-镜像命令"></a> 3.2 镜像命令</h3>
<h4 id="321-登入登出loginlogout"><a class="markdownIt-Anchor" href="#321-登入登出loginlogout"></a> 3.2.1 登入/登出(login/logout)</h4>
<p>使用<code>docker login</code>登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub；<br />
使用<code>docker logout</code>登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub。<br />
<strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker login [Options] [Server]</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">logout</span> [Options] [Server]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-u：登陆的用户名</li>
<li>-p：登陆的密码</li>
</ul>
<p><strong>示例：</strong><br />
登陆到Docker Hub。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker login -u username -p password</code></pre></div>
<p>登出Docker Hub。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">logout</span></code></pre></div>
<h4 id="322-查找镜像search"><a class="markdownIt-Anchor" href="#322-查找镜像search"></a> 3.2.2 查找镜像(search)</h4>
<p>使用<code>docker search</code>从Docker Hub查找镜像。<br />
<strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker search [Options] TERM</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>–automated：只列出 automated build类型的镜像</li>
<li>–no-trunc：显示完整的镜像描述</li>
<li>-s：列出收藏数不小于指定值的镜像</li>
</ul>
<p><strong>查找到的镜像列表包含：</strong></p>
<ul>
<li><strong>NAME</strong> 镜像名称</li>
<li><strong>DESCRIPTION</strong> 镜像描述</li>
<li><strong>STARS</strong> 星标数量</li>
<li><strong>OFFICIAL</strong> 是否为官方镜像</li>
<li><strong>AUTOMATED</strong> 是否是自动构建的镜像</li>
</ul>
<p><strong>示例：</strong><br />
从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker search -s 10 java</code></pre></div>
<h4 id="323-拉取镜像pull"><a class="markdownIt-Anchor" href="#323-拉取镜像pull"></a> 3.2.3 拉取镜像(pull)</h4>
<p>使用<code>docker pull</code>从镜像仓库中拉取或者更新指定镜像。<br />
<strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker pull [Options] NAME[:TAG|@DIGEST]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-a：拉取所有tagged镜像</li>
<li>–disable-content-trust：忽略镜像的校验，默认开启</li>
</ul>
<p><strong>示例：</strong><br />
从Docker Hub下载<code>java</code>最新版镜像。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker pull java</code></pre></div>
<p>从Docker Hub下载<code>Repository</code>为<code>java</code>的所有镜像。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker pull -a java</code></pre></div>
<h4 id="324-上传镜像push"><a class="markdownIt-Anchor" href="#324-上传镜像push"></a> 3.2.4 上传镜像(push)</h4>
<p>使用<code>docker push</code>将本地的镜像上传到镜像仓库，要先登陆到镜像仓库<br />
<strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker push [Options] NAME[:TAG]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>–disable-content-trust：忽略镜像的校验，默认开启</li>
</ul>
<p><strong>示例：</strong><br />
上传本地镜像<code>myapache:v1</code>到镜像仓库中。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker push myapache:v1</code></pre></div>
<h4 id="325-查看镜像images"><a class="markdownIt-Anchor" href="#325-查看镜像images"></a> 3.2.5 查看镜像(images)</h4>
<p>使用<code>docker images</code>查看本地存在的镜像。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker images [Options] [Repository[:Tag]]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-a：列出本地所有的镜像(含中间映像层，默认情况下，过滤掉中间映像层)</li>
<li>–digests：显示镜像的摘要信息</li>
<li>-f：显示满足条件的镜像</li>
<li>–format：指定返回值的模板文件</li>
<li>–no-trunc：显示完整的镜像信息</li>
<li>-q：只显示镜像ID</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker images</code></pre></div>
<p>列出的镜像列表包含以下信息：</p>
<ul>
<li><strong>REPOSITORY</strong> 镜像来自于哪个仓库，比如ubuntu</li>
<li><strong>TAG</strong> 镜像的标记，比如 14.04</li>
<li><strong>IMAGE ID</strong> 镜像的ID号(唯一)</li>
<li><strong>CREATED</strong> 镜像创建时间</li>
<li><strong>VIRTUAL SIZE</strong> 镜像大小</li>
</ul>
<h4 id="326-载入镜像load"><a class="markdownIt-Anchor" href="#326-载入镜像load"></a> 3.2.6 载入镜像(load)</h4>
<p>使用 <code>docker load</code>对于本地其他方式获得的镜像进行导入。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">docker</span> <span class="hljs-variable">load</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Options</span><span class="hljs-punctuation">]</span> <span class="hljs-built_in">Image</span></code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>–input ， -i：指定导入的文件，代替 STDIN。</li>
<li>–quiet ， -q：精简输出信息。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker load --input fedora.tar</code></pre></div>
<h4 id="327-存出镜像save"><a class="markdownIt-Anchor" href="#327-存出镜像save"></a> 3.2.7 存出镜像(save)</h4>
<p>可以使用<code>docker save</code>将指定镜像保存成tar归档文件。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker save [Options] Image</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-o：输出到的文件。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker save -o ubuntu_16.04.tar ubuntu:16.04</code></pre></div>
<h4 id="328-删除镜像rmi"><a class="markdownIt-Anchor" href="#328-删除镜像rmi"></a> 3.2.8 删除镜像(rmi)</h4>
<p>使用<code>docker rmi</code>删除镜像。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker rmi [Options] Image</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-f：强制删除</li>
<li>–no-prune：不移除该镜像的过程镜像，默认移除</li>
</ul>
<p><strong>示例：</strong><br />
强制删除本地镜像。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker rmi -f ubuntu_16.04.tar</code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><code>docker rm</code>命令是删除容器，而<code>docker rmi</code>命令是删除镜像(remove <strong>i</strong>mage)。</li>
<li>当出现同一个Image ID对应多个Repository:Tag时，使用<code>docker rmi Repository:Tag</code>可以删除对应的镜像，此时会显示<code>Untagged: Repository:Tag</code>；而加上参数<code>-f</code>，使用<code>docker rmi -f ImageID</code>会删除对应Image ID的所有镜像。</li>
</ul>
</blockquote>
<h4 id="329-创建dockerfile"><a class="markdownIt-Anchor" href="#329-创建dockerfile"></a> 3.2.9 创建Dockerfile</h4>
<p>我们可以使用<code>docker build</code>来创建一个新的镜像。首先需要创建一个Dockerfile，包含一些如何创建镜像的指令。</p>
<p>新建一个目录和一个Dockerfile</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> Dockerfile</code></pre></div>
<p>在Dockerfile中写入创建信息，Dockerfile 中每一条指令都创建镜像的一层，例如：</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># This is a comment</span>
<span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">14.04</span>
<span class="hljs-keyword">MAINTAINER</span> Docker Newbee &lt;newbee@docker.com&gt;
<span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -qq update</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -qqy install ruby ruby-dev</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> gem install sinatra</span></code></pre></div>
<p><strong>Dockerfile 基本的语法是：</strong></p>
<ul>
<li><code>#</code> 注释</li>
<li><code>FROM</code> 告诉Docker使用哪个镜像作为基础</li>
<li><code>MAINTAINER</code> 维护者信息</li>
<li><code>RUN</code> 该指令会在创建中运行，比如安装一个软件包，在这里使用<code>apt-get</code>来安装了一些软件</li>
</ul>
<h4 id="3210-从dockerfile创建镜像build"><a class="markdownIt-Anchor" href="#3210-从dockerfile创建镜像build"></a> 3.2.10 从Dockerfile创建镜像(build)</h4>
<p>对于已有的Dockerfile，可以使用<code>docker build</code>来生成镜像。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker build [Options] Path | Url | -</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-f：指定要使用的Dockerfile路径</li>
<li>-t/-tag：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签</li>
<li>–build-arg=[]：设置镜像创建时的变量</li>
<li>–cpu-shares：设置 cpu 使用权重</li>
<li>–cpu-period：限制 CPU CFS周期</li>
<li>–cpu-quota：限制 CPU CFS配额</li>
<li>–cpuset-cpus：指定使用的CPU id</li>
<li>–cpuset-mems：指定使用的内存 id</li>
<li>–disable-content-trust：忽略校验，默认开启</li>
<li>–force-rm：设置镜像过程中删除中间容器</li>
<li>–isolation：使用容器隔离技术</li>
<li>–label=[]：设置镜像使用的元数据</li>
<li>-m：设置内存最大值</li>
<li>–memory-swap：设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap</li>
<li>–no-cache：创建镜像的过程不使用缓存</li>
<li>–pull：尝试去更新镜像的新版本</li>
<li>–quiet， -q：安静模式，成功后只输出镜像ID</li>
<li>–rm：设置镜像成功后删除中间容器</li>
<li>–shm-size：设置/dev/shm的大小，默认值是64M</li>
<li>–ulimit：Ulimit配置</li>
<li>–squash：将 Dockerfile 中所有的操作压缩为一层</li>
<li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li>
</ul>
<p><strong>示例：</strong><br />
使用当前目录(用<code>.</code>表示)的 Dockerfile 创建镜像，标签为 walker/ubuntu:v1。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker build -t walker/ubuntu:v1 .</code></pre></div>
<p>使用URL <a target="_blank" rel="noopener" href="http://github.com/creack/docker-firefox">github.com/creack/docker-firefox</a> 的 Dockerfile 创建镜像。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker build github.com/creack/docker-firefox</code></pre></div>
<p>也可以通过<code>-f</code>指定Dockerfile文件的位置。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker build -f /path/to/a/Dockerfile .</code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<p>在使用<code>docker build</code>命令时，<code>Docker client</code>会发送执行命令时同级目录下的所有文件到<code>Docker daemon</code>，因此建议<code>cd</code>到Dockerfile所在路径，并保证该路径下无其他大文件。</p>
</blockquote>
<h4 id="3211-标记镜像tag"><a class="markdownIt-Anchor" href="#3211-标记镜像tag"></a> 3.2.11 标记镜像(tag)</h4>
<p>使用<code>docker tag</code>标记本地镜像，将其归入某一仓库。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker tag [Options] Image[:Tag] [RegistryHost/][Username/]Name[:Tag]</code></pre></div>
<p><strong>示例：</strong><br />
将镜像ubuntu:15.10标记为 walker/ubuntu:v3 镜像。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker tag ubuntu:15.10 walker/ubuntu:v3</code></pre></div>
<h4 id="3212-镜像历史history"><a class="markdownIt-Anchor" href="#3212-镜像历史history"></a> 3.2.12 镜像历史(history)</h4>
<p>使用<code>docker history</code>查看指定镜像的创建历史。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> [Options] Image</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-H：以可读的格式打印镜像大小和日期，默认为true</li>
<li>–no-trunc：显示完整的提交记录</li>
<li>-q：仅列出提交记录ID</li>
</ul>
<p><strong>示例：</strong><br />
查看本地镜像walker/ubuntu:v3的创建历史。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> walker/ubuntu:v3</code></pre></div>
<h4 id="3213-导入镜像import"><a class="markdownIt-Anchor" href="#3213-导入镜像import"></a> 3.2.13 导入镜像(import)</h4>
<p>使用<code>docker import</code>从归档文件中创建镜像。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker import [Options] file|URL|- [REPOSITORY[:TAG]]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-c：应用docker 指令创建镜像</li>
<li>-m：提交时的说明文字</li>
</ul>
<p><strong>示例：</strong><br />
从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为walker/ubuntu:v4。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker import my_ubuntu_v3.tar walker/ubuntu:v4</code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><code>import</code>与[<code>export</code>](# 3.3.3 导出容器(export))是一对命令，<code>export</code>用于从<strong>容器</strong>导出得到归档文件；而<code>import</code>用于导入归档文件获得镜像 。</li>
<li><code>save</code>与<code>load</code>是一对命令，<code>save</code>用于将镜像到处得到归档文件；而load用于导入归档文件获得镜像。</li>
<li>这四个命令中只有<code>export</code>的操作对象是容器。</li>
</ul>
</blockquote>
<h3 id="33-容器操作"><a class="markdownIt-Anchor" href="#33-容器操作"></a> 3.3 容器操作</h3>
<h4 id="331-列出容器ps"><a class="markdownIt-Anchor" href="#331-列出容器ps"></a> 3.3.1 列出容器(ps)</h4>
<p>使用<code>docker ps</code>列出容器。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker ps [Options]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-a：显示所有的容器，包括未运行的</li>
<li>-f：根据条件过滤显示的内容</li>
<li>–format：指定返回值的模板文件</li>
<li>-l：显示最近创建的容器</li>
<li>-n：列出最近创建的n个容器</li>
<li>–no-trunc：不截断输出</li>
<li>-q：静默模式，只显示容器编号</li>
<li>-s：显示总的文件大小</li>
</ul>
<p><strong>示例：</strong><br />
列出所有在运行的容器信息。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker ps</code></pre></div>
<h4 id="332-连接进入容器attach"><a class="markdownIt-Anchor" href="#332-连接进入容器attach"></a> 3.3.2 连接进入容器(attach)</h4>
<p>使用<code>docker attach</code>连接到正在运行中的容器。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker attach [Options] CONTAINER</code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕(与screen命令的attach类似)。官方文档中说attach后可以通过Ctrl+C来detach，但实际上经过我的测试，如果container当前在运行bash，Ctrl+C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，Ctrl+C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保Ctrl+D或Ctrl+C不会关闭容器。</p>
</blockquote>
<p><strong>示例：</strong><br />
容器<code>mynginx</code>将访问日志指到标准输出，连接到容器查看访问信息。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker attach --sig-proxy=<span class="hljs-literal">false</span> mynginx</code></pre></div>
<h4 id="333-导出容器export"><a class="markdownIt-Anchor" href="#333-导出容器export"></a> 3.3.3 导出容器(export)</h4>
<p>使用<code>docker export</code>将文件系统作为一个tar归档文件导出。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> [Options] CONTAINER</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-o：将输入内容写到文件。</li>
</ul>
<p><strong>示例：</strong><br />
将<code>id</code>为<code>a404c6c174a2</code>的容器按日期保存为tar文件。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> -o mysql-`<span class="hljs-built_in">date</span> +%Y%m%d`.tar a404c6c174a2</code></pre></div>
<h4 id="334-获取元数据inspect"><a class="markdownIt-Anchor" href="#334-获取元数据inspect"></a> 3.3.4 获取元数据(inspect)</h4>
<p>使用<code>docker inspect</code>获取容器/镜像的元数据。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker inspect [Options] NAME|ID [NAME|ID...]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-f：指定返回值的模板文件</li>
<li>-s：显示总的文件大小</li>
<li>–type：为指定类型返回JSON</li>
</ul>
<p><strong>示例：</strong><br />
获取镜像mysql:5.6的元信息。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker inspect mysql:5.6</code></pre></div>
<h4 id="335-容器进程top"><a class="markdownIt-Anchor" href="#335-容器进程top"></a> 3.3.5 容器进程(top)</h4>
<p>使用<code>docker top</code>查看容器中运行的进程信息，支持<code>ps</code>命令参数。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker top [Options] Container [ps Options]</code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<p>容器运行时不一定有<code>/bin/bash</code>终端来交互执行<code>top</code>命令，而且容器还不一定有<code>top</code>命令，可以使用<code>docker top</code>来实现查看container中正在运行的进程。</p>
</blockquote>
<p><strong>示例：</strong><br />
查看容器<code>mymysql</code>的进程信息。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker top mymysql</code></pre></div>
<h4 id="336-容器事件events"><a class="markdownIt-Anchor" href="#336-容器事件events"></a> 3.3.6 容器事件(events)</h4>
<p>使用<code>docker events</code>从服务器获取实时事件。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker events [Options]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-f ：根据条件过滤事件；</li>
<li>–since ：从指定的时间戳后显示所有事件;</li>
<li>–until ：流水时间显示到指定的时间为止；</li>
</ul>
<p><strong>示例：</strong><br />
显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker events -f <span class="hljs-string">&quot;image&quot;</span>=<span class="hljs-string">&quot;mysql:5.6&quot;</span> --since=<span class="hljs-string">&quot;1467302400&quot;</span></code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如<code>--since=&quot;2016-07-01</code>。</p>
</blockquote>
<h4 id="337-容器日志logs"><a class="markdownIt-Anchor" href="#337-容器日志logs"></a> 3.3.7 容器日志(logs)</h4>
<p>使用<code>docker logs</code>获取容器的日志。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker logs [Options] Container</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-f： 跟踪日志输出</li>
<li>–since：显示某个开始时间的所有日志</li>
<li>-t： 显示时间戳</li>
<li>–tail：仅列出最新N条容器日志</li>
</ul>
<p><strong>示例：</strong><br />
跟踪查看容器mynginx的日志输出。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker logs -f mynginx</code></pre></div>
<p>查看容器mynginx从2016年7月1日后的最新10条日志。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker logs --since=<span class="hljs-string">&quot;2016-07-01&quot;</span> --<span class="hljs-built_in">tail</span>=10 mynginx</code></pre></div>
<h4 id="338-阻塞容器wait"><a class="markdownIt-Anchor" href="#338-阻塞容器wait"></a> 3.3.8 阻塞容器(wait)</h4>
<p>使用<code>docker wait</code>阻塞运行直到容器停止，然后打印出它的退出代码。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">wait</span> [Options] Container [Container...]</code></pre></div>
<p><strong>示例：</strong><br />
跟踪查看容器mynginx的日志输出。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">wait</span> mynginx</code></pre></div>
<h4 id="339-容器端口port"><a class="markdownIt-Anchor" href="#339-容器端口port"></a> 3.3.9 容器端口(port)</h4>
<p>使用<code>docker port</code>列出指定的容器的端口映射，或者查找将<code>PRIVATE_PORT NAT</code>到面向公众的端口。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker port [Options] Container [Private_Port[/Proto]]</code></pre></div>
<p><strong>示例：</strong><br />
查看容器mynginx的端口映射情况。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker port mymysql</code></pre></div>
<h4 id="3310-容器提交commit"><a class="markdownIt-Anchor" href="#3310-容器提交commit"></a> 3.3.10 容器提交(commit)</h4>
<p>使用<code>docker commit</code>从容器创建一个新的镜像。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker commit [Options] Container [Repository[:Tag]]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-a：提交的镜像作者；</li>
<li>-c：使用Dockerfile指令来创建镜像；</li>
<li>-m：提交时的说明文字；</li>
<li>-p：在commit时，将容器暂停。</li>
</ul>
<p><strong>yuhong示例：</strong><br />
将容器<code>a404c6c174a2</code>保存为新的镜像，并添加提交人信息和说明信息。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker commit -a <span class="hljs-string">&quot;walker.com&quot;</span> -m <span class="hljs-string">&quot;my apache&quot;</span> a404c6c174a2  mymysql:v1</code></pre></div>
<h4 id="3311-容器数据拷贝cp"><a class="markdownIt-Anchor" href="#3311-容器数据拷贝cp"></a> 3.3.11 容器数据拷贝(cp)</h4>
<p>使用<code>docker cp</code>进行容器与主机之间的数据拷贝。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> [Options] Container:Src_Path Dest_Path|-</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> [Options] Src_Path|- Container:Dedt_Path</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-L：保持源目标中的链接</li>
</ul>
<p><strong>示例：</strong><br />
将主机<code>/www/walker</code>目录拷贝到容器<code>96f7f14e99ab</code>的<code>/www</code>目录下。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /www/walker 96f7f14e99ab:/www/</code></pre></div>
<p>将主机<code>/www/walker</code>目录拷贝到容器<code>96f7f14e99ab</code>中，目录重命名为<code>www</code>。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> /www/walker 96f7f14e99ab:/www</code></pre></div>
<p>将容器<code>96f7f14e99ab</code>的<code>/www</code>目录拷贝到主机的<code>/tmp</code>目录中。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span>  96f7f14e99ab:/www /tmp/</code></pre></div>
<h4 id="3312-容器文件结构diff"><a class="markdownIt-Anchor" href="#3312-容器文件结构diff"></a> 3.3.12 容器文件结构(diff)</h4>
<p>使用<code>docker diff</code>检查容器里文件结构的更改。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker diff [Options] Container</code></pre></div>
<p><strong>示例：</strong><br />
查看容器mymysql的文件结构更改。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker diff mymysql</code></pre></div>
<h3 id="34-容器生命周期管理"><a class="markdownIt-Anchor" href="#34-容器生命周期管理"></a> 3.4 容器生命周期管理</h3>
<h4 id="341-创建容器create"><a class="markdownIt-Anchor" href="#341-创建容器create"></a> 3.4.1 创建容器(create)</h4>
<p>使用<code>docker create</code>创建一个新的容器但不启动它。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker create [Options] Inage [Command] [Arg...]</code></pre></div>
<p><strong>示例：</strong><br />
使用docker镜像nginx:latest创建一个容器，并将容器命名为mywalker</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker create --name mywalker nginx:latest</code></pre></div>
<h4 id="342-运行容器run"><a class="markdownIt-Anchor" href="#342-运行容器run"></a> 3.4.2 运行容器(run)</h4>
<p>使用<code>docker run</code>创建一个新的容器并运行一个命令。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run [Options] Image [Command] [Arg...]</code></pre></div>
<p><strong>常用Options：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">option</th>
<th style="text-align:left">descriptipon</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-a， --attach=[]</td>
<td style="text-align:left">指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项</td>
</tr>
<tr>
<td style="text-align:left">–add-host=[]</td>
<td style="text-align:left">Add a custom host-to-IP mapping (host:ip)</td>
</tr>
<tr>
<td style="text-align:left">–blkio-weight=0</td>
<td style="text-align:left">Block IO (relative weight)， between 10 and 1000</td>
</tr>
<tr>
<td style="text-align:left">–cpu-shares=0</td>
<td style="text-align:left">CPU shares (relative weight)</td>
</tr>
<tr>
<td style="text-align:left">–cap-add=[]</td>
<td style="text-align:left">Add Linux capabilities</td>
</tr>
<tr>
<td style="text-align:left">–cap-drop=[]</td>
<td style="text-align:left">Drop Linux capabilities</td>
</tr>
<tr>
<td style="text-align:left">–cgroup-parent=</td>
<td style="text-align:left">Optional parent cgroup for the container</td>
</tr>
<tr>
<td style="text-align:left">–cidfile=</td>
<td style="text-align:left">Write the container ID to the file</td>
</tr>
<tr>
<td style="text-align:left">–cpu-period=0</td>
<td style="text-align:left">Limit CPU CFS (Completely Fair Scheduler) period</td>
</tr>
<tr>
<td style="text-align:left">–cpu-quota=0</td>
<td style="text-align:left">Limit CPU CFS (Completely Fair Scheduler) quota</td>
</tr>
<tr>
<td style="text-align:left">–cpuset-cpus=</td>
<td style="text-align:left">CPUs in which to allow execution (0-3， 0，1)</td>
</tr>
<tr>
<td style="text-align:left">–cpuset-mems=</td>
<td style="text-align:left">MEMs in which to allow execution (0-3， 0，1)</td>
</tr>
<tr>
<td style="text-align:left">-d， --detach=false</td>
<td style="text-align:left">后台运行容器，并返回容器ID</td>
</tr>
<tr>
<td style="text-align:left">–device=[]</td>
<td style="text-align:left">Add a host device to the container</td>
</tr>
<tr>
<td style="text-align:left">–disable-content-trust=true</td>
<td style="text-align:left">Skip image verification</td>
</tr>
<tr>
<td style="text-align:left">–dns=[]</td>
<td style="text-align:left">指定容器使用的DNS服务器，默认和宿主一致</td>
</tr>
<tr>
<td style="text-align:left">–dns-opt=[]</td>
<td style="text-align:left">Set DNS options</td>
</tr>
<tr>
<td style="text-align:left">–dns-search=[]</td>
<td style="text-align:left">指定容器DNS搜索域名，默认和宿主一致</td>
</tr>
<tr>
<td style="text-align:left">-e， --env=[]</td>
<td style="text-align:left">设置环境变量</td>
</tr>
<tr>
<td style="text-align:left">–entrypoint=</td>
<td style="text-align:left">Overwrite the default ENTRYPOINT of the image</td>
</tr>
<tr>
<td style="text-align:left">–env-file=[]</td>
<td style="text-align:left">从指定文件读入环境变量</td>
</tr>
<tr>
<td style="text-align:left">–expose=[]</td>
<td style="text-align:left">开放一个端口或一组端口</td>
</tr>
<tr>
<td style="text-align:left">–gpu</td>
<td style="text-align:left">使用GPU启动</td>
</tr>
<tr>
<td style="text-align:left">–group-add=[]</td>
<td style="text-align:left">Add additional groups to join</td>
</tr>
<tr>
<td style="text-align:left">-h， --hostname=</td>
<td style="text-align:left">指定容器的hostname</td>
</tr>
<tr>
<td style="text-align:left">–help=false</td>
<td style="text-align:left">Print usage</td>
</tr>
<tr>
<td style="text-align:left">-i， --interactive=false</td>
<td style="text-align:left">以交互模式运行容器，通常与<code>-t</code>一起同时使用</td>
</tr>
<tr>
<td style="text-align:left">–ipc=</td>
<td style="text-align:left">IPC namespace to use</td>
</tr>
<tr>
<td style="text-align:left">–kernel-memory=</td>
<td style="text-align:left">Kernel memory limit</td>
</tr>
<tr>
<td style="text-align:left">-l， --label=[]</td>
<td style="text-align:left">Set meta data on a container</td>
</tr>
<tr>
<td style="text-align:left">–label-file=[]</td>
<td style="text-align:left">Read in a line delimited file of labels</td>
</tr>
<tr>
<td style="text-align:left">–link=[]</td>
<td style="text-align:left">添加链接到另一个容器</td>
</tr>
<tr>
<td style="text-align:left">–log-driver=</td>
<td style="text-align:left">Logging driver for container</td>
</tr>
<tr>
<td style="text-align:left">–log-opt=[]</td>
<td style="text-align:left">Log driver options</td>
</tr>
<tr>
<td style="text-align:left">–lxc-conf=[]</td>
<td style="text-align:left">Add custom lxc options</td>
</tr>
<tr>
<td style="text-align:left">-m， --memory=</td>
<td style="text-align:left">Memory limit</td>
</tr>
<tr>
<td style="text-align:left">–mac-address=</td>
<td style="text-align:left">Container MAC address (e.g. 92:d0:c6:0a:29:33)</td>
</tr>
<tr>
<td style="text-align:left">–memory-reservation=</td>
<td style="text-align:left">Memory soft limit</td>
</tr>
<tr>
<td style="text-align:left">–memory-swap=</td>
<td style="text-align:left">Total memory (memory + swap)， ‘-1’ to disable swap</td>
</tr>
<tr>
<td style="text-align:left">–memory-swappiness=-1</td>
<td style="text-align:left">Tuning container memory swappiness (0 to 100)</td>
</tr>
<tr>
<td style="text-align:left">–name=</td>
<td style="text-align:left">为容器指定一个名称</td>
</tr>
<tr>
<td style="text-align:left">–net=default</td>
<td style="text-align:left">指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型</td>
</tr>
<tr>
<td style="text-align:left">–oom-kill-disable=false</td>
<td style="text-align:left">Disable OOM Killer</td>
</tr>
<tr>
<td style="text-align:left">-P， --publish-all=false</td>
<td style="text-align:left">Publish all exposed ports to random ports</td>
</tr>
<tr>
<td style="text-align:left">-p， --publish=[]</td>
<td style="text-align:left">指定端口映射，格式为：主机(宿主)端口:容器端口</td>
</tr>
<tr>
<td style="text-align:left">–pid=</td>
<td style="text-align:left">PID namespace to use</td>
</tr>
<tr>
<td style="text-align:left">–privileged=false</td>
<td style="text-align:left">Give extended privileges to this container</td>
</tr>
<tr>
<td style="text-align:left">–read-only=false</td>
<td style="text-align:left">Mount the container’s root filesystem as read only</td>
</tr>
<tr>
<td style="text-align:left">–restart=no</td>
<td style="text-align:left">Restart policy to apply when a container exits</td>
</tr>
<tr>
<td style="text-align:left">–rm=false</td>
<td style="text-align:left">Automatically remove the container when it exits</td>
</tr>
<tr>
<td style="text-align:left">–runtime=nvidia</td>
<td style="text-align:left">在安装nvidia-docker的情况下，使用该参数可以在docker中使用GPU及Nvidia驱动</td>
</tr>
<tr>
<td style="text-align:left">–security-opt=[]</td>
<td style="text-align:left">Security Options</td>
</tr>
<tr>
<td style="text-align:left">–shm-size=</td>
<td style="text-align:left">指定容器的shared memory</td>
</tr>
<tr>
<td style="text-align:left">–sig-proxy=true</td>
<td style="text-align:left">Proxy received signals to the process</td>
</tr>
<tr>
<td style="text-align:left">–stop-signal=SIGTERM</td>
<td style="text-align:left">Signal to stop a container， SIGTERM by default</td>
</tr>
<tr>
<td style="text-align:left"><strong>-t， --tty=false</strong></td>
<td style="text-align:left">为容器重新分配一个伪输入终端</td>
</tr>
<tr>
<td style="text-align:left">-u， --user=</td>
<td style="text-align:left">Username or UID (format: &lt;name</td>
</tr>
<tr>
<td style="text-align:left">–ulimit=[]</td>
<td style="text-align:left">Ulimit options</td>
</tr>
<tr>
<td style="text-align:left">–uts=</td>
<td style="text-align:left">UTS namespace to use</td>
</tr>
<tr>
<td style="text-align:left">-v， --volume=[]</td>
<td style="text-align:left">挂载目录</td>
</tr>
<tr>
<td style="text-align:left">–volume-driver=</td>
<td style="text-align:left">Optional volume driver for the container</td>
</tr>
<tr>
<td style="text-align:left">–volumes-from=[]</td>
<td style="text-align:left">Mount volumes from the specified container(s)</td>
</tr>
<tr>
<td style="text-align:left">-w， --workdir=</td>
<td style="text-align:left">Working directory inside the container</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<p><strong>使用镜像nginx:latest以交互模式启动一个容器，命名为mynginx，使用GPU启动，同时将宿主机<code>/data1/walker</code>挂载到docker的<code>/share</code>文件夹下，将宿主机2333端口映射到容器的22端口，为容器分配2G共享内存(Shared Memory)</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run -it --runtime=nvidia --name=mynginx -v /data1/walker:/share -p 2323:22 --shm-size=<span class="hljs-string">&quot;2g&quot;</span> nginx:latest</code></pre></div>
<p>使用docker镜像nginx:latest以后台模式启动一个容器，并将容器命名为mynginx。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run --name mynginx -d nginx:latest</code></pre></div>
<p>使用镜像nginx:latest以后台模式启动一个容器，并将容器的80端口映射到主机随机端口。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run -P -d nginx:latest</code></pre></div>
<p>使用镜像 nginx:latest，以后台模式启动一个容器，将容器的 80 端口映射到主机的 80 端口，主机的目录 /data 映射到容器的 /data。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run -p 80:80 -v /data:/data -d nginx:latest</code></pre></div>
<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</code></pre></div>
<h4 id="343-容器启动停止重启startstoprestart"><a class="markdownIt-Anchor" href="#343-容器启动停止重启startstoprestart"></a> 3.4.3 容器启动/停止/重启(start/stop/restart)</h4>
<p>使用<code>docker start</code>启动一个或多个已经被停止的容器；<br />
使用<code>docker stop</code>停止一个运行中的容器；<br />
使用<code>docker restart</code>重启容器。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker start [Options] Container [Container...]</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs bash">docker stop [Options] Container [Container...]</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs bash">docker restart [Options] Container [Container...]</code></pre></div>
<p><strong>示例：</strong><br />
启动已被停止的容器<code>mywalker</code>。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker start mywalker</code></pre></div>
<p>停止运行中的容器<code>mywalker</code>。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker stop mywalker</code></pre></div>
<p>重启容器<code>mywalker</code>。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker restart mywalker</code></pre></div>
<h4 id="344-容器强制停止kill"><a class="markdownIt-Anchor" href="#344-容器强制停止kill"></a> 3.4.4 容器强制停止(kill)</h4>
<p>使用<code>docker kill</code>杀掉一个运行中的容器。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> [Options] Container [Container...]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-s：向容器发送一个信号</li>
</ul>
<p><strong>示例：</strong><br />
杀掉运行中的容器mynginx。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> -s KILL myngin</code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<p><code>docker kill</code>命令不管容器同不同意，执行强行终止；<code>docker stop</code>命令首先给容器发送一个SIGTERM信号，让容器做一些退出前必须的保护性、安全性操作，然后让容器自动停止运行，这是一种更为优雅的退出方式；如果在一段时间内，容器还是没有停止，再考虑使用<code>docker kill</code>命令强行终止。</p>
</blockquote>
<h4 id="345-删除容器rm"><a class="markdownIt-Anchor" href="#345-删除容器rm"></a> 3.4.5 删除容器(rm)</h4>
<p>使用<code>docker rm</code>删除一个或多个容器。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> [Options] Container [Container...]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-f：通过 SIGKILL 信号强制删除一个运行中的容器</li>
<li>-l：移除容器间的网络连接，而非容器本身</li>
<li>-v：删除与容器关联的卷</li>
</ul>
<p><strong>示例：</strong><br />
强制删除容器 db01、db02。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f db01 db02</code></pre></div>
<p>移除容器 nginx01 对容器 db01 的连接，连接名 db。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f db01 db02</code></pre></div>
<p>删除容器 nginx01， 并删除容器挂载的数据卷。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -v nginx01</code></pre></div>
<p>删除所有已经停止的容器。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)</code></pre></div>
<p><strong>注意：</strong></p>
<blockquote>
<p><code>docker rm</code>命令是删除容器，而<code>docker rmi</code>命令是删除镜像(remove <strong>i</strong>mage)。</p>
</blockquote>
<h4 id="346-容器暂停与恢复pauseunpause"><a class="markdownIt-Anchor" href="#346-容器暂停与恢复pauseunpause"></a> 3.4.6 容器暂停与恢复(pause/unpause)</h4>
<p>使用<code>docker pause</code>暂停容器中所有的进程；<br />
使用<code>docker unpause</code>恢复容器中所有的进程。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker pause [Options] Container [Container...]</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs bash">docker unpause [Options] Container [Container...]</code></pre></div>
<p><strong>示例：</strong><br />
暂停数据库容器db01提供服务。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker pause db01</code></pre></div>
<p>恢复数据库容器db01提供服务。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker unpause db01</code></pre></div>
<h4 id="347-容器执行命令exec"><a class="markdownIt-Anchor" href="#347-容器执行命令exec"></a> 3.4.7 容器执行命令(exec)</h4>
<p>使用<code>docker exec</code>在运行的容器中执行命令。</p>
<p><strong>语法：</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> [Options] Container Command [Arg...]</code></pre></div>
<p><strong>常用Options：</strong></p>
<ul>
<li>-d：分离模式: 在后台运行</li>
<li>-i：即使没有附加也保持STDIN 打开</li>
<li>-t：分配一个伪终端</li>
</ul>
<p><strong>示例：</strong><br />
在容器<code>mynginx</code>中以交互模式执行容器内<code>/root/runoob.sh</code>脚本。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mynginx /bin/sh /root/runoob.sh</code></pre></div>
<p>在容器 mynginx 中开启一个交互模式的终端。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  mynginx /bin/bash</code></pre></div>
<p>也可以通过<code>docker ps</code>命令查看已经在运行的容器，然后使用容器ID进入容器，再通过<code>docker exec</code>命令对指定的容器执行bash。</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker ps
docker <span class="hljs-built_in">exec</span> -it 9df70f9a0714 /bin/bash</code></pre></div>
<h3 id="35-docker清理命令汇总"><a class="markdownIt-Anchor" href="#35-docker清理命令汇总"></a> 3.5 Docker清理命令汇总</h3>
<p><strong>杀死所有正在运行的容器</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> $(docker ps -a -q)</code></pre></div>
<p><strong>删除所有已经停止的容器</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)</code></pre></div>
<p><strong>删除所有未打<code>dangling</code>标签的镜像</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker rmi $(docker images -q -f dangling=<span class="hljs-literal">true</span>)</code></pre></div>
<p><strong>通过镜像的<code>id</code>来删除指定镜像</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker rmi $(docker images -q)</code></pre></div>
<p><strong>删除所有镜像</strong></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker rmi &lt;image <span class="hljs-built_in">id</span>&gt;</code></pre></div>
<h2 id="4-docker仓库管理"><a class="markdownIt-Anchor" href="#4-docker仓库管理"></a> 4 Docker仓库管理</h2>
<p>仓库<code>Repository</code>是集中存放镜像的地方。以下介绍一下 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。当然不止DockerHub，只是远程的服务商不一样，操作都是一样的。</p>
<h3 id="41-docker-hub"><a class="markdownIt-Anchor" href="#41-docker-hub"></a> 4.1 Docker Hub</h3>
<p>目前 Docker 官方维护了一个公共仓库<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<ul>
<li>
<p><strong>注册</strong><br />
在<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>免费注册一个 Docker 账号。</p>
</li>
<li>
<p><strong>登录和退出</strong><br />
登录需要输入用户名和密码，使用[<code>docker login(点击查看)</code>](#3.2.1 登入/登出(login/logout))命令登录成功后，我们就可以从Docker Hub上拉取自己账号下的全部镜像。使用[<code>docker logout(点击查看)</code>](#3.2.1 登入/登出(login/logout))命令即可退出登录。</p>
</li>
<li>
<p><strong>拉取镜像</strong><br />
你可以通过[<code>docker search</code>](#3.2.2 查找镜像(search))命令来查找官方仓库中的镜像，并利用[<code>docker pull</code>](#3.2.3 拉取镜像(pull))命令来将它下载到本地。以 ubuntu 为关键词进行搜索：</p>
</li>
<li>
<p><strong>推送镜像</strong><br />
用户登录后，可以通过[<code>docker push</code>](#3.2.4 上传镜像(push))命令将自己的镜像推送到Docker Hub。</p>
</li>
</ul>
<h3 id="42-阿里云容器hub"><a class="markdownIt-Anchor" href="#42-阿里云容器hub"></a> 4.2 阿里云容器Hub</h3>
<p>我们使用Docker的第一步，应该是获取一个官方的镜像，例如mysql、wordpress，基于这些基础镜像我们可以开发自己个性化的应用。我们可以使用Docker命令行工具来下载官方镜像。但是因为网络原因，我们下载一个300M的镜像需要很长的时间，甚至下载失败。可以通过设置镜像代理站点/加速器的方式来对下载加速。<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云容器Hub</a>服务提供了官方的镜像站点加速官方镜像的下载速度。在该网站登录可以获得加速器地址，格式为<code>https://*****.mirror.aliyuncs.com</code>。</p>
<p>当你下载安装的Docker Version不低于1.10时，建议直接通过<code>daemon config</code>进行配置。</p>
<p>使用配置文件 /etc/docker/daemon.json(没有时新建该文件)。</p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&lt;your accelerate address&gt;&quot;</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>
<p>然后重启Docker Daemon就可以了。</p>
<div class="code-wrapper"><pre><code class="hljs bash">sudo systemctl daemon-reload
sudo systemctl restart docker</code></pre></div>
<h2 id="5-docker网络模式"><a class="markdownIt-Anchor" href="#5-docker网络模式"></a> 5 Docker网络模式</h2>
<p>docker共有4种网络模式，其中自带3种网络模式：分别是<code>bridge</code>网络，<code>host</code>网络，<code>none</code>网络，可以使用以下命令查看。</p>
<div class="code-wrapper"><pre><code class="hljs bash">$ docker network <span class="hljs-built_in">ls</span>
NETWORK ID     NAME      DRIVER    SCOPE
40bf4cb78250   bridge    bridge    <span class="hljs-built_in">local</span>
59609bcae8c7   host      host      <span class="hljs-built_in">local</span>
4ba3f22b12f7   none      null      <span class="hljs-built_in">local</span></code></pre></div>
<h3 id="51-host网络"><a class="markdownIt-Anchor" href="#51-host网络"></a> 5.1 host网络</h3>
<p>创建容器时，可以使用<code>-net=host</code>指定。</p>
<p>启动的容器如果指定了网络类型为<code>host</code>模式，那么新创建的容器不会创建自己的虚拟网卡，而是直接使用宿主机的网卡和IP地址，因此容器里面查看到的IP信息就是宿主机的信息，访问容器的时候直接使用<code>宿主机IP:容器端口</code>即可，不过容器的其它资源们比如文件系统，系统进程等还是和宿主机保持隔离。</p>
<p>此模式的网络性能最高，但是各容器之间端口不能相同(因为该模式直接使用的是宿主机的网络)，适用于运行容器端口比较固定的业务，比如Mysql，Redis等。</p>
<p>该模式也有一个缺点，容器内已经使用的端口就不能再用了，并且网络的隔离性不好。例如，当通过ssh的方式直接远程登陆至该容器内部时，端口号<code>22</code>已经被宿主机占用，此时需要修改容器内部ssh端口号，并通过<code>宿主机IP:修改后的端口</code>登录。</p>
<h3 id="52-none模式"><a class="markdownIt-Anchor" href="#52-none模式"></a> 5.2 none模式</h3>
<p>创建容器时，可以使用<code>-net=none</code>指定。</p>
<p>在使用<code>none</code>模式后，docker容器不会进行任何网络配置，其没有网卡，没有IP也没有路由，因此默认无法与外界通信，需要手动添加配置IP等，所以极少使用。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p>
<h3 id="53-bridge模式"><a class="markdownIt-Anchor" href="#53-bridge模式"></a> 5.3 bridge模式</h3>
<p>docker的默认模式就是<code>bridge</code>模式，也是使用比较多的模式，此模式创建的容器会为每一个容器分配自己的网络IP等信息，并将容器连接到一个虚拟网桥与外界通信。</p>
<h3 id="54-container模式"><a class="markdownIt-Anchor" href="#54-container模式"></a> 5.4 container模式</h3>
<p>创建容器时，可以使用&quot;-net=container:容器名称或容器ID&quot;指定。</p>
<p>使用此模式创建的容器需指定和一个已经存在的容器共享一个网络，而不是和宿主机共享网络，换句话说，就是两个容器公用同一个IP地址。</p>
<p>新创建的容器不会创建自己的网卡也不会配置自己的IP，而是和一个已经存在的被指定的容器IP和端口范围，因此这个容器的端口不能和被指定的端口冲突，除了网络之外的文件系统，进程信息等仍然保持相互隔离，两个容器的进程可以通过lo网卡设备通信。</p>
<h2 id="6-docker-ssh远程调试"><a class="markdownIt-Anchor" href="#6-docker-ssh远程调试"></a> 6 Docker-SSH远程调试</h2>
<p>本章详细讲述使用Pycharm进行远程调试的方法。</p>
<h3 id="61-远程服务器docker宿主机ssh配置"><a class="markdownIt-Anchor" href="#61-远程服务器docker宿主机ssh配置"></a> 6.1 远程服务器(Docker宿主机)SSH配置</h3>
<p>确保宿主机正确安装openssh-server服务，默认端口22，可以自行修改。</p>
<h3 id="62-docker-container-ssh配置"><a class="markdownIt-Anchor" href="#62-docker-container-ssh配置"></a> 6.2 Docker Container SSH配置</h3>
<p>要想通过本地Pycharm调试服务器中的Docker容器中的代码，需要进行端口映射操作；即我们通过端口映射将容器内部向宿主机的一个端口转发出来，然后通过本地Pycharm连接该转发出来的端口，即可对容器内部代码进行调试。</p>
<ul>
<li>启动Dockers容器时指定参数<code>p</code>，将Dockers容器内部端口映射到宿主机端口：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">docker run -it -p 2021:22 55914e782b13</code></pre></div>
<p>启动参数<code>-p 2021:22</code>表示端口映射，将容器内部的<code>22</code>端口映射到宿主机的<code>2021</code>端口。</p>
<ul>
<li>Docker容器内安装openssh-server服务</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">apt update &amp;&amp; apt install openssh-server</code></pre></div>
<ul>
<li>Docker容器内配置openssh-server服务</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 将root的密码修改为test</span>
$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:12345&#x27;</span> | chpasswd

<span class="hljs-comment"># 允许使用root身份登录</span>
$ sed -i <span class="hljs-string">&#x27;s/PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config

<span class="hljs-comment"># 限制 PAM方式登录</span>
$ sed <span class="hljs-string">&#x27;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#x27;</span> -i /etc/pam.d/sshd

$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export VISIBLE=now&quot;</span> &gt;&gt; /etc/profile</code></pre></div>
<p>可将以上代码写成<code>docker_config.sh</code>文件，在Docker容器内运行</p>
<ul>
<li>Docker容器内重启openssh-server服务</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">service ssh restart</code></pre></div>
<h3 id="63-测试ssh端口映射配置"><a class="markdownIt-Anchor" href="#63-测试ssh端口映射配置"></a> 6.3 测试SSH端口映射配置</h3>
<ul>
<li>Docker容器中ssh服务端口在远程服务器上的映射</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">docker port &lt;your container name&gt; 22

<span class="hljs-comment"># 输出结果如下所示</span>
0.0.0.0:2021</code></pre></div>
<h3 id="64-本地设备windowslinux的pycharm配置"><a class="markdownIt-Anchor" href="#64-本地设备windowslinux的pycharm配置"></a> 6.4 本地设备(Windows/Linux)的Pycharm配置</h3>
<ul>
<li>
<p>在Pycharm中配置Deployment</p>
  <div style="text-align: center">
  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Deployment.png" srcset="/img/loading.gif" lazyload alt="Pycharm Deployment" width="40%">
  </div>
</li>
<li>
<p>新建SFTP连接</p>
  <div style="text-align: center">
  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Connection.png" srcset="/img/loading.gif" lazyload alt="Pycharm SFTP Connection" width="60%">
  </div>
<p>其中Host填写宿主机IP地址，Port填写Docker容器转发到宿主机的端口(即刚才的<code>2021</code>)，Usernam填写<code>root</code>，passward即为先前在容器内部设置的<code>12345</code>，选择好Root Path后选择Mappings。</p>
</li>
<li>
<p><strong>新建SFTP连接(ipv6)</strong><br />
如果你的宿主机IP地址是ipv6的，那么需要配置Pycharm的ipv6支持：</p>
<ul>
<li>在pycharm中打开<code>Help</code> -&gt; <code>Edit Custom VM Options</code></li>
<li>在该文件中添加一行<code>-Djava.net.preferIPv6Addresses=true</code></li>
<li>将<code>-Djava.net.preferIPv4Stack=false</code>由<code>true</code>改为<code>false</code>(备选)  <div style="text-align: center">
  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-VM-Options.png" srcset="/img/loading.gif" lazyload alt="Pycharm VM Options" width="60%">
  </div>
</li>
<li>重启Pycharm</li>
<li>按照ipv4的方式新建SFTP连接，Host处填写ipv6地址，不过要使用英文中括号<code>[]</code>包裹  <div style="text-align: center">
  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Connection-ipv6.png" srcset="/img/loading.gif" lazyload alt="Pycharm SFTP Connection ipv6" width="60%">
  </div>
</li>
</ul>
</li>
<li>
<p>映射本地项目至远程服务器</p>
  <div style="text-align: center">
  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-SFTP-Mappings.png" srcset="/img/loading.gif" lazyload alt="Pycharm SFTP Mappings" width="70%">
  </div>
<p>Local path是当前项目路径，Deployment path是远程服务器同步的项目路径。选择完毕后确定。Tools -&gt; Deployment -&gt; Browse Remote Host可以查看远程项目文件。</p>
</li>
<li>
<p>配置Python远程解释器</p>
<ul>
<li>
<p>查看远程Python解释器位置(进入Docker容器内部)</p>
   <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> python
<span class="hljs-comment"># 输出如下</span>
/opt/conda/bin/python</code></pre></div>
</li>
<li>
<p>添加远程Python解释器<br />
在Pycharm中Add Python Interpret，选择SSH Interpret -&gt; Existing server configuration，选择我们刚才配置的SFTP Deployment，若无法下一步，点击<code>move</code>。接着Interpret路径选择刚才找到的Python解释器位置，同步文件夹(Sync folders)修改为远程项目地址，去掉勾选自动上传。</p>
   <div style="text-align: center">
   <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Interpret-Add.png" srcset="/img/loading.gif" lazyload alt="Pycharm Interpret Add" width="70%">
   </div>
   <div style="text-align: center">
   <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Interpret-Config.png" srcset="/img/loading.gif" lazyload alt="Pycharm Interpret Config" width="70%">
   </div>
</li>
</ul>
</li>
<li>
<p>配置上传方式Tools -&gt; Deployment -&gt; Options，将自动上传改为<code>Ctrl+S</code>。</p>
  <div style="text-align: center">
  <img style="margin: 5px 5px; border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,0.12), 0 2px 10px 0 rgba(34,36,38,0.08);" src="Pycharm-Deployment-Options.png" srcset="/img/loading.gif" lazyload alt="Pycharm Deployment Options" width="50%">
  </div>
</li>
</ul>
<h2 id="7-docker使用常见问题"><a class="markdownIt-Anchor" href="#7-docker使用常见问题"></a> 7. Docker使用常见问题</h2>
<h3 id="71-docker容器内用户选择"><a class="markdownIt-Anchor" href="#71-docker容器内用户选择"></a> 7.1 Docker容器内用户选择</h3>
<p>Docker在启动时，默认使用的时宿主机的root用户的uid，这就导致两个问题：一时Docker具有宿主机的root权限，安全性很低；二是这样启动的容器如果挂载了宿主机文件，那么在运行时容器所生成的文件在宿主机看来具有root权限，owner是root，这样可能会存在权限上的一些问题。相应的解决方法有两个：</p>
<ul>
<li>
<p>启动容器时指定uid与gid<br />
如果我们想以宿主机的某个用户启动docker，那么在启动时指定参数<code>-u</code>，获取宿主机用户uid和gid的方法如下：</p>
  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> &lt;username&gt;</code></pre></div>
<p>然后根据获得的id指定启动参数</p>
  <div class="code-wrapper"><pre><code class="hljs bash">docker run -it --gpus all --name=yuhong -u 1001:1001  55914e782b13</code></pre></div>
<p>但是这种方法要求docker容器内已经有对应id的用户组及用户，因此不方便使用。</p>
</li>
<li>
<p>启动容器后在内部建立用户<br />
同样的，我们先在获取宿主机用户uid和gid：</p>
  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> &lt;username&gt;</code></pre></div>
<p>接着在容器内部建立对应id的用户，例如：</p>
  <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 首先设定root密码，防止无法切回账号</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:12345&#x27;</span> | chpasswd
groupadd -g 1001 student
<span class="hljs-comment"># 指定命令行为bash</span>
useradd -u 1001 -g student -s /bin/bash yuhong 
<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;yuhong:12345&#x27;</span> | chpasswd</code></pre></div>
<p>切换至新建的用户</p>
  <div class="code-wrapper"><pre><code class="hljs bash">su yuhong</code></pre></div>
</li>
<li>
<p>如果容器内部所使用的Python环境并非对所有用户有效(例如Conda环境)，可以先查找环境位置，切换用户再激活环境。</p>
  <div class="code-wrapper"><pre><code class="hljs bash">su root
<span class="hljs-built_in">which</span> python
su yuhong
<span class="hljs-built_in">cd</span> &lt;python path&gt;
<span class="hljs-built_in">source</span> activate</code></pre></div>
</li>
<li>
<p>当在Pycharm中使用非root用户的Deployment时，此用户连接ssh远程解释器可能出现permission denied的情况，此时可以考虑在Docker容器内部建立该用户的home文件夹，并将文件夹权限修改为该用户可用(xrw)，由于此时该用户uid和gid都与root不同，因此需要给<code>777</code>权限。</p>
</li>
</ul>
<h3 id="72-docker容器内部无法联网"><a class="markdownIt-Anchor" href="#72-docker容器内部无法联网"></a> 7.2 Docker容器内部无法联网</h3>
<p>解决方法：在启动时增加参数<code>--net host</code></p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run -it --gpus all --name=yuhong --net host  55914e782b13</code></pre></div>
<h3 id="73-importerror"><a class="markdownIt-Anchor" href="#73-importerror"></a> 7.3 ImportError</h3>
<p>在容器内部使用python，导入模块时报错&quot;ImportError: libGL.so.1: cannot open shared object file: No such file or directory&quot;。</p>
<p>解决方法：容器内安装libgl1-mesa-glx</p>
<div class="code-wrapper"><pre><code class="hljs bash">apt install libgl1-mesa-glx</code></pre></div>
<h3 id="74-no-command-specified"><a class="markdownIt-Anchor" href="#74-no-command-specified"></a> 7.4 No command specified</h3>
<p>从容器启动Docker的时候报错&quot;Error response from daemon: No command specified&quot;。</p>
<p>解决方法：指定命令行</p>
<div class="code-wrapper"><pre><code class="hljs bash">docker run -t -i 87e5b6b3ccc1 /bin/bash</code></pre></div>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Technology/" class="category-chain-item">Technology</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/Tutorial/" class="category-chain-item">Tutorial</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Technology/">#Technology</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Docker</div>
      <div>http://example.com/docker/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Deluge Walker</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 21, 2021</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/bittorrent/" title="BitTorrent">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">BitTorrent</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/linux/" title="Linux">
                        <span class="hidden-mobile">Linux</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>







  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
